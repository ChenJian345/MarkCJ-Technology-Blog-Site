<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" version="2.0"><channel><title>Crazy Mark</title><description>Thoughts &amp; Ideas.</description><link>http://localhost:2368/</link><image><url>http://localhost:2368/favicon.png</url><title>Crazy Mark</title><link>http://localhost:2368/</link></image><generator>Ghost 1.20</generator><lastBuildDate>Wed, 24 Jul 2019 04:58:07 GMT</lastBuildDate><atom:link href="http://localhost:2368/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title>WWDC19 iOS Related Session List</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="swiftui"&gt;SwiftUI&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://developer.apple.com/videos/play/wwdc2019/204/"&gt;Introducing SwiftUI: Building Your First App&lt;/a&gt;&lt;br&gt;
&lt;em&gt;See SwiftUI in action! Watch as engineers from the SwiftUI team build a fully-functioning app from scratch. Understand the philosophy driving this new framework and learn about the benefits of declarative-style programming. Take a look under the hood to understand how SwiftUI operates&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</description><link>http://localhost:2368/2019/07/10/wwdc19-ios-related-session-list/</link><guid isPermaLink="false">5d253ced4be6e2da3aebf36b</guid><dc:creator>Mark Chen</dc:creator><pubDate>Wed, 10 Jul 2019 03:39:27 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="swiftui"&gt;SwiftUI&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://developer.apple.com/videos/play/wwdc2019/204/"&gt;Introducing SwiftUI: Building Your First App&lt;/a&gt;&lt;br&gt;
&lt;em&gt;See SwiftUI in action! Watch as engineers from the SwiftUI team build a fully-functioning app from scratch. Understand the philosophy driving this new framework and learn about the benefits of declarative-style programming. Take a look under the hood to understand how SwiftUI operates and learn how SwiftUI and Xcode 11 work together to help you to build great apps, faster.&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://developer.apple.com/videos/play/wwdc2019/216/"&gt;SwiftUI Essentials&lt;/a&gt;&lt;br&gt;
Take your first deep-dive into building an app with SwiftUI. Learn about Views and how they work. From basic controls to sophisticated containers like lists and navigation stacks, SwiftUI enables the creation of great user interfaces, faster and more easily. See how basic controls like Button are both simple yet versatile. Discover how to compose these pieces into larger, full-featured user interfaces that facilitate building great apps with SwiftUI. Build your SwiftUI skills as you learn the essentials of Apple’s new declarative framework.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://developer.apple.com/videos/play/wwdc2019/226/"&gt;Data Flow Through SwiftUI&lt;/a&gt;&lt;br&gt;
SwiftUI was built from the ground up to let you write beautiful and correct user interfaces free of inconsistencies. Learn how to connect your data as dependencies while keeping the UI fully predictable and error free. Familiarize yourself with SwiftUI’s powerful data flow tools and understand what the best tool is for each situation.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://developer.apple.com/videos/play/wwdc2019/237/"&gt;Building Custom Views with SwiftUI&lt;/a&gt;&lt;br&gt;
Learn how to build custom views and controls in SwiftUI with advanced composition, layout, graphics, and animation. See a demo of a high performance, animatable control and watch it made step by step in code. Gain a deeper understanding of the layout system of SwiftUI.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://developer.apple.com/videos/play/wwdc2019/231/"&gt;Integrating SwiftUI&lt;/a&gt;&lt;br&gt;
SwiftUI is designed to integrate with your existing code base on any of Apple’s platforms. Learn how to adopt SwiftUI on any Apple platform by adding SwiftUI views into your app’s hierarchy, leveraging your existing data model and more.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://developer.apple.com/videos/play/wwdc2019/240/"&gt;SwiftUI On All Devices&lt;/a&gt;&lt;br&gt;
Once you’ve learned the basics of SwiftUI, you’ve learned what you need to know to use SwiftUI anywhere. You can use the same SwiftUI skills for making an iOS app as you would for making an app on watchOS, tvOS or macOS. We'll cover the basics, and then dig into more detail about how SwiftUI can help you make changes to your app on every Apple device. Hear about design principles for each platform and learn about how much code you can share across platforms. See how to incorporate device-specific features and how to make changes in SwiftUI by following along with a starter project, available for download.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="applesignin"&gt;Apple SignIn&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://developer.apple.com/videos/play/wwdc2019/706/"&gt;Introducing Sign In with Apple&lt;/a&gt;&lt;br&gt;
Sign In with Apple is the fast, easy way for people to sign in to apps using the Apple IDs they already have. Learn how easy it is to add a Sign In with Apple button to your app or website to acquire new customers and benefit from the built-in security, antifraud, and privacy that Sign In with Apple provides.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="location"&gt;Location&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://developer.apple.com/videos/play/wwdc2019/705/"&gt;What's New in Core Location&lt;/a&gt;&lt;br&gt;
Location technologies are core to delivering context-based services within your app. Discover how the latest features in the Core Location Framework lay the groundwork for advanced ranging capabilities and delivers more options for you to clearly communicate your location needs to your users, and allow them to provide more granular access authorization to your app.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="appdistribution"&gt;App Distribution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://developer.apple.com/videos/play/wwdc2019/304/"&gt;App Distribution – From Ad-hoc to Enterprise&lt;/a&gt;&lt;br&gt;
Whether you want to share your app with a few colleagues, deliver it to employees within an organization, or release it to the world, there's a distribution mechanism designed to fit your needs. Familiarize yourself with each app deployment model, learn how to choose the one that's best for you, and learn about essential testing and distribution tools.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="combine"&gt;Combine&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://developer.apple.com/videos/play/wwdc2019/711/"&gt;Introducing Combine and Advances in Foundation&lt;/a&gt;&lt;br&gt;
Combine is a unified declarative framework for processing values over time. Learn how it can simplify asynchronous code like networking, key value observing, notifications and callbacks. Hear about improvements to Foundation collections, performance, internationalization features and Swift integration.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://developer.apple.com/videos/play/wwdc2019/721/"&gt;Combine in Practice&lt;/a&gt;&lt;br&gt;
Expand your knowledge of Combine, Apple's new unified, declarative framework for processing values over time. Learn about how to correctly handle errors, schedule work and integrate Combine into your app today.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="tools"&gt;Tools&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://developer.apple.com/videos/play/wwdc2019/401/"&gt;What's New in Xcode 11&lt;/a&gt;&lt;br&gt;
Start the week with a tour of new features in Xcode 11, designed to help you get from idea to product faster than ever. Discover new ways to edit and organize your source code, new capabilities for designing and previewing user interfaces, and great improvements for debugging and testing. Get an overview for sessions covering developer tools this year.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://developer.apple.com/videos/play/wwdc2019/411/"&gt;Getting Started with Instruments&lt;/a&gt;&lt;br&gt;
The Instruments app in Xcode provides a rich set of tools and templates for profiling your app performance. Learn all about Instruments and gain strategies for identifying bottlenecks in your code. See just how to leverage the power of time profiling and points of interest tracking to make meaningful changes to your code that can dramatically improve app responsiveness.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://developer.apple.com/videos/play/wwdc2019/413/"&gt;Testing in Xcode&lt;/a&gt;&lt;br&gt;
Unit testing is an essential tool to consistently verify your code works correctly. Learn about the built-in testing features in Xcode, using XCTest. Find out how to organize your tests and run them under different configurations using test plans, new in Xcode 11. Discover how to automate testing and efficiently work with the results.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://developer.apple.com/videos/play/wwdc2019/233/"&gt;Mastering Xcode Previews&lt;/a&gt;&lt;br&gt;
Xcode 11 displays previews of your user interface right in the editor, streamlining the edit-debug-run cycle into a seamless workflow. Learn how previews work, how to optimize the structure of your SwiftUI app for previews, and how to add preview support to your existing views and view controllers.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://developer.apple.com/videos/play/wwdc2019/301/"&gt;What's New in App Store Connect&lt;/a&gt;&lt;br&gt;
App Store Connect continues to improve its role in each step of your app's lifecycle with new features that make your app submission, management, and distribution experience better than ever. Learn about the latest enhancements and discover new ways to ensure each release of your app is better than the last.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://developer.apple.com/videos/play/wwdc2019/414/"&gt;Developing a Great Profiling Experience&lt;/a&gt;&lt;br&gt;
Learn how to add useful tracing to your reusable classes, subsystems, or frameworks. By making it easy to trace your code, you provide adopters with valuable insight and confidence. We'll show you best practices for tracing your Swift and Objective-C code, building custom instruments, and visualizing data in Instruments 11. Share your expertise in a tools experience so others can understand the contracts of your APIs and avoid anti-patterns that impact performance.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://developer.apple.com/videos/play/wwdc2019/409/"&gt;What's New in Clang and LLVM&lt;/a&gt;&lt;br&gt;
Keep up with the latest enhancements to C, Objective-C, and C++ made possible by advancements in the Clang compiler and LLVM. Find out about new static analyzer features and how to use them to improve your code. Learn how to take advantage of new optimizations for code size.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://developer.apple.com/videos/play/wwdc2019/412/"&gt;Debugging in Xcode 11&lt;/a&gt;&lt;br&gt;
Xcode 11 introduces new features for finding and fixing bugs fast. Discover how to simulate network conditions and thermal states, and how to override your app's runtime environment while debugging. See how the debugging features work with Xcode previews to identify issues before Build &amp;amp; Run. Learn how to work with the View Debugger to troubleshoot your SwiftUI views.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://developer.apple.com/videos/play/wwdc2019/421/"&gt;Modeling in Custom Instruments&lt;/a&gt;&lt;br&gt;
Custom instruments make it possible to profile your app your way, telling the story of what your app is doing at runtime. At the center of each custom instrument is a modeler. Find out how to build your own modelers that translate from signpost output to the data you want to show in your instrument. Learn how the Instruments rules engine works and how to optimize your instrument for maximum efficiency. This session builds on Creating Custom Instruments from WWDC 2018.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="darkmode"&gt;Dark Mode&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://developer.apple.com/videos/play/wwdc2019/214/"&gt;Implementing Dark Mode on iOS&lt;/a&gt;&lt;br&gt;
Hear from the UIKit engineering team about the principles and concepts that anchor Dark Mode on iOS. Get introduced to the principles of enhancing your app with this new appearance using dynamic colors and images, and add an experience that people are sure to love.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="securityprivacy"&gt;Security &amp;amp; Privacy&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://developer.apple.com/videos/play/wwdc2019/708/"&gt;Designing for Privacy&lt;/a&gt;&lt;br&gt;
Privacy is a more important issue than ever for your users. Learn about new features and privacy engineering techniques that can help you earn customer trust, create more personal experiences, and improve user engagement.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://developer.apple.com/videos/play/wwdc2019/709/"&gt;Cryptography and Your Apps&lt;/a&gt;&lt;br&gt;
System frameworks encrypt both data at rest and data in transit in a transparent way for you. This functionality is available by simply setting an attribute. However you may want to do more to protect your users’ data. CryptoKit is a new Swift framework that makes it easier and safer than ever to perform cryptographic operations, whether you simply need to compute a hash or are implementing a more advanced authentication protocol.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="performance"&gt;Performance&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://developer.apple.com/videos/play/wwdc2019/707/"&gt;Advances in App Background Execution&lt;/a&gt;&lt;br&gt;
Background execution is a powerful tool your app can leverage to provide a great user experience. Learn about best practices to follow when running in the background, especially if you use VoIP or silent pushes, and an all-new scheduling API that enables long running processing and maintenance tasks.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://developer.apple.com/videos/play/wwdc2019/417/"&gt;Improving Battery Life and Performance&lt;/a&gt;&lt;br&gt;
Learn about new ways to find and fix performance issues during daily development, beta testing, and public release on the App Store. Learn how to catch performance issues during daily development by measuring CPU, memory, and more in your XCTests. Discover how to find issues in the field during beta testing and public release using MetricKit. See how the Xcode Organizer now displays the most important metrics from your app aggregated from each version on the App Store.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://developer.apple.com/videos/play/wwdc2019/423/"&gt;Optimizing App Launch&lt;/a&gt;&lt;br&gt;
Slow app launches are frustrating. Learn about the new app launch instrument and discover how to make your app launch fast. Gain insights into what happens during app launch and how to minimize, prioritize, and optimize work at this critical time. Hear tips and tricks from the engineers making iOS apps launch fast.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://developer.apple.com/videos/play/wwdc2019/239/"&gt;Great Developer Habits&lt;/a&gt;&lt;br&gt;
Successful app development requires mastering a lot of different things. Discover practices you can incorporate into your development workflow to enhance your productivity, and improve your app’s performance and stability. Learn how to improve the quality of code you write with Xcode. Gain a practical understanding of some valuable development techniques.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="language"&gt;Language&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://developer.apple.com/videos/play/wwdc2019/402/"&gt;What's New in Swift&lt;/a&gt;&lt;br&gt;
Swift is now the language of choice for a number of major frameworks across all of Apple's platforms, including SwiftUI, RealityKit and Create ML. Join us for a review of Swift 5.0 and an exploration of Swift 5.1, new in Xcode 11. Find out about the latest advancements in performance and safety. Discover new features in the language, and how they have enabled the development of these new frameworks.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://developer.apple.com/videos/play/wwdc2019/408/"&gt;Adopting Swift Packages in Xcode&lt;/a&gt;&lt;br&gt;
Swift packages are a great way to organize and share code, and are now supported while building apps for all Apple platforms in Xcode 11. Find out how to use community-developed packages in your project, how Swift packages are structured, and how package versioning and dependencies work.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="storage"&gt;Storage&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://developer.apple.com/videos/play/wwdc2019/419/"&gt;Optimizing Storage in Your App&lt;/a&gt;&lt;br&gt;
How you store data in your app affects not only disk footprint, but also the performance of your app and the battery life of the device. Learn techniques for optimizing data serialization, working with images, and syncing to disk. Find out how to take advantage of features in SQLite to improve performance and safety.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://developer.apple.com/videos/play/wwdc2019/206/"&gt;Introducing SF Symbols&lt;/a&gt;&lt;br&gt;
SF Symbols introduces a comprehensive library of vector-based symbols that you can incorporate into your app to simplify the layout of user interface elements through automatic alignment with surrounding text, and support for multiple weights and sizes. Learn how easy it is to adapt to different screen sizes and layouts, and improve the accessibility and localizability of your app. Get details on how to create new symbols for your specific needs that perfectly match the visual style of SF Symbols.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="map"&gt;Map&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://developer.apple.com/videos/play/wwdc2019/236/"&gt;What’s New in MapKit and MapKit JS&lt;/a&gt;&lt;br&gt;
MapKit and MapKit JS bring fully featured Apple Maps to your app and website. See how the latest features give you more control over the base map presentation, finer-grained search and result filtering of points of interest and address information, and integration with standard data formats for custom overlays and annotations.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://developer.apple.com/videos/play/wwdc2019/241/"&gt;Adding to your App and Website&lt;/a&gt;&lt;br&gt;
The Indoor Maps Program enables organizations with large public or private spaces to deliver user experiences that provide precise indoor location information and present stunning indoor maps. Discover the overall process in the indoor map enablement workflow then take deep dive into the technical details on how MapKit and MapKit JS use powerful APIs and geo-standards to rapidly integrate indoor maps into your app and website.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="ui"&gt;UI&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://developer.apple.com/videos/play/wwdc2019/224/"&gt;Modernizing Your UI for iOS 13&lt;/a&gt;&lt;br&gt;
iOS 13 combines powerful new multitasking and productivity technologies with a refreshed look and feel for all applications. Familiarize yourself with new requirements to keep your app ready for upcoming versions of iOS. Discover improvements to search fields and a totally new way to present UI. Learn how to adopt new gestures around selection, access peek and pop on all hardware, and how to renew your app's look for iOS 13.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://developer.apple.com/videos/play/wwdc2019/215/"&gt;Advances in Collection View Layout&lt;/a&gt;&lt;br&gt;
Collection View Layouts make it easy to build rich interactive collections. Learn how to make dynamic and responsive layouts that range in complexity from basic lists to an advanced, multi-dimensional browsing experience.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="machinelearning"&gt;Machine Learning&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://developer.apple.com/videos/play/wwdc2019/209/"&gt;What's New in Machine Learning&lt;/a&gt;&lt;br&gt;
Core ML 3 now enables support for advanced model types that were never before available in on-device machine learning. Learn how model personalization brings amazing personalization opportunities to your app. Gain a deeper understanding of strategies for linking models and improvements to Core ML tools used for conversion of existing models.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://developer.apple.com/videos/play/wwdc2019/704/"&gt;Core ML 3 Framework&lt;/a&gt;&lt;br&gt;
Core ML 3 now enables support for advanced model types that were never before available in on-device machine learning. Learn how model personalization brings amazing personalization opportunities to your app. Gain a deeper understanding of strategies for linking models and improvements to Core ML tools used for conversion of existing models.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="design"&gt;Design&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://localhost:2368/2019/07/10/wwdc19-ios-related-session-list/"&gt;What’s New in iOS and macOS Design&lt;/a&gt;&lt;br&gt;
Discover how to update your app’s interface for Dark Mode to create beautiful and accessible apps. Learn how refinements to modal sheets and the new contextual menu UI can help improve usability and lead to more powerful and efficient workflows. And, gain key insights into how you can create a great Mac experience with your iPad app.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://developer.apple.com/videos/play/wwdc2019/808/"&gt;What's New in iOS Design&lt;/a&gt;&lt;br&gt;
Discover how to update your app's interface for Dark Mode to create beautiful and accessible apps. And learn how refinements to modal sheets and the new contextual menu UI can help improve usability and lead to more powerful and efficient workflows.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content:encoded></item><item><title>Google Objective-C Style Guide [中英对照]</title><description>翻译者：Mark C.J. 

警告：文章原始版权归Google所有，本文档翻译部分归作者Mark所有，只供学习使用，禁止以营利为目的或其他商业使用！</description><link>http://localhost:2368/2018/10/09/google-objective-c-style-guide/</link><guid isPermaLink="false">5bbc591c9e9f546e55266be0</guid><category>style guide</category><category>iOS</category><category>技术</category><dc:creator>Mark Chen</dc:creator><pubDate>Tue, 09 Oct 2018 12:00:00 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;&lt;strong&gt;注意：文章原始版权归Google所有，本文档翻译部分归作者Mark所有，只供学习使用，禁止以营利为目的或其他商业使用！&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Objective-C is a dynamic, object-oriented extension of C. It's designed to be&lt;br&gt;
easy to use and read, while enabling sophisticated object-oriented design. It&lt;br&gt;
is the primary development language for applications on OS X and on iOS.&lt;/p&gt;
&lt;p&gt;Objective-C是基于C语言的动态化、面向对象程序设计语言。它被设计的易读易使用，同时支持复杂的面向对象程序设计。Objective-C是OS X和iOS应用程序开发的首选语言。&lt;/p&gt;
&lt;p&gt;Apple has already written a very good, and widely accepted, &lt;a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html"&gt;Cocoa Coding&lt;br&gt;
Guidelines&lt;/a&gt;&lt;br&gt;
for Objective-C. Please read it in addition to this guide.&lt;/p&gt;
&lt;p&gt;苹果公司已经为Objective-C撰写了优秀且被广泛接受的 &lt;a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html"&gt;Cocoa开发代码规范&lt;/a&gt;，除本文档外，可以参考上述文档。&lt;/p&gt;
&lt;p&gt;The purpose of this document is to describe the Objective-C (and&lt;br&gt;
Objective-C++) coding guidelines and practices that should be used for iOS and&lt;br&gt;
OS X code. These guidelines have evolved and been proven over time on other&lt;br&gt;
projects and teams.&lt;br&gt;
Open-source projects developed by Google conform to the requirements in this guide.&lt;/p&gt;
&lt;p&gt;本文档用于描述在用于iOS和OS X程序开发时，Objective-C (Objective-C++)语言的代码规范和最佳实践。该规范已经被其他项目和团队广泛使用并被时间验证。Google的开源项目均采用该代码开发规范。&lt;/p&gt;
&lt;p&gt;Note that this guide is not an Objective-C tutorial. We assume that the reader&lt;br&gt;
is familiar with the language. If you are new to Objective-C or need a&lt;br&gt;
refresher, please read &lt;a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html"&gt;Programming with&lt;br&gt;
Objective-C&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;注意本文档不是Objective-C语言教程。我们假设读者已经熟知Objective-C开发语言。如果你是Objective-C新人或需要复习该语言，请阅读&lt;a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html"&gt;Programming with Objective-C&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="principles"&gt;原则（Principles）&lt;/h2&gt;
&lt;h3 id="optimizeforthereadernotthewriter"&gt;关注读者，而非作者（Optimize for the reader, not the writer）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Codebases often have extended lifetimes and more time is spent reading the code&lt;br&gt;
than writing it. We explicitly choose to optimize for the experience of our&lt;br&gt;
average software engineer reading, maintaining, and debugging code in our&lt;br&gt;
codebase rather than the ease of writing said code. For example, when something&lt;br&gt;
surprising or unusual is happening in a snippet of code, leaving textual hints&lt;br&gt;
for the reader is valuable.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;阅读代码库中的代码的时间往往远大于书写的时间。我们很明确的选择优化普通软件开发工程师对于代码阅读、维护和调试的体验，而不是写出简易（指简陋甚至）的代码。例如，当对于一小段代码会让人感到惊奇或不寻常时（不可奇技淫巧），给读者书写一段文本注释或说明是非常可贵的。&lt;/p&gt;
&lt;h3 id="beconsistent"&gt;保持一致性 （Be consistent）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;When the style guide allows multiple options it is preferable to pick one option&lt;br&gt;
over mixed usage of multiple options. Using one style consistently throughout a&lt;br&gt;
codebase lets engineers focus on other (more important) issues. Consistency also&lt;br&gt;
enables better automation because consistent code allows more efficient&lt;br&gt;
development and operation of tools that format or refactor code. In many cases,&lt;br&gt;
rules that are attributed to &amp;quot;Be Consistent&amp;quot; boil down to &amp;quot;Just pick one and&lt;br&gt;
stop worrying about it&amp;quot;; the potential value of allowing flexibility on these&lt;br&gt;
points is outweighed by the cost of having people argue over them.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当编码风格规范中提供规范供选择时，选择一种规范要优于多种规范混用。代码库中使用一致的规范，会帮助工程师节省时间，将精力放在其他更重要的事情上（指减少因为编码规范不统一导致的各种误解）。由于一致的代码风格可以高效的开发和使用工具组件，所以，一致性也可以提高自动化程度。在很多场景中，保持一致性可以归结为“（快速）选一个，然后就不要再担心它”，这种选择的灵活性做法，对比花费更多时间争论选择哪种规范来使用，更具潜在价值。&lt;/p&gt;
&lt;h3 id="applesdksbeconsistentwithapplesdks"&gt;与Apple SDKs保持一致（Be consistent with Apple SDKs）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Consistency with the way Apple SDKs use Objective-C has value for the same&lt;br&gt;
reasons as consistency within our code base. If an Objective-C feature solves a&lt;br&gt;
problem that's an argument for using it. However, sometimes language features&lt;br&gt;
and idioms are flawed, or were just designed with assumptions that are not&lt;br&gt;
universal. In those cases it is appropriate to constrain or ban language&lt;br&gt;
features or idioms.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;与上面说的保持一致性一样，与苹果Objective-C SDKs保持一致性同样具有价值。如果一个Objective-C的功能特性解决了一个由于参数使用导致的问题。然而，有时语言的特性和惯用语法是有缺陷的，或者本来就被设计的不是通用的。此时，避免或者禁用这些特性或惯用语法往往更好。&lt;/p&gt;
&lt;h3 id="stylerulesshouldpulltheirweight"&gt;风格规范要适度（Style rules(编码规范) should pull their weight）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;The benefit of a style rule must be large enough to justify asking engineers to&lt;br&gt;
remember it. The benefit is measured relative to the codebase we would get&lt;br&gt;
without the rule, so a rule against a very harmful practice may still have a&lt;br&gt;
small benefit if people are unlikely to do it anyway. This principle mostly&lt;br&gt;
explains the rules we don’t have, rather than the rules we do: for example, goto&lt;br&gt;
contravenes many of the following principles, but is not discussed due to its&lt;br&gt;
extreme rarity.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;编码规范必须被证明足够有益，以便让工程师信服。这些收益是相对于我们拿一个完全没有规范的代码库来对比的，若工程师执行一个非常糟糕的编码规范，也比完全没有规范好一些。这一原则主要解释我们没有的规则，而不是我们已有的规则。例如，goto违反很多下述原则，但我们由于其极其少见，我们在此不讨论。&lt;/p&gt;
&lt;h2 id="example"&gt;示例 (Example)&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;They say an example is worth a thousand words, so let's start off with an&lt;br&gt;
example that should give you a feel for the style, spacing, naming, and so on.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Here is an example header file, demonstrating the correct commenting and spacing&lt;br&gt;
for an &lt;code&gt;@interface&lt;/code&gt; declaration.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;俗话说，一个例子胜过千言万语，所以我们举个例子，来初步感受一下编码风格、空格空行布局、命名等等编码规范。&lt;/p&gt;
&lt;p&gt;下面头文件的例子，演示如何声明一个&lt;code&gt;@interface&lt;/code&gt;正确的注释及代码空格空行编码风格。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

#import &amp;lt;Foundation/Foundation.h&amp;gt;

@class Bar;

/**
 * A sample class demonstrating good Objective-C style. All interfaces,
 * categories, and protocols (read: all non-trivial top-level declarations
 * in a header) MUST be commented. Comments must also be adjacent to the
 * object they're documenting.
 */
@interface Foo : NSObject

/** The retained Bar. */
@property(nonatomic) Bar *bar;

/** The current drawing attributes. */
@property(nonatomic, copy) NSDictionary&amp;lt;NSString *, NSNumber *&amp;gt; *attributes;

/**
 * Convenience creation method.
 * See -initWithBar: for details about @c bar.
 *
 * @param bar The string for fooing.
 * @return An instance of Foo.
 */
+ (instancetype)fooWithBar:(Bar *)bar;

/**
 * Initializes and returns a Foo object using the provided Bar instance.
 *
 * @param bar A string that represents a thing that does a thing.
 */
- (instancetype)initWithBar:(Bar *)bar NS_DESIGNATED_INITIALIZER;

/**
 * Does some work with @c blah.
 *
 * @param blah
 * @return YES if the work was completed; NO otherwise.
 */
- (BOOL)doWorkWithBlah:(NSString *)blah;

@end
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;An example source file, demonstrating the correct commenting and spacing for the&lt;br&gt;
&lt;code&gt;@implementation&lt;/code&gt; of an interface.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;实现一个&lt;code&gt;@implementation&lt;/code&gt; 的正确编码规范示例，展示正确的注释和间距（包括空行，回车，空格等）&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

#import &amp;quot;Shared/Util/Foo.h&amp;quot;

@implementation Foo {
  /** The string used for displaying &amp;quot;hi&amp;quot;. */
  NSString *_string;
}

+ (instancetype)fooWithBar:(Bar *)bar {
  return [[self alloc] initWithBar:bar];
}

- (instancetype)init {
  // Classes with a custom designated initializer should always override
  // the superclass's designated initializer.
  return [self initWithBar:nil];
}

- (instancetype)initWithBar:(Bar *)bar {
  self = [super init];
  if (self) {
    _bar = [bar copy];
    _string = [[NSString alloc] initWithFormat:@&amp;quot;hi %d&amp;quot;, 3];
    _attributes = @{
      @&amp;quot;color&amp;quot; : [UIColor blueColor],
      @&amp;quot;hidden&amp;quot; : @NO
    };
  }
  return self;
}

- (BOOL)doWorkWithBlah:(NSString *)blah {
  // Work should be done here.
  return NO;
}

@end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="naming"&gt;命名（Naming）&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Names should be as descriptive as possible, within reason. Follow standard&lt;br&gt;
&lt;a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html"&gt;Objective-C naming rules&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;命名需要自达意（即看到命名，即可清楚知道代表的意义）且合理，参照&lt;a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html"&gt;Objective-C naming rules&lt;/a&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Avoid non-standard abbreviations (including non-standard acronyms and&lt;br&gt;
initialisms). Don't worry about saving horizontal space as it is far more&lt;br&gt;
important to make your code immediately understandable by a new reader. For&lt;br&gt;
example:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;禁用非标准缩写（包括非标准首字母缩略词）。 相对节约横向空间来说，对于一个新的读者来说，能够立即理解意义会更为重要，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

// Good names.
int numberOfErrors = 0;
int completedConnectionsCount = 0;
tickets = [[NSMutableArray alloc] init];
userInfo = [someObject object];
port = [network port];
NSDate *gAppLaunchDate;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// AVOID:

// Names to avoid.
int w;
int nerr;
int nCompConns;
tix = [[NSMutableArray alloc] init];
obj = [someObject object];
p = [network port];
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Any class, category, method, function, or variable name should use all capitals&lt;br&gt;
for acronyms and &lt;a href="https://en.wikipedia.org/wiki/Initialism"&gt;initialisms&lt;/a&gt;&lt;br&gt;
within the name. This follows Apple's standard of using all capitals within a&lt;br&gt;
name for acronyms such as URL, ID, TIFF, and EXIF.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;任何类、扩展、方法、函数或者变量名，简称或者缩略语必须大写。对于名字，可参照苹果缩略语或简称大写字母标准，例如URL, ID, TIFF, EXIF。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Names of C functions and typedefs should be capitalized and use camel case as&lt;br&gt;
appropriate for the surrounding code.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;C语言函数或者typedef命名须首字母大写，使用驼峰命名方式区分大小写；&lt;/p&gt;
&lt;h3 id="filenames"&gt;文件命名（File Names）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;File names should reflect the name of the class implementation that they&lt;br&gt;
contain—including case.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;文件命名须与该文件中实现的类名保持一致，包括大小写；&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Follow the convention that your project uses.&lt;br&gt;
File extensions should be as follows:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;文件扩展名，约定如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;扩展名（Extension）&lt;/th&gt;
&lt;th&gt;类型（Type）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;.h&lt;/td&gt;
&lt;td&gt;C/C++/Objective-C头文件（C/C++/Objective-C header file）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.m&lt;/td&gt;
&lt;td&gt;Objective-C（类）实现文件（Objective-C implementation file）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.mm&lt;/td&gt;
&lt;td&gt;Objective-C++（类）实现文件（Objective-C++ implementation file）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.cc&lt;/td&gt;
&lt;td&gt;纯C++实现文件（Pure C++ implementation file）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.c&lt;/td&gt;
&lt;td&gt;C实现文件（C implementation file）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;Files containing code that may be shared across projects or used in a large&lt;br&gt;
project should have a clearly unique name, typically including the project or&lt;br&gt;
class &lt;a href="#prefixes"&gt;prefix&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;包含跨工程或者较大工程中共用的代码的文件，必须有一个清晰唯一的名字，一般包括工程或者类名作为前缀。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;File names for categories should include the name of the class being extended,&lt;br&gt;
like GTMNSString+Utils.h or NSTextView+GTMAutocomplete.h&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;扩展类的文件名，须包含被扩展类的类名，例如GTMNSString+Utils.h or NSTextView+GTMAutocomplete.h&lt;/p&gt;
&lt;h3 id="prefixes"&gt;前缀（Prefixes）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Prefixes are commonly required in Objective-C to avoid naming collisions in a&lt;br&gt;
global namespace. Classes, protocols, global functions, and global constants&lt;br&gt;
should generally be named with a prefix that begins with a capital letter&lt;br&gt;
followed by one or more capital letters or numbers.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前缀被用来避免全局命名空间的命名冲突。类名、协议、全局方法和全局常量命名，要添加前缀，并且首字母大写，后面包含一个或几个数字或大写字母。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;WARNING: Apple reserves two-letter prefixes—see&lt;br&gt;
&lt;a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Conventions/Conventions.html"&gt;Conventions in Programming with Objective-C&lt;/a&gt;—so&lt;br&gt;
prefixes with a minimum of three characters are considered best practice.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;警告：苹果使用两个字母的前缀，参考&lt;a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Conventions/Conventions.html"&gt;Conventions in Programming with Objective-C&lt;/a&gt;，所以，建议最好使用最少三个字符的前缀。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

/** An example error domain. */
extern NSString *GTMExampleErrorDomain;

/** Gets the default time zone. */
extern NSTimeZone *GTMGetDefaultTimeZone(void);

/** An example delegate. */
@protocol GTMExampleDelegate &amp;lt;NSObject&amp;gt;
@end

/** An example class. */
@interface GTMExample : NSObject
@end

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="classnames"&gt;类命名（Class Names）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Class names (along with category and protocol names) should start as uppercase&lt;br&gt;
and use mixed case to delimit words.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;类命名（连同扩展和协议命名）需要使用首字母大写，大小写混合的方式来界定不同单词。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Classes and protocols in code shared across multiple applications must have an&lt;br&gt;
appropriate &lt;a href="#prefixes"&gt;prefix&lt;/a&gt; (e.g. GTMSendMessage). Prefixes are recommended,&lt;br&gt;
but not required, for other classes and protocols.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;跨应用使用的类和协议必须使用合适的前缀（例如：GTMSendMessage）。对于其他类和协议，前缀被推荐使用，但不是必须的。&lt;/p&gt;
&lt;h3 id="categorycategorynaming"&gt;Category命名（Category Naming ）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Category names should start with an appropriate &lt;a href="#prefixes"&gt;prefix&lt;/a&gt; identifying&lt;br&gt;
the category as part of a project or open for general use.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Category名要使用合适的前缀，来表明该扩展是某一工程的一部分或可以通用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Category source file names should begin with the class being extended followed&lt;br&gt;
by a plus sign and the name of the category, e.g., &lt;code&gt;NSString+GTMParsing.h&lt;/code&gt;.&lt;br&gt;
Methods in a category should be prefixed with a lowercase version of the prefix&lt;br&gt;
used for the category name followed by an underscore (e.g.,&lt;br&gt;
&lt;code&gt;gtm_myCategoryMethodOnAString:&lt;/code&gt;) in order to prevent collisions in&lt;br&gt;
Objective-C's global namespace.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Category源文件名必须以被扩展类名开头，中间用+号衔接后面的扩展名字，例如：&lt;code&gt;NSString+GTMParsing.h&lt;/code&gt;。 扩展中的方法以小写的扩展名为前缀，中间用下划线衔接方法名（例如：&lt;code&gt;gtm_myCategoryMethodOnAString:&lt;/code&gt;），以便避免全局命名范围内的命名冲突。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;There should be a single space between the class name and the opening&lt;br&gt;
parenthesis of the category.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;类名和扩展名的左圆括号之间，须添加一个空格。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

// UIViewController+GTMCrashReporting.h

/** A category that adds metadata to include in crash reports to UIViewController. */
@interface UIViewController (GTMCrashReporting)

/** A unique identifier to represent the view controller in crash reports. */
@property(nonatomic, setter=gtm_setUniqueIdentifier:) int gtm_uniqueIdentifier;

/** Returns an encoded representation of the view controller's current state. */
- (nullable NSData *)gtm_encodedState;

@end
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;If a class is not shared with other projects, categories extending it may omit&lt;br&gt;
name prefixes and method name prefixes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;若类不被其他工程共用，扩展名和方法名可省略前缀。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

/** This category extends a class that is not shared with other projects. */
@interface XYZDataObject (Storage)
- (NSString *)storageIdentifier;
@end
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="ocobjectivecmethodnames"&gt;OC方法命名（Objective-C Method Names）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Method and parameter names typically start as lowercase and then use mixed case.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;方法名和参数名以小写字母开头，中间夹杂大小写。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Proper capitalization should be respected, including at the beginning of names.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;包括首字母命名，可以考虑某些字母大写。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

+ (NSURL *)URLWithString:(NSString *)URLString;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;The method name should read like a sentence if possible, meaning you should&lt;br&gt;
choose parameter names that flow with the method name. Objective-C method names&lt;br&gt;
tend to be very long, but this has the benefit that a block of code can almost&lt;br&gt;
read like prose, thus rendering many implementation comments unnecessary.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;方法名应该尽量读起来像一个句子，告诉你这个方法后面应该传入的参数名。Objective-C方法名倾向于非常长，但是这样的好处就是一段block的代码读起来像散文，因此没必要再添加更多注释。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Use prepositions and conjunctions like &amp;quot;with&amp;quot;, &amp;quot;from&amp;quot;, and &amp;quot;to&amp;quot; in the second&lt;br&gt;
and later parameter names only where necessary to clarify the meaning or&lt;br&gt;
behavior of the method.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;只有在有必要说明方法意义或行为时，才在第二个参数名后，使用例如&amp;quot;with&amp;quot;, &amp;quot;from&amp;quot;, and &amp;quot;to&amp;quot;等介词和连词。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

- (void)addTarget:(id)target action:(SEL)action;                          // GOOD; no conjunction needed
- (CGPoint)convertPoint:(CGPoint)point fromView:(UIView *)view;           // GOOD; conjunction clarifies parameter
- (void)replaceCharactersInRange:(NSRange)aRange
            withAttributedString:(NSAttributedString *)attributedString;  // GOOD.
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;A method that returns an object should have a name beginning with a noun&lt;br&gt;
identifying the object returned:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;返回对象的方法名需要以名词开头，以表明返回的对象类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

- (Sandwich *)sandwich;      // GOOD.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// AVOID:

- (Sandwich *)makeSandwich;  // AVOID.
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;An accessor method should be named the same as the object it's getting, but it&lt;br&gt;
should not be prefixed with the word &lt;code&gt;get&lt;/code&gt;. For example:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;访问器方法需要和对象的getting方法一致，但不可有&lt;code&gt;get&lt;/code&gt;前缀。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

- (id)delegate;     // GOOD.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// AVOID:

- (id)getDelegate;  // AVOID.
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Accessors that return the value of boolean adjectives have method names&lt;br&gt;
beginning with &lt;code&gt;is&lt;/code&gt;, but property names for those methods omit the &lt;code&gt;is&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;返回布尔类型的方法，要以&lt;code&gt;is&lt;/code&gt;为开头，但属性名省略&lt;code&gt;is&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Dot notation is used only with property names, not with method names.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;点只用于属性获取，不可用于方法调用&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

@property(nonatomic, getter=isGlorious) BOOL glorious;
- (BOOL)isGlorious;

BOOL isGood = object.glorious;      // GOOD.
BOOL isGood = [object isGlorious];  // GOOD.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// AVOID:

BOOL isGood = object.isGlorious;    // AVOID.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

NSArray&amp;lt;Frog *&amp;gt; *frogs = [NSArray&amp;lt;Frog *&amp;gt; arrayWithObject:frog];
NSEnumerator *enumerator = [frogs reverseObjectEnumerator];  // GOOD.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// AVOID: 避免使用.来调用方法

NSEnumerator *enumerator = frogs.reverseObjectEnumerator;    // AVOID.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;See &lt;a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingMethods.html#//apple_ref/doc/uid/20001282-BCIGIJJF"&gt;Apple's Guide to Naming Methods&lt;/a&gt; for more details on Objective-C naming.&lt;/p&gt;
&lt;p&gt;These guidelines are for Objective-C methods only. C++ method names continue to&lt;br&gt;
follow the rules set in the C++ style guide.&lt;/p&gt;
&lt;p&gt;更多命名相关内容，参考&lt;a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingMethods.html#//apple_ref/doc/uid/20001282-BCIGIJJF"&gt;Apple's Guide to Naming Methods&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;以上规范只适用于Objective-C方法，C++方法命名请参考C++命名指南。&lt;/p&gt;
&lt;h3 id="functionnames"&gt;函数命名（Function Names）&lt;/h3&gt;
&lt;p&gt;Function names should start with a capital letter and have a capital letter for&lt;br&gt;
each new word (a.k.a. &amp;quot;&lt;a href="https://en.wikipedia.org/wiki/Camel_case"&gt;camel case&lt;/a&gt;&amp;quot; or &amp;quot;Pascal case&amp;quot;).&lt;/p&gt;
&lt;p&gt;函数名要首字母大写，之后使用驼峰命名法。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

static void AddTableEntry(NSString *tableEntry);
static BOOL DeleteFile(const char *filename);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Because Objective-C does not provide namespacing, non-static functions should&lt;br&gt;
have a &lt;a href="#prefixes"&gt;prefix&lt;/a&gt; that minimizes the chance of a name collision.&lt;/p&gt;
&lt;p&gt;由于Objective-C不支持命名空间，非静态函数要使用前缀，以最大程度减少命名冲突。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

extern NSTimeZone *GTMGetDefaultTimeZone(void);
extern NSString *GTMGetURLScheme(NSURL *URL);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="variablenames"&gt;变量命名（Variable Names）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Variable names typically start with a lowercase and use mixed case to delimit&lt;br&gt;
words.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Instance variables have leading underscores. File scope or global variables have&lt;br&gt;
a prefix &lt;code&gt;g&lt;/code&gt;. For example: &lt;code&gt;myLocalVariable&lt;/code&gt;, &lt;code&gt;_myInstanceVariable&lt;/code&gt;,&lt;br&gt;
&lt;code&gt;gMyGlobalVariable&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;变量名首字母小写，采用驼峰命名法.&lt;/p&gt;
&lt;p&gt;实例变量使用下划线前缀。文件范围或全局变量使用&lt;code&gt;g&lt;/code&gt;作为前缀。例如&lt;code&gt;myLocalVariable&lt;/code&gt;, &lt;code&gt;_myInstanceVariable&lt;/code&gt;, &lt;code&gt;gMyGlobalVariable&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id="commonvariablenames"&gt;一般变量命名（Common Variable Names）&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;Readers should be able to infer the variable type from the name, but do not use&lt;br&gt;
Hungarian notation for syntactic attributes, such as the static type of a&lt;br&gt;
variable (int or pointer).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;代码读者应该能从命名中推导出变量所代表的含义，但是对于句法属性不要使用匈牙利表示法，例如，对于静态变量，不需要加&lt;code&gt;s&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;File scope or global variables (as opposed to constants) declared outside the&lt;br&gt;
scope of a method or function should be rare, and should have the prefix g.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;声明在方法或函数外的文件作用域变量或全局变量（区别常量）比较少见，应该带有一个前缀&lt;code&gt;g&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

static int gGlobalCounter;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="instancevariables"&gt;实例变量（Instance Variables）&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;Instance variable names are mixed case and should be prefixed with an&lt;br&gt;
underscore, like &lt;code&gt;_usernameTextField&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例变量前边以下划线&lt;code&gt;_&lt;/code&gt;开头，中间但是使用驼峰法区分大小写。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;NOTE: Google's previous convention for Objective-C ivars was a trailing&lt;br&gt;
underscore. Existing projects may opt to continue using trailing underscores in&lt;br&gt;
new code in order to maintain consistency within the project codebase.&lt;br&gt;
Consistency of prefix or suffix underscores should be maintained within each&lt;br&gt;
class.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意：Google之前对Objective-C变量的约定是使用尾部下划线。现有工程中，后续开发可能会选择继续使用实例变量尾部带有下划线的方式，以便与之前工程代码保持一致。在每个类中要保持前后缀下划线的一致性。&lt;/p&gt;
&lt;h4 id="constants"&gt;常量（Constants）&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;Constant symbols (const global and static variables and constants created&lt;br&gt;
with #define) should use mixed case to delimit words.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;常量标识符（包括全局常量、静态变量和使用#define定义的常量）需使用驼峰命名；&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Global and file scope constants should have an appropriate &lt;a href="#prefixes"&gt;prefix&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;全局和文件作用域常量要带有合适的前缀。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

extern NSString *const GTLServiceErrorDomain;

typedef NS_ENUM(NSInteger, GTLServiceError) {
  GTLServiceErrorQueryResultMissing = -3000,
  GTLServiceErrorWaitTimedOut       = -3001,
};
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Because Objective-C does not provide namespacing, constants with external&lt;br&gt;
linkage should have a prefix that minimizes the chance of a name collision,&lt;br&gt;
typically like &lt;code&gt;ClassNameConstantName&lt;/code&gt; or &lt;code&gt;ClassNameEnumName&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于Objective-C不支持命名空间，与外界关联的常量要使用前缀以最大程度避免命名冲突，常用方式例如&lt;code&gt;ClassNameConstantName&lt;/code&gt; or &lt;code&gt;ClassNameEnumName&lt;/code&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;For interoperability with Swift code, enumerated values should have names that&lt;br&gt;
extend the typedef name:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;与Swift有交互的Objective-C代码，枚举值变量要使用自定义类型名作为前缀：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

typedef NS_ENUM(NSInteger, DisplayTinge) {
  DisplayTingeGreen = 1,
  DisplayTingeBlue = 2,
};
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;A lowercase k can be used as a standalone prefix for constants of static storage&lt;br&gt;
duration declared within implementation files:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在实现文件中，小写字母k可以被用来作为声明独立的常量或者静态变量前缀：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

static const int kFileCount = 12;
static NSString *const kUserKey = @&amp;quot;kUserKey&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;NOTE: Previous convention was for public constant names to begin with a&lt;br&gt;
lowercase k followed by a project-specific &lt;a href="#prefixes"&gt;prefix&lt;/a&gt;. This practice is&lt;br&gt;
no longer recommended.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;提示：之前约定中，公共常量名使用小写k开头，以作为工程常量特有标识。该方式不再推荐使用。&lt;/p&gt;
&lt;h2 id="typesanddeclarations"&gt;类型和声明（Types and Declarations ）&lt;/h2&gt;
&lt;h3 id="methoddeclarations"&gt;方法声明（Method Declarations）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;As shown in the &lt;a href="#Example"&gt;example&lt;/a&gt;, the recommended order&lt;br&gt;
for declarations in an &lt;code&gt;@interface&lt;/code&gt; declaration are: properties, class methods,&lt;br&gt;
initializers, and then finally instance methods. The class methods section&lt;br&gt;
should begin with any convenience constructors.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如示例所示，声明一个 &lt;code&gt;@interface&lt;/code&gt; 内容的推荐顺序为：属性，类方法，初始化方法，之后实例方法。类方法区域，把&lt;a href="https://zhuanlan.zhihu.com/p/35695874"&gt;便捷初始化方法&lt;/a&gt;放在前面。&lt;/p&gt;
&lt;h3 id="localvariables"&gt;局部变量（Local Variables）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Declare variables in the narrowest practical scopes, and close to their use.&lt;br&gt;
Initialize variables in their declarations.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在靠近需要使用该变量的地方声明变量，声明时完成初始化。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

CLLocation *location = [self lastKnownLocation];
for (int meters = 1; meters &amp;lt; 10; meters++) {
  reportFrogsWithinRadius(location, meters);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Occasionally, efficiency will make it more appropriate to declare a variable&lt;br&gt;
outside the scope of its use. This example declares meters separate from&lt;br&gt;
initialization, and needlessly sends the lastKnownLocation message each time&lt;br&gt;
through the loop:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有时出于效率考虑，把变量声明在作用域外更可取。这个例子声明meters变量，并没有初始化，每次循环时，没必要每次都需要对location进行赋值。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// AVOID:

int meters;                                         // AVOID.
for (meters = 1; meters &amp;lt; 10; meters++) {
  CLLocation *location = [self lastKnownLocation];  // AVOID.
  reportFrogsWithinRadius(location, meters);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Under Automatic Reference Counting, strong and weak pointers to Objective-C&lt;br&gt;
objects are automatically initialized to &lt;code&gt;nil&lt;/code&gt;, so explicit initialization to&lt;br&gt;
&lt;code&gt;nil&lt;/code&gt; is not required for those common cases. However, automatic initialization&lt;br&gt;
does &lt;em&gt;not&lt;/em&gt; occur for many Objective-C pointer types, including object pointers&lt;br&gt;
declared with the &lt;code&gt;__unsafe_unretained&lt;/code&gt; ownership qualifier and CoreFoundation&lt;br&gt;
object pointer types. When in doubt, prefer to initialize all Objective-C&lt;br&gt;
local variables.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用ARC时，Objective-C对象的强、弱指针会被自动会被初始化为&lt;code&gt;nil&lt;/code&gt;，所以通常不需要强制初始化为&lt;code&gt;nil&lt;/code&gt;。然而，包括利用&lt;code&gt;__unsafe_unretained&lt;/code&gt;声明的变量和CoreFoundation对象指针，很多Objective-C指针类型不会自动完成初始化。 当无法肯定时，建议所有Objective-C局部变量声明时进行初始化。&lt;/p&gt;
&lt;h3 id="unsignedintegers"&gt;无符号整型 （Unsigned Integers）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Avoid unsigned integers except when matching types used by system interfaces.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;除匹配系统接口调用外，避免使用无符号整型。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Subtle errors crop up when doing math or counting down to zero using unsigned&lt;br&gt;
integers. Rely only on signed integers in math expressions except when matching&lt;br&gt;
NSUInteger in system interfaces.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用无符号整型进行数学计算或出现倒数为0时，会出现微妙的错误。除匹配系统接口时使用NSUInteger外，数学计算时只使用带符号整型。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

NSUInteger numberOfObjects = array.count;
for (NSInteger counter = numberOfObjects - 1; counter &amp;gt; 0; --counter)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// AVOID:

for (NSUInteger counter = numberOfObjects - 1; counter &amp;gt; 0; --counter)  // AVOID.
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Unsigned integers may be used for flags and bitmasks, though often NS_OPTIONS or&lt;br&gt;
NS_ENUM will be more appropriate.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;尽管推荐使用NS_OPTIONS或NS_ENUM，无符号整型可以被用来作为标志位或位运算掩码。&lt;/p&gt;
&lt;h3 id="typeswithinconsistentsizes"&gt;字节宽度可变类型（Types with Inconsistent Sizes)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Due to sizes that differ in 32- and 64-bit builds, avoid types long, NSInteger,&lt;br&gt;
NSUInteger, and CGFloat except when matching system interfaces.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于long，NSInteger，NSUIInteger和CGFloat类型在32位和64位机上字节宽度不同，除必须匹配调用系统接口外，避免使用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Types long, NSInteger, NSUInteger, and CGFloat vary in size between 32- and&lt;br&gt;
64-bit builds. Use of these types is appropriate when handling values exposed by&lt;br&gt;
system interfaces, but they should be avoided for most other computations.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;long, NSInteger, NSUInteger, and CGFloat类型在32位和64位环境下字节宽度可变。处理系统暴露的数据时，可以使用上述类型，但其他运算，避免使用。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

int32_t scalar1 = proto.intValue;

int64_t scalar2 = proto.longValue;

NSUInteger numberOfObjects = array.count;

CGFloat offset = view.bounds.origin.x;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// AVOID:

NSInteger scalar2 = proto.longValue;  // AVOID.
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;File and buffer sizes often exceed 32-bit limits, so they should be declared&lt;br&gt;
using &lt;code&gt;int64_t&lt;/code&gt;, not with &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;NSInteger&lt;/code&gt;, or &lt;code&gt;NSUInteger&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;文件或缓存区大小常常超过32位限制，所以应该使用&lt;code&gt;int64_t&lt;/code&gt;，而不是&lt;code&gt;long&lt;/code&gt;, &lt;code&gt;NSInteger&lt;/code&gt;,或 &lt;code&gt;NSUInteger&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id="comments"&gt;注释（Comments）&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Comments are absolutely vital to keeping our code readable. The following rules&lt;br&gt;
describe what you should comment and where. But remember: while comments are&lt;br&gt;
important, the best code is self-documenting. Giving sensible names to types and&lt;br&gt;
variables is much better than using obscure names and then trying to explain&lt;br&gt;
them through comments.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注释对于保证代码可读性至关重要。以下规范说明在哪以及如何写注释。但请记住：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Pay attention to punctuation, spelling, and grammar; it is easier to read&lt;br&gt;
well-written comments than badly written ones.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意（注释的）标点、拼写和语法；写的好的注释更易懂。（aka，注释要写的清楚明白，好好说话）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Comments should be as readable as narrative text, with proper capitalization and&lt;br&gt;
punctuation. In many cases, complete sentences are more readable than sentence&lt;br&gt;
fragments. Shorter comments, such as comments at the end of a line of code, can&lt;br&gt;
sometimes be less formal, but use a consistent style.&lt;br&gt;
When writing your comments, write for your audience: the next contributor who will need to understand your code. Be generous—the next one may be you!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注释要读起来是叙事文字，需要使用合适的大小写和标点。很多场景中，完整的句子比一段段的文字更易懂。注释要简短，例如一行代码后的注释，可以是非正式的（句子），但请使用一致的风格。&lt;/p&gt;
&lt;p&gt;当你写注释时，要为你的读者而写，也就是后面需要读你代码的合作者。要慷慨些，也许他之后读注释的就是你自己。&lt;/p&gt;
&lt;h3 id="filecomments"&gt;文件注释（File Comments）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;A file may optionally start with a description of its contents.&lt;br&gt;
Every file may contain the following items, in order:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;License boilerplate if necessary. Choose the appropriate boilerplate for the license used by the project.&lt;/li&gt;
&lt;li&gt;A basic description of the contents of the file if necessary.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;文件头部可以添加该文件的注释说明。文件注释可以包含这些内容，顺序如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如有必要，添加许可。选择工程使用的合适的许可引用说明&lt;/li&gt;
&lt;li&gt;文件内容简要说明&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;If you make significant changes to a file with an author line, consider deleting&lt;br&gt;
the author line since revision history already provides a more detailed and&lt;br&gt;
accurate record of authorship.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果对具有作者行的文件进行了重大更改，请考虑删除作者行，因为修订历史记录已提供更详细和准确的作者记录。&lt;/p&gt;
&lt;h3 id="declarationcomments"&gt;声明注释（Declaration Comments）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Every non-trivial interface, public and private, should have an accompanying&lt;br&gt;
comment describing its purpose and how it fits into the larger picture.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;每个公开和私有的重要接口，要有附加的注释说明其作用和试用场景。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Comments should be used to document classes, properties, ivars, functions,&lt;br&gt;
categories, protocol declarations, and enums.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注释适用于要有文档说明的类、属性、成员变量、方法、扩展、协议声明及枚举。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

/**
 * A delegate for NSApplication to handle notifications about app
 * launch and shutdown. Owned by the main app controller.
 */
@interface MyAppDelegate : NSObject {
  /**
   * The background task in progress, if any. This is initialized
   * to the value UIBackgroundTaskInvalid.
   */
  UIBackgroundTaskIdentifier _backgroundTaskID;
}

/** The factory that creates and manages fetchers for the app. */
@property(nonatomic) GTMSessionFetcherService *fetcherService;

@end
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Doxygen-style comments are encouraged for interfaces as they are parsed by Xcode&lt;br&gt;
to display formatted documentation. There is a wide variety of Doxygen commands;&lt;br&gt;
use them consistently within a project.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接口推荐使用Doxygen风格注释，并可以利用xcode将注释原样转化为文档。Doxygen命令很多样，请在工程中保持一致，即使用同一套Doxygen命令&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If you have already described an interface in detail in the comments at the top&lt;br&gt;
of your file, feel free to simply state, &amp;quot;See comment at top of file for a&lt;br&gt;
complete description&amp;quot;, but be sure to have some sort of comment.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果在文件顶部已经添加了对接口的详细说明，你可以轻松的指出：&amp;quot;请参考文件顶部的完整说明&amp;quot;，但一定要有类似说明，说明一下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Additionally, each method should have a comment explaining its function,&lt;br&gt;
arguments, return value, thread or queue assumptions, and any side effects.&lt;br&gt;
Documentation comments should be in the header for public methods, or&lt;br&gt;
immediately preceding the method for non-trivial private methods.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另外，每个方法需要有注释解释其功能、参数、返回值、使用线程假设，以及副作用。文档化注释需要在公开方法的头文件中，或者紧挨着重要的私有方法前。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Use descriptive form (&amp;quot;Opens the file&amp;quot;) rather than imperative form (&amp;quot;Open the&lt;br&gt;
file&amp;quot;) for method and function comments. The comment describes the function; it&lt;br&gt;
does not tell the function what to do.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于方法和函数的注释使用描述性形式，而不是使用命令形式。注释描述其功能，而不是让函数去做什么。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Document the thread usage assumptions the class, properties, or methods make, if&lt;br&gt;
any. If an instance of the class can be accessed by multiple threads, take extra&lt;br&gt;
care to document the rules and invariants surrounding multithreaded use.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于类、属性、方法，如果需要，添加线程使用假设文档说明。若类的示例被多个线程访问使用，对此文档中要格外说明其在多线程中使用规范及不变式。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Any sentinel values for properties and ivars, such as &lt;code&gt;NULL&lt;/code&gt; or &lt;code&gt;-1&lt;/code&gt;, should be&lt;br&gt;
documented in comments.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;任何属性或成员变量的临界值，例如&lt;code&gt;NULL&lt;/code&gt;或&lt;code&gt;-1&lt;/code&gt;, 都需要在文档中注释说明其代表的意义。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Declaration comments explain how a method or function is used. Comments&lt;br&gt;
explaining how a method or function is implemented should be with the&lt;br&gt;
implementation rather than with the declaration.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;声明注释用于解释方法或函数应该如何被使用。那些解释方法或函数是如何实现的注释，应该添加在实现处，而不是函数或方法的声明处。&lt;/p&gt;
&lt;h3 id="implementationcomments"&gt;实现注释（Implementation Comments）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Provide comments explaining tricky, subtle, or complicated sections of code.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对刁钻、微妙或复杂的代码添加注释，解释其中奥妙。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

// Set the property to nil before invoking the completion handler to
// avoid the risk of reentrancy leading to the callback being
// invoked again.
CompletionHandler handler = self.completionHandler;
self.completionHandler = nil;
handler();
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;When useful, also provide comments about implementation approaches that were&lt;br&gt;
considered or abandoned.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果需要，也对一些考虑使用或放弃使用的方法实现添加注释。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;End-of-line comments should be separated from the code by at least 2 spaces. If&lt;br&gt;
you have several comments on subsequent lines, it can often be more readable to&lt;br&gt;
line them up.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;跟在代码行尾的注释需要至少用两个空格隔开代码与注释。如果你在随后的多行里有多个注释，更易读的办法是把他们（对齐）排好。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

[self doSomethingWithALongName];  // Two spaces before the comment.
[self doSomethingShort];          // More spacing to align the comment.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="disambiguatingsymbols"&gt;消除符号歧义（Disambiguating Symbols）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Where needed to avoid ambiguity, use backticks or vertical bars to quote&lt;br&gt;
variable names and symbols in comments in preference to using quotation marks&lt;br&gt;
or naming the symbols inline.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在需要避免歧义的地方，使用反引号或竖杠将注释中变量名字或符号引起来，要优于使用引号或内联命名符号。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In Doxygen-style comments, prefer demarcating symbols with a monospace text&lt;br&gt;
command, such as &lt;code&gt;@c&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Doxygen风格注释中，更建议使用等宽文本命令来划分标定符号，例如&lt;code&gt;@c&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Demarcation helps provide clarity when a symbol is a common word that might make&lt;br&gt;
the sentence read like it was poorly constructed. A common example is the symbol&lt;br&gt;
&lt;code&gt;count&lt;/code&gt;:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当一个符号命名是常用单词时，划定边界会使注释更清晰。若不划分，可能会使句子读起来不通顺。常见的例子如单词&lt;code&gt;count&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

// Sometimes `count` will be less than zero.
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;or when quoting something which already contains quotes&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;或引用已经有引号的文字&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

// Remember to call `StringWithoutSpaces(&amp;quot;foo bar baz&amp;quot;)`
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Backticks or vertical bars are not needed when a symbol is self-apparent.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于显而易见的文字不需要添加反引号或竖杠。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

// This class serves as a delegate to GTMDepthCharge.
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Doxygen formatting is also suitable for identifying symbols.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Doxygen格式化同样适用标识符号。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

/** @param maximum The highest value for @c count. */
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="objectownership"&gt;对象所有权（Object Ownership）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;For objects not managed by ARC, make the pointer ownership model as explicit as&lt;br&gt;
possible when it falls outside the most common Objective-C usage idioms.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不在ARC管理下的对象，当这些对象的指针在常见的Objective-C常用用法之外时，需要尽可能明确的说明该对象的指针。&lt;/p&gt;
&lt;h4 id="mrcmanualreferencecounting"&gt;MRC（Manual Reference Counting）&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;Instance variables for NSObject-derived objects are presumed to be retained; if&lt;br&gt;
they are not retained, they should be either commented as weak or declared with&lt;br&gt;
the &lt;code&gt;__weak&lt;/code&gt; lifetime qualifier.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;NSObject子类的所有示例对象都被假定为会被保留计数，若他们没有被保留计数，要么需要注释为弱引用，要么声明时使用为&lt;code&gt;__weak&lt;/code&gt;标识符。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;An exception is in Mac software for instance variables labeled as &lt;code&gt;@IBOutlets&lt;/code&gt;,&lt;br&gt;
which are presumed to not be retained.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Mac软件中，被标示为 &lt;code&gt;@IBOutlets&lt;/code&gt;的实例变量是个例外，这些变量假定不会被保留计数。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Where instance variables are pointers to Core Foundation, C++, and other&lt;br&gt;
non-Objective-C objects, they should always be declared with strong and weak&lt;br&gt;
comments to indicate which pointers are and are not retained. Core Foundation&lt;br&gt;
and other non-Objective-C object pointers require explicit memory management,&lt;br&gt;
even when building for automatic reference counting.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当实例变量指向Core Foundation，C++或其他非Objective-C对象，这些变量应该使用使用strong和weak，注释其哪些是被保留的，哪些不保留。Core Foundation和其他非Objective-C对象指针需要清晰明确的内存管理，即便使用ARC情况下也一样。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Examples of strong and weak declarations:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;strong和weak声明示例&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

@interface MyDelegate : NSObject

@property(nonatomic) NSString *doohickey;
@property(nonatomic, weak) NSString *parent;

@end


@implementation MyDelegate {
  IBOutlet NSButton *_okButton;  // Normal NSControl; implicitly weak on Mac only

  AnObjcObject *_doohickey;  // My doohickey
  __weak MyObjcParent *_parent;  // To send messages back (owns this instance)

  // non-NSObject pointers...
  CWackyCPPClass *_wacky;  // Strong, some cross-platform object
  CFDictionaryRef *_dict;  // Strong
}
@end
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="arcautomaticreferencecounting"&gt;ARC （Automatic Reference Counting）&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;Object ownership and lifetime are explicit when using ARC, so no additional&lt;br&gt;
comments are required for automatically retained objects.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当使用ARC时，对象所有权和生命周期很清晰，所以不需要额外的注释来说明自动引用计数变量。&lt;/p&gt;
&lt;h2 id="cclanguagefeatures"&gt;C语言特性（C Language Features）&lt;/h2&gt;
&lt;h3 id="macros"&gt;宏（Macros）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Avoid macros, especially where &lt;code&gt;const&lt;/code&gt; variables, enums, XCode snippets, or C&lt;br&gt;
functions may be used instead.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;若能使用&lt;code&gt;const&lt;/code&gt;变量，枚举，Xcode代码片段，或C函数，请不要使用宏。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Macros make the code you see different from the code the compiler sees. Modern C&lt;br&gt;
renders traditional uses of macros for constants and utility functions&lt;br&gt;
unnecessary. Macros should only be used when there is no other solution&lt;br&gt;
available.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;宏会使你看到的代码和编译器看到的代码不同。现代C使用宏的的传统用途不再是常量和工具函数。现在宏只有在没有其他解决方案时才被使用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Where a macro is needed, use a unique name to avoid the risk of a symbol&lt;br&gt;
collision in the compilation unit. If practical, keep the scope limited by&lt;br&gt;
&lt;code&gt;#undefining&lt;/code&gt; the macro after its use.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;需要宏的地方，使用唯一的名字以避免在汇编时符号冲突。如果可行，使用&lt;code&gt;#undefining&lt;/code&gt;限制宏的使用范围。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Macro names should use &lt;code&gt;SHOUTY_SNAKE_CASE&lt;/code&gt;—all uppercase letters with&lt;br&gt;
underscores between words. Function-like macros may use C function naming&lt;br&gt;
practices. Do not define macros that appear to be C or Objective-C keywords.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;宏的名字应该使用&lt;code&gt;SHOUTY_SNAKE_CASE&lt;/code&gt;形式——所有字母大写，使用下划线链接不同单词。函数类的宏使用函数的命名规范。不要定义和C或Objective-C关键字同名的宏。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

#define GTM_EXPERIMENTAL_BUILD ...      // GOOD

// Assert unless X &amp;gt; Y
#define GTM_ASSERT_GT(X, Y) ...         // GOOD, macro style.

// Assert unless X &amp;gt; Y
#define GTMAssertGreaterThan(X, Y) ...  // GOOD, function style.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// AVOID:

#define kIsExperimentalBuild ...        // AVOID

#define unless(X) if(!(X))              // AVOID
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Avoid macros that expand to unbalanced C or Objective-C constructs. Avoid macros&lt;br&gt;
that introduce scope, or may obscure the capturing of values in blocks.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;这一段突然不知道如何翻译&lt;/em&gt;，大意是：避免使用会导致C或Objective-C构造方法错乱的宏，避免使用会引入作用域或让block中变量持有者模糊（防止内存泄漏）的宏。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Avoid macros that generate class, property, or method definitions in&lt;br&gt;
headers to be used as public API. These only make the code hard to&lt;br&gt;
understand, and the language already has better ways of doing this.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;避免在公用API头文件中使用可以生成类，属性或方法定义的宏。这种用法会导致代码难懂，而且语言本身有相对此方法更好的实现方法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Avoid macros that generate method implementations, or that generate declarations&lt;br&gt;
of variables that are later used outside of the macro. Macros shouldn't make&lt;br&gt;
code hard to understand by hiding where and how a variable is declared.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;避免使用生成方法实现的宏（比如生成单例方法的宏等）或者可生成变量声明，且该变量在宏外使用的宏。宏不能隐藏变量在何处以及如何被声明，这会导致代码晦涩难懂。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// AVOID:

#define ARRAY_ADDER(CLASS) \
  -(void)add ## CLASS ## :(CLASS *)obj toArray:(NSMutableArray *)array

ARRAY_ADDER(NSString) {
  if (array.count &amp;gt; 5) {              // AVOID -- where is 'array' defined?
    ...
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Examples of acceptable macro use include assertion and debug logging macros&lt;br&gt;
that are conditionally compiled based on build settings—often, these are&lt;br&gt;
not compiled into release builds.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;宏中使用assert或根据编译设置，进行debug有条件编译，这可以接受，一般情况下这些条件编译代码不会包含在release版本中。&lt;/p&gt;
&lt;h3 id="nonstandardextensions"&gt;非标准扩展宏（Nonstandard Extensions）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Nonstandard extensions to C/Objective-C may not be used unless otherwise&lt;br&gt;
specified.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;C/Objective-C非标准扩展宏，除非特别说明，否则不可使用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Compilers support various extensions that are not part of standard C. Examples&lt;br&gt;
include compound statement expressions (e.g. &lt;code&gt;foo = ({ int x; Bar(&amp;amp;x); x })&lt;/code&gt;).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;编译器支持大量的非标准C语言扩展宏。例如复合语句表达式(例如： &lt;code&gt;foo = ({ int x; Bar(&amp;amp;x); x })&lt;/code&gt;).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;__attribute__&lt;/code&gt; is an approved exception, as it is used in Objective-C API&lt;br&gt;
specifications.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;__attribute__&lt;/code&gt; 是一个在Objective-C API被认可和使用的扩展宏。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The binary form of the conditional operator, &lt;code&gt;A ?: B&lt;/code&gt;, is an approved exception.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于三元运算符，&lt;code&gt;A ?: B&lt;/code&gt;这种用法是个例外，也被认可使用。&lt;/p&gt;
&lt;h2 id="cocoaobjectiveccocoaandobjectivecfeatures"&gt;Cocoa&amp;amp;Objective-C特性 （Cocoa and Objective-C Features）&lt;/h2&gt;
&lt;h3 id="identifydesignatedinitializer"&gt;明确特定初始化器（Identify Designated Initializer）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Clearly identify your designated initializer.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;清晰指明你的特定初始化器（也可以理解成初始化方法）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It is important for those who might be subclassing your class that the&lt;br&gt;
designated initializer be clearly identified. That way, they only need to&lt;br&gt;
override a single initializer (of potentially several) to guarantee the&lt;br&gt;
initializer of their subclass is called. It also helps those debugging your&lt;br&gt;
class in the future understand the flow of initialization code if they need to&lt;br&gt;
step through it. Identify the designated initializer using comments or the&lt;br&gt;
&lt;code&gt;NS_DESIGNATED_INITIALIZER&lt;/code&gt; macro. If you use &lt;code&gt;NS_DESIGNATED_INITIALIZER&lt;/code&gt;, mark&lt;br&gt;
unsupported initializers with &lt;code&gt;NS_UNAVAILABLE&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;清晰的指明你创建的类的特定初始化器，这一点在其他人创建继承自你的类时显得非常重要。这样的话，他们只需要重写某一个或几个初始化器就可以保证他们的子类初始化方法被调用。这也可以帮助后面可能调试代码的人，更清晰的了解你的类初始化流程。请使用注释或者&lt;code&gt;NS_DESIGNATED_INITIALIZER&lt;/code&gt; 宏指明你的特定初始化器。如果使用&lt;code&gt;NS_DESIGNATED_INITIALIZER&lt;/code&gt; 宏，请将其他不支持的初始化器用 &lt;code&gt;NS_UNAVAILABLE&lt;/code&gt;来标注。&lt;/p&gt;
&lt;h3 id="overridedesignatedinitializer"&gt;重写指定初始化器（Override Designated Initializer）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;When writing a subclass that requires an &lt;code&gt;init...&lt;/code&gt; method, make sure you&lt;br&gt;
override the designated initializer of the superclass.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;若实现一个类需要 &lt;code&gt;init...&lt;/code&gt; 方法，必须重写父类的指定初始化器。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If you fail to override the designated initializer of the superclass, your&lt;br&gt;
initializer may not be called in all cases, leading to subtle and very difficult&lt;br&gt;
to find bugs.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果不重写父类的指定初始化器，你自己的初始化器可能不会保证在所有情况下都被调用，这会导致bug很诡异，难以被发现。&lt;/p&gt;
&lt;h3 id="nsobjectoverriddennsobjectmethodplacement"&gt;NSObject重写方法的放置位置（Overridden NSObject Method Placement)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Put overridden methods of NSObject at the top of an &lt;code&gt;@implementation&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;将NSObject的重写方法置于&lt;code&gt;@implementation&lt;/code&gt;部分的顶部。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This commonly applies to (but is not limited to) the &lt;code&gt;init...&lt;/code&gt;, &lt;code&gt;copyWithZone:&lt;/code&gt;,&lt;br&gt;
and &lt;code&gt;dealloc&lt;/code&gt; methods. The &lt;code&gt;init...&lt;/code&gt; methods should be grouped together,&lt;br&gt;
followed by other typical &lt;code&gt;NSObject&lt;/code&gt; methods such as &lt;code&gt;description&lt;/code&gt;, &lt;code&gt;isEqual:&lt;/code&gt;,&lt;br&gt;
and &lt;code&gt;hash&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这通常用于但不局限于 &lt;code&gt;init...&lt;/code&gt;, &lt;code&gt;copyWithZone:&lt;/code&gt;, &lt;code&gt;dealloc&lt;/code&gt;方法。 &lt;code&gt;init…&lt;/code&gt; 一类的方法要集合放置在一起，后面可以放置其他 &lt;code&gt;NSObject&lt;/code&gt; 常用方法，例如 &lt;code&gt;description&lt;/code&gt;, &lt;code&gt;isEqual:&lt;/code&gt;和 &lt;code&gt;hash&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Convenience class factory methods for creating instances may precede the&lt;br&gt;
&lt;code&gt;NSObject&lt;/code&gt; methods.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;便捷的创建对象的工厂方法可以放置在&lt;code&gt;NSObject&lt;/code&gt; 之前。&lt;/p&gt;
&lt;h3 id="initialization"&gt;初始化（Initialization）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Don't initialize instance variables to &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt; in the &lt;code&gt;init&lt;/code&gt; method; doing&lt;br&gt;
so is redundant.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不必在 &lt;code&gt;init&lt;/code&gt; 方法中初始化实例变量为 &lt;code&gt;0&lt;/code&gt; 或 &lt;code&gt;nil&lt;/code&gt; ，多余！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;All instance variables for a newly allocated object are &lt;a href="https://developer.apple.com/library/mac/documentation/General/Conceptual/CocoaEncyclopedia/ObjectAllocation/ObjectAllocation.html"&gt;initialized to&lt;/a&gt;&lt;br&gt;
&lt;code&gt;0&lt;/code&gt; (except for isa), so don't clutter up the init method by re-initializing&lt;br&gt;
variables to &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所有新创建的实例变量都会被初始化为0（isa除外），所以不必散乱的在init初始化方法中将实例变量初始化为 &lt;code&gt;0&lt;/code&gt; 或 &lt;code&gt;nil&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id="protectedprivateinstancevariablesinheadersshouldbeprotectedorprivate"&gt;头文件中的实例变量的作用域应该是@protected或@private（Instance Variables In Headers Should Be @protected or @private）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Instance variables should typically be declared in implementation files or&lt;br&gt;
auto-synthesized by properties. When ivars are declared in a header file, they&lt;br&gt;
should be marked &lt;code&gt;@protected&lt;/code&gt; or &lt;code&gt;@private&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;实例变量通常被放置在头文件中，或通过property被自动synthesize。若实例变量被声明在头文件中，这些成员变量需要被标记为 &lt;code&gt;@protected&lt;/code&gt; 或 &lt;code&gt;@private&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

@interface MyClass : NSObject {
 @protected
  id _myInstanceVariable;
}
@end
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="newdonotusenew"&gt;不要使用+new（Do Not Use +new）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Do not invoke the &lt;code&gt;NSObject&lt;/code&gt; class method &lt;code&gt;new&lt;/code&gt;, nor override it in a subclass.&lt;br&gt;
&lt;code&gt;+new&lt;/code&gt; is rarely used and contrasts greatly with initializer usage. Instead, use&lt;br&gt;
&lt;code&gt;+alloc&lt;/code&gt; and &lt;code&gt;-init&lt;/code&gt; methods to instantiate retained objects.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不可调用NSObject的类方法&lt;code&gt;new&lt;/code&gt;或在子类中重写该方法。&lt;code&gt;+new&lt;/code&gt;方法很少使用，与初始化器的使用有很大的不同。相反，一般使用+alloc和-init方法来创建和初始化实例对象。&lt;/p&gt;
&lt;h3 id="apikeepthepublicapisimple"&gt;公开API保持简单（Keep the Public API Simple）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Keep your class simple; avoid &amp;quot;kitchen-sink&amp;quot; APIs. If a method doesn't need to&lt;br&gt;
be public, keep it out of the public interface.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;保持类简单，避免“kitchen-sink”（激进现实主义）API。如果一个方法不需要作为公开方法，请不要暴露在公开接口中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Unlike C++, Objective-C doesn't differentiate between public and private&lt;br&gt;
methods; any message may be sent to an object. As a result, avoid placing&lt;br&gt;
methods in the public API unless they are actually expected to be used by a&lt;br&gt;
consumer of the class. This helps reduce the likelihood they'll be called when&lt;br&gt;
you're not expecting it. This includes methods that are being overridden from&lt;br&gt;
the parent class.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;和C++不同，Objective-C在公开方法和私有方法之间并没有什么太多区分，任何消息都可能被发送给对象。因此，只有使用者需要调用某一个方法时，才把这个方法放置在公开的API中。这样可以降低一些你不希望外界调用的方法被调用的可能性，这也包括重写的父类方法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Since internal methods are not really private, it's easy to accidentally&lt;br&gt;
override a superclass's &amp;quot;private&amp;quot; method, thus making a very difficult bug to&lt;br&gt;
squash. In general, private methods should have a fairly unique name that will&lt;br&gt;
prevent subclasses from unintentionally overriding them.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为内部方法并不是真正的私有方法，也容易碰巧重写一个父类的私有方法，这样会导致很难排除由此引起的bug。通常隐私方法需要有一个较为独特的名字，这样可以防止子类无意的重写这些方法。&lt;/p&gt;
&lt;h3 id="importincludeimportandinclude"&gt;#import和#include（#import and #include）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;#import&lt;/code&gt; Objective-C and Objective-C++ headers, and &lt;code&gt;#include&lt;/code&gt; C/C++ headers.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用&lt;code&gt;#import&lt;/code&gt;引用Objective-C 和 Objective-C++头文件，用&lt;code&gt;#include&lt;/code&gt; C/C++头文件。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;C/C++ headers include other C/C++ headers using &lt;code&gt;#include&lt;/code&gt;. Using &lt;code&gt;#import&lt;/code&gt;&lt;br&gt;
on C/C++ headers prevents future inclusions using &lt;code&gt;#include&lt;/code&gt; and could result in&lt;br&gt;
unintended compilation behavior.&lt;br&gt;
C/C++ headers should provide their own &lt;code&gt;#define&lt;/code&gt; guard.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;C/C++头文件中引用其他C/C++头文件使用&lt;code&gt;#include&lt;/code&gt;。使用&lt;code&gt;#import&lt;/code&gt;引用C/C++头文件，以避免后面使用 &lt;code&gt;#include&lt;/code&gt; 可能导致的头文件冲突和编译问题。&lt;/p&gt;
&lt;p&gt;C/C++每个头文件中需要有自己&lt;code&gt;#define&lt;/code&gt;保护，（以防止头文件被重复引用导致的重复编译的问题）。&lt;/p&gt;
&lt;h3 id="orderofincludes"&gt;头文件引用顺序（Order of Includes）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;The standard order for header inclusion is the related header, operating system&lt;br&gt;
headers, language library headers, and finally groups of headers for other&lt;br&gt;
dependencies.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;标准头文件引用顺序为相关头文件、系统头文件、语言库头文件，最终是其他引用头文件。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The related header precedes others to ensure it has no hidden dependencies.&lt;br&gt;
For implementation files the related header is the header file.&lt;br&gt;
For test files the related header is the header containing the tested interface.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;相关头文件放在其他头文件前，可以保证其他隐藏依赖。对于implementation文件，它的相关头文件就是它自己的头文件。对于测试文件，它的相关头文件就是包含被测试接口的头文件。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A blank line may separate logically distinct groups of included headers.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用空行来区分不同类别的头文件。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Within each group the includes should be ordered alphabetically.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不同类别的头文件，需要按字母顺序排列。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Import headers using their path relative to the project's source directory.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以工程目录作为根目录，使用相对路径引用头文件。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

#import &amp;quot;ProjectX/BazViewController.h&amp;quot;

#import &amp;lt;Foundation/Foundation.h&amp;gt;

#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;vector&amp;gt;

#include &amp;quot;base/basictypes.h&amp;quot;
#include &amp;quot;base/integral_types.h&amp;quot;
#include &amp;quot;util/math/mathutil.h&amp;quot;

#import &amp;quot;ProjectX/BazModel.h&amp;quot;
#import &amp;quot;Shared/Util/Foo.h&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="umbrellauseumbrellaheadersforsystemframeworks"&gt;使用系统库Umbrella头文件（Use Umbrella Headers for System Frameworks）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Import umbrella headers for system frameworks and system libraries rather than&lt;br&gt;
include individual files.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;引用系统库的umbrella头文件，而不是引用某几个单独的头文件。（关于umbrella头文件，更像是一个库中专门暴露出来，供外界使用者去引用的头文件，而不是引用库中的某些头文件，详细解析请Google）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;While it may seem tempting to include individual system headers from a framework&lt;br&gt;
such as Cocoa or Foundation, in fact it's less work on the compiler if you&lt;br&gt;
include the top-level root framework. The root framework is generally&lt;br&gt;
pre-compiled and can be loaded much more quickly. In addition, remember to use&lt;br&gt;
&lt;code&gt;@import&lt;/code&gt; or &lt;code&gt;#import&lt;/code&gt; rather than &lt;code&gt;#include&lt;/code&gt; for Objective-C frameworks.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;人们似乎更倾向引用Cocoa或Foundation系统库中单独的头文件，这样看起来引用更简单，但事实上，引用系统库的顶层头文件会让编译器做更少的工作。根框架通常会预处理，从而加载速度更快。另外，对于Objective-C框架，记住使用&lt;code&gt;@import&lt;/code&gt;和&lt;code&gt;#import&lt;/code&gt;，而不使用 &lt;code&gt;#include&lt;/code&gt; 。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

@import UIKit;     // GOOD.
#import &amp;lt;Foundation/Foundation.h&amp;gt;     // GOOD.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// AVOID:

#import &amp;lt;Foundation/NSArray.h&amp;gt;        // AVOID.
#import &amp;lt;Foundation/NSString.h&amp;gt;
...
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="deallocavoidmessagingthecurrentobjectwithininitializersanddealloc"&gt;避免在初始化器或&lt;code&gt;-dealloc&lt;/code&gt;中给当前对象发消息（Avoid Messaging the Current Object Within Initializers and &lt;code&gt;-dealloc&lt;/code&gt;）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Code in initializers and &lt;code&gt;-dealloc&lt;/code&gt; should avoid invoking instance methods.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;初始化器或 &lt;code&gt;-dealloc&lt;/code&gt;方法中，避免调用该类对象的实例方法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Superclass initialization completes before subclass initialization. Until all&lt;br&gt;
classes have had a chance to initialize their instance state any method&lt;br&gt;
invocation on self may lead to a subclass operating on uninitialized instance&lt;br&gt;
state.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;父类的初始化方法先于子类初始化方法执行。在所有类都被初始化，使该对象的所有属性被初始化之前调用该类的示例方法，都可能导致子类直接操作未初始化的属性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A similar issue exists for &lt;code&gt;-dealloc&lt;/code&gt;, where a method invocation may cause a&lt;br&gt;
class to operate on state that has been deallocated.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;-dealloc&lt;/code&gt;方法中也存在类似问题，例如在&lt;code&gt;-dealloc&lt;/code&gt;调用一些实例方法，这些方法操作的某些属性，可能早已被释放掉了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;One case where this is less obvious is property accessors. These can be&lt;br&gt;
overridden just like any other selector. Whenever practical, directly assign to&lt;br&gt;
and release ivars in initializers and &lt;code&gt;-dealloc&lt;/code&gt;, rather than rely on accessors.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;属性访问是一种不太明显的案例。属性访问器可以像其他selector一样被重写。一旦切实可行，直接在初始化器和&lt;code&gt;-dealloc&lt;/code&gt;方法中对成员变量进行赋值和释放，而不是通过属性访问器来完成。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

- (instancetype)init {
  self = [super init];
  if (self) {
    _bar = 23;  // GOOD.
  }
  return self;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Beware of factoring common initialization code into helper methods:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Methods can be overridden in subclasses, either deliberately, or&lt;br&gt;
accidentally due to naming collisions.&lt;/li&gt;
&lt;li&gt;When editing a helper method, it may not be obvious that the code is being&lt;br&gt;
run from an initializer.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;拆解通用初始化代码为工具方法要谨慎！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;工具方法可能会有意或无意的被子类重写，或者碰巧产生了命名冲突；&lt;/li&gt;
&lt;li&gt;当编辑一个工具方法时，可能不会知晓这段代码是被初始化方法调用的；&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// AVOID:

- (instancetype)init {
  self = [super init];
  if (self) {
    self.bar = 23;  // AVOID.
    [self sharedMethod];  // AVOID. Fragile to subclassing or future extension.
  }
  return self;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

- (void)dealloc {
  [_notifier removeObserver:self];  // GOOD.
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// AVOID:

- (void)dealloc {
  [self removeNotifications];  // AVOID.
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="setternsstringscopysetterscopynsstrings"&gt;Setter方法中NSStrings要Copy（Setters copy NSStrings）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Setters taking an &lt;code&gt;NSString&lt;/code&gt; should always copy the string it accepts. This is&lt;br&gt;
often also appropriate for collections like &lt;code&gt;NSArray&lt;/code&gt; and &lt;code&gt;NSDictionary&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Setter方法中对传入的&lt;code&gt;NSString&lt;/code&gt;参数必须copy一份再使用，同样，对于容器类参数，例如 &lt;code&gt;NSArray&lt;/code&gt;、 &lt;code&gt;NSDictionary&lt;/code&gt;，也需要copy再使用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Never just retain the string, as it may be a &lt;code&gt;NSMutableString&lt;/code&gt;. This avoids the&lt;br&gt;
caller changing it under you without your knowledge.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;永远不要只考虑是string类型，也可能（传入的）是&lt;code&gt;NSMutableString&lt;/code&gt;类型。这可以避免在你不知情的情况下，调用方修改该值。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Code receiving and holding collection objects should also consider that the&lt;br&gt;
passed collection may be mutable, and thus the collection could be more safely&lt;br&gt;
held as a copy or mutable copy of the original.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;持有容器对象参数也需要考虑该对象可能也是可变的，因此，使用该容器参数的复制对象，相对更安全。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

@property(nonatomic, copy) NSString *name;

- (void)setZigfoos:(NSArray&amp;lt;Zigfoo *&amp;gt; *)zigfoos {
  // Ensure that we're holding an immutable collection.
  _zigfoos = [zigfoos copy];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="uselightweightgenericstodocumentcontainedtypes"&gt;用泛型标识元素类型（Use Lightweight Generics to Document Contained Types）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;All projects compiling on Xcode 7 or newer versions should make use of the&lt;br&gt;
Objective-C lightweight generics notation to type contained objects.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Xcode7或更新版本编译的工程，应该使用Objective-C轻量级泛型符号来标识其包含的对象类别。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Every &lt;code&gt;NSArray&lt;/code&gt;, &lt;code&gt;NSDictionary&lt;/code&gt;, or &lt;code&gt;NSSet&lt;/code&gt; reference should be declared using&lt;br&gt;
lightweight generics for improved type safety and to explicitly document usage.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;NSArray&lt;/code&gt;, &lt;code&gt;NSDictionary&lt;/code&gt;, 或 &lt;code&gt;NSSet&lt;/code&gt;对象都需要轻量级泛型符号标明，这可以改善类型安全以及明确文档使用说明。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

@property(nonatomic, copy) NSArray&amp;lt;Location *&amp;gt; *locations;
@property(nonatomic, copy, readonly) NSSet&amp;lt;NSString *&amp;gt; *identifiers;

NSMutableArray&amp;lt;MyLocation *&amp;gt; *mutableLocations = [otherObject.locations mutableCopy];
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;If the fully-annotated types become complex, consider using a typedef to&lt;br&gt;
preserve readability.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;若要标识的泛型比较复杂，可以考虑使用typedef定义新类型，以保持可读性。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

typedef NSSet&amp;lt;NSDictionary&amp;lt;NSString *, NSDate *&amp;gt; *&amp;gt; TimeZoneMappingSet;
TimeZoneMappingSet *timeZoneMappings = [TimeZoneMappingSet setWithObjects:...];
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Use the most descriptive common superclass or protocol available. In the most&lt;br&gt;
generic case when nothing else is known, declare the collection to be explicitly&lt;br&gt;
heterogenous using id.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用最具描述性的常用父类或协议。通常情况下，当不知道容器中对象类型时，使用id显式声明。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

@property(nonatomic, copy) NSArray&amp;lt;id&amp;gt; *unknowns;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="avoidthrowingexceptions"&gt;避免抛异常（Avoid Throwing Exceptions）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Don't &lt;code&gt;@throw&lt;/code&gt; Objective-C exceptions, but you should be prepared to catch them&lt;br&gt;
from third-party or OS calls.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不要使用&lt;code&gt;@throw&lt;/code&gt; 抛出Objective-C异常，但在使用第三库或系统调用时，你还必须要考虑如何捕获异常。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This follows the recommendation to use error objects for error delivery in&lt;br&gt;
&lt;a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Exceptions/Exceptions.html"&gt;Apple's Introduction to Exception Programming Topics for&lt;br&gt;
Cocoa&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这遵循关于错误对象错误传递的推荐说明文档：&lt;a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Exceptions/Exceptions.html"&gt;Apple's Introduction to Exception Programming Topics for&lt;br&gt;
Cocoa&lt;/a&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;We do compile with &lt;code&gt;-fobjc-exceptions&lt;/code&gt; (mainly so we get &lt;code&gt;@synchronized&lt;/code&gt;), but&lt;br&gt;
we don't &lt;code&gt;@throw&lt;/code&gt;. Use of &lt;code&gt;@try&lt;/code&gt;, &lt;code&gt;@catch&lt;/code&gt;, and &lt;code&gt;@finally&lt;/code&gt; are allowed when&lt;br&gt;
required to properly use 3rd party code or libraries. If you do use them, please&lt;br&gt;
document exactly which methods you expect to throw.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们编译时使用编译选项&lt;code&gt;-fobjc-exceptions&lt;/code&gt;（通常也用&lt;code&gt;@synchronized&lt;/code&gt;），但我们不使用&lt;code&gt;@throw&lt;/code&gt;。当使用第三方库或代码时， &lt;code&gt;@try&lt;/code&gt;, &lt;code&gt;@catch&lt;/code&gt;和 &lt;code&gt;@finally&lt;/code&gt; 是被允许使用的。如果确定使用了这些关键字，请清晰明确的指明哪些方法会抛出异常。&lt;/p&gt;
&lt;h3 id="nilnilchecks"&gt;&lt;code&gt;nil&lt;/code&gt;检查 （&lt;code&gt;nil&lt;/code&gt; Checks）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Avoid &lt;code&gt;nil&lt;/code&gt; pointer checks that exist only to prevent sending messages to &lt;code&gt;nil&lt;/code&gt;.&lt;br&gt;
Sending a message to &lt;code&gt;nil&lt;/code&gt; &lt;a href="http://www.sealiesoftware.com/blog/archive/2012/2/29/objc_explain_return_value_of_message_to_nil.html"&gt;reliably returns&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nil&lt;/code&gt; as a pointer, zero as an integer or floating-point value, structs initialized to &lt;code&gt;0&lt;/code&gt;, and &lt;code&gt;_Complex&lt;/code&gt; values equal to &lt;code&gt;{0, 0}&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果指针检查只是为了防止给nil对象发消息，那这部分检查不必添加。&lt;/p&gt;
&lt;p&gt;给&lt;code&gt;nil&lt;/code&gt;发消息的返回值是可靠的&lt;/p&gt;
&lt;p&gt;返回值是指针时，返回nil；返回值是整数或浮点数时，返回0；返回值是结构体时，返回0；返回值是&lt;code&gt;_Complex&lt;/code&gt;时，返回 &lt;code&gt;{0, 0}&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;(上面这句我也没读懂，我也不打算不懂装懂)&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// AVOID:

if (dataSource) {  // AVOID.
  [dataSource moveItemAtIndex:1 toIndex:0];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

[dataSource moveItemAtIndex:1 toIndex:0];  // GOOD.
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Note that this applies to &lt;code&gt;nil&lt;/code&gt; as a message target, not as a parameter value.&lt;br&gt;
Individual methods may or may not safely handle &lt;code&gt;nil&lt;/code&gt; parameter values.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意：这适用于 &lt;code&gt;nil&lt;/code&gt; 作为消息接受者，而不是作为参数值。&lt;/p&gt;
&lt;p&gt;个别方法可能会，也可能不会安全处理nil参数值。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Note too that this is distinct from checking C/C++ pointers and block pointers&lt;br&gt;
against &lt;code&gt;NULL&lt;/code&gt;, which the runtime does not handle and will cause your&lt;br&gt;
application to crash. You still need to make sure you do not dereference a&lt;br&gt;
&lt;code&gt;NULL&lt;/code&gt; pointer.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也请注意这区别于检查C/C++指针和block指针是否为&lt;code&gt;NULL&lt;/code&gt;, 这些运行时不会处理，这些会导致应用崩溃。你仍然需要检查指针不能为&lt;code&gt;NULL&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id="nullability"&gt;可空性（Nullability）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Interfaces can be decorated with nullability annotations to describe how the&lt;br&gt;
interface should be used and how it behaves. Use of nullability regions (e.g.,&lt;br&gt;
&lt;code&gt;NS_ASSUME_NONNULL_BEGIN&lt;/code&gt; and &lt;code&gt;NS_ASSUME_NONNULL_END&lt;/code&gt;) and explicit nullability&lt;br&gt;
annotations are both accepted. Prefer using the &lt;code&gt;_Nullable&lt;/code&gt; and &lt;code&gt;_Nonnull&lt;/code&gt;&lt;br&gt;
keywords over the &lt;code&gt;__nullable&lt;/code&gt; and &lt;code&gt;__nonnull&lt;/code&gt; keywords. For Objective-C methods&lt;br&gt;
and properties prefer using the context-sensitive, non-underscored keywords,&lt;br&gt;
e.g., &lt;code&gt;nonnull&lt;/code&gt; and &lt;code&gt;nullable&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Interface中可以使用可空性注解来描述接口行为和如何使用。使用可控性作用域（例如&lt;code&gt;NS_ASSUME_NONNULL_BEGIN&lt;/code&gt; 和 &lt;code&gt;NS_ASSUME_NONNULL_END&lt;/code&gt;）或使用可控性注解，这两种方式都是可以的。相对 &lt;code&gt;__nullable&lt;/code&gt; 和 &lt;code&gt;__nonnull&lt;/code&gt; 关键字，更推荐使用 &lt;code&gt;_Nullable&lt;/code&gt;和 &lt;code&gt;_Nonnull&lt;/code&gt;。对于Objective-C方法和属性，推荐使用无下划线的关键字，例如&lt;code&gt;nonnull&lt;/code&gt; 和 &lt;code&gt;nullable&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

/** A class representing an owned book. */
@interface GTMBook : NSObject

/** The title of the book. */
@property(readonly, copy, nonnull) NSString *title;

/** The author of the book, if one exists. */
@property(readonly, copy, nullable) NSString *author;

/** The owner of the book. Setting nil resets to the default owner. */
@property(copy, null_resettable) NSString *owner;

/** Initializes a book with a title and an optional author. */
- (nonnull instancetype)initWithTitle:(nonnull NSString *)title
                               author:(nullable NSString *)author
    NS_DESIGNATED_INITIALIZER;

/** Returns nil because a book is expected to have a title. */
- (nullable instancetype)init;

@end

/** Loads books from the file specified by the given path. */
NSArray&amp;lt;GTMBook *&amp;gt; *_Nullable GTMLoadBooksFromFile(NSString *_Nonnull path);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// AVOID:

NSArray&amp;lt;GTMBook *&amp;gt; *__nullable GTMLoadBooksFromTitle(NSString *__nonnull path);
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Be careful assuming that a pointer is not null based on a non-null qualifier&lt;br&gt;
because the compiler may not guarantee that the pointer is not null.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果标识符标注某个指针不为空，也不要轻信，因为编译器可不能保证该指针不为空。&lt;/p&gt;
&lt;h3 id="boolboolpitfalls"&gt;BOOL陷阱（BOOL Pitfalls）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Be careful when converting general integral values to &lt;code&gt;BOOL&lt;/code&gt;. Avoid comparing&lt;br&gt;
directly with &lt;code&gt;YES&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;将整型数值转换为&lt;code&gt;BOOL&lt;/code&gt;要小心。避免直接和 &lt;code&gt;YES&lt;/code&gt;直接进行比较。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;BOOL&lt;/code&gt; in OS X and in 32-bit iOS builds is defined as a signed &lt;code&gt;char&lt;/code&gt;, so it may&lt;br&gt;
have values other than &lt;code&gt;YES&lt;/code&gt; (&lt;code&gt;1&lt;/code&gt;) and &lt;code&gt;NO&lt;/code&gt; (&lt;code&gt;0&lt;/code&gt;). Do not cast or convert&lt;br&gt;
general integral values directly to &lt;code&gt;BOOL&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在OSX和32位iOS系统版本中，&lt;code&gt;BOOL&lt;/code&gt; 类型被定义为有符号&lt;code&gt;char&lt;/code&gt;类型，所以，它可以是除了&lt;code&gt;YES&lt;/code&gt; (&lt;code&gt;1&lt;/code&gt;) and &lt;code&gt;NO&lt;/code&gt; (&lt;code&gt;0&lt;/code&gt;)之外的其他值。切勿将整数值直接赋值或强制类型转换后赋值给&lt;code&gt;BOOL&lt;/code&gt;值。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Common mistakes include casting or converting an array's size, a pointer value,&lt;br&gt;
or the result of a bitwise logic operation to a &lt;code&gt;BOOL&lt;/code&gt; that could, depending on&lt;br&gt;
the value of the last byte of the integer value, still result in a &lt;code&gt;NO&lt;/code&gt; value.&lt;br&gt;
When converting a general integral value to a &lt;code&gt;BOOL&lt;/code&gt;, use ternary operators to&lt;br&gt;
return a &lt;code&gt;YES&lt;/code&gt; or &lt;code&gt;NO&lt;/code&gt; value.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;常见错误包括将强转或转换数组大小、指针值或者通过逻辑位运算结果赋值给&lt;code&gt;BOOL&lt;/code&gt;变量，根据整数最后一个字节的值，结果仍然有可能会产生&lt;code&gt;NO&lt;/code&gt;值。在将一个整数转换为&lt;code&gt;BOOL&lt;/code&gt;值时，需要使用三元运算符来保证返回值是&lt;code&gt;YES&lt;/code&gt; 或 &lt;code&gt;NO&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You can safely interchange and convert &lt;code&gt;BOOL&lt;/code&gt;, &lt;code&gt;_Bool&lt;/code&gt; and &lt;code&gt;bool&lt;/code&gt; (see C++ Std&lt;br&gt;
4.7.4, 4.12 and C99 Std 6.3.1.2). Use &lt;code&gt;BOOL&lt;/code&gt; in Objective-C method signatures.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Objective-C方法签名中使用&lt;code&gt;BOOL&lt;/code&gt;，你可以安全的来转换 &lt;code&gt;BOOL&lt;/code&gt;, &lt;code&gt;_Bool&lt;/code&gt; and &lt;code&gt;bool&lt;/code&gt;值（参考see C++ Std 4.7.4, 4.12 and C99 Std 6.3.1.2）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Using logical operators (&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;||&lt;/code&gt; and &lt;code&gt;!&lt;/code&gt;) with &lt;code&gt;BOOL&lt;/code&gt; is also valid and will&lt;br&gt;
return values that can be safely converted to &lt;code&gt;BOOL&lt;/code&gt; without the need for a&lt;br&gt;
ternary operator.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也可以使用逻辑运算符(&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;、 &lt;code&gt;||&lt;/code&gt;、 &lt;code&gt;!&lt;/code&gt;)来获取 &lt;code&gt;BOOL&lt;/code&gt; 值，这种方法也可以不使用三元运算符来安全转换 &lt;code&gt;BOOL&lt;/code&gt; 值。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// AVOID:

- (BOOL)isBold {
  return [self fontTraits] &amp;amp; NSFontBoldTrait;  // AVOID.
}
- (BOOL)isValid {
  return [self stringValue];  // AVOID.
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

- (BOOL)isBold {
  return ([self fontTraits] &amp;amp; NSFontBoldTrait) ? YES : NO;
}
- (BOOL)isValid {
  return [self stringValue] != nil;
}
- (BOOL)isEnabled {
  return [self isValid] &amp;amp;&amp;amp; [self isBold];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Also, don't directly compare &lt;code&gt;BOOL&lt;/code&gt; variables directly with &lt;code&gt;YES&lt;/code&gt;. Not only is&lt;br&gt;
it harder to read for those well-versed in C, but the first point above&lt;br&gt;
demonstrates that return values may not always be what you expect.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;同样，不要将 &lt;code&gt;BOOL&lt;/code&gt; 值和&lt;code&gt;YES&lt;/code&gt;进行直接比较。这样做不仅仅是因为对于精通C语言的人可能难以理解，而是返回值可能并不总是和预期一致（容易引起逻辑错误），这才是真正原因。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// AVOID:

BOOL great = [foo isGreat];
if (great == YES) {  // AVOID.
  // ...be great!
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

BOOL great = [foo isGreat];
if (great) {         // GOOD.
  // ...be great!
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="interfaceinterfaceswithoutinstancevariables"&gt;无实例变量的Interface（Interfaces Without Instance Variables）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Omit the empty set of braces on interfaces that do not declare any instance&lt;br&gt;
variables.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;若interface不声明任何实例变量，省略空的大括号。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

@interface MyClass : NSObject
// Does a lot of stuff.
- (void)fooBarBam;
@end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// AVOID:

@interface MyClass : NSObject {
}
// Does a lot of stuff.
- (void)fooBarBam;
@end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="cocoacocoapatterns"&gt;Cocoa模式（Cocoa Patterns）&lt;/h2&gt;
&lt;h3 id="delegatedelegatepattern"&gt;Delegate模式（Delegate Pattern）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Delegates, target objects, and block pointers should not be retained when doing&lt;br&gt;
so would create a retain cycle.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Delegate，target对象，block指针不可使用retain，不然会产生循环引用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;To avoid causing a retain cycle, a delegate or target pointer should be released&lt;br&gt;
as soon as it is clear there will no longer be a need to message the object.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为避免引起循环引用，delegate或响应对象指针需要被及时清理，以便后续发送的消息不再被响应。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If there is no clear time at which the delegate or target pointer is no longer&lt;br&gt;
needed, the pointer should only be retained weakly.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;若delegate或响应对象指针在后续不被需要时，没有一个清晰的时间点，那么该delegate或响应对象指针应该被设置为弱引用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Block pointers cannot be retained weakly. To avoid causing retain cycles in the&lt;br&gt;
client code, block pointers should be used for callbacks only where they can be&lt;br&gt;
explicitly released after they have been called or once they are no longer&lt;br&gt;
needed. Otherwise, callbacks should be done via weak delegate or target&lt;br&gt;
pointers.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Block指针不可使用弱引用。为避免在客户端代码中出现循环引用，block指针只有在被调用一次或者他们不被需要时会被明确的清理，才可以用于回调方法。否则，回调方法应该通过弱引用的delegate或者响应对象指针来实现。&lt;/p&gt;
&lt;h2 id="objectivec"&gt;Objective-C++&lt;/h2&gt;
&lt;h3 id="stylematchesthelanguage"&gt;代码风格与所用语言保持一致（Style Matches the Language）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Within an Objective-C++ source file, follow the style for the language of the&lt;br&gt;
function or method you're implementing. In order to minimize clashes between the&lt;br&gt;
differing naming styles when mixing Cocoa/Objective-C and C++, follow the style&lt;br&gt;
of the method being implemented.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于Objective-C++源码文件，遵守函数或方法实现语言的编码规范。为了将Cocoa/Objective-C、C++不同语言混合使用导致的命名风格冲突最小化，遵守源码中方法实现使用的编码风格。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;For code in an &lt;code&gt;@implementation&lt;/code&gt; block, use the Objective-C naming rules. For&lt;br&gt;
code in a method of a C++ class, use the C++ naming rules.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于 &lt;code&gt;@implementation&lt;/code&gt;代码，使用Objective-C命名规范。对于C++类中方法代码，使用C++命名规范。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;For code in an Objective-C++ file outside of a class implementation, be&lt;br&gt;
consistent within the file.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于Objective-C++文件类实现部分之外的代码，与该文件代码风格保持一致。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec++"&gt;// GOOD:

// file: cross_platform_header.h

class CrossPlatformAPI {
 public:
  ...
  int DoSomethingPlatformSpecific();  // impl on each platform
 private:
  int an_instance_var_;
};

// file: mac_implementation.mm
#include &amp;quot;cross_platform_header.h&amp;quot;

/** A typical Objective-C class, using Objective-C naming. */
@interface MyDelegate : NSObject {
 @private
  int _instanceVar;
  CrossPlatformAPI* _backEndObject;
}

- (void)respondToSomething:(id)something;

@end

@implementation MyDelegate

- (void)respondToSomething:(id)something {
  // bridge from Cocoa through our C++ backend
  _instanceVar = _backEndObject-&amp;gt;DoSomethingPlatformSpecific();
  NSString* tempString = [NSString stringWithFormat:@&amp;quot;%d&amp;quot;, _instanceVar];
  NSLog(@&amp;quot;%@&amp;quot;, tempString);
}

@end

/** The platform-specific implementation of the C++ class, using C++ naming. */
int CrossPlatformAPI::DoSomethingPlatformSpecific() {
  NSString* temp_string = [NSString stringWithFormat:@&amp;quot;%d&amp;quot;, an_instance_var_];
  NSLog(@&amp;quot;%@&amp;quot;, temp_string);
  return [temp_string intValue];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Projects may opt to use an 80 column line length limit for consistency with&lt;br&gt;
Google's C++ style guide.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;工程中可能选择使用80个字符列宽限制，以便和Google的C++代码规范保持一致。&lt;/p&gt;
&lt;h2 id="spacingandformatting"&gt;空间布局和格式（Spacing and Formatting）&lt;/h2&gt;
&lt;h3 id="vsspacesvstabs"&gt;空格 vs 制表符（Spaces vs. Tabs）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Use only spaces, and indent 2 spaces at a time. We use spaces for indentation.&lt;br&gt;
Do not use tabs in your code.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;只使用空格，缩进量为2个空格宽度。缩进时不使用制表符，只用空格。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You should set your editor to emit spaces when you hit the tab key, and to trim&lt;br&gt;
trailing spaces on lines.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;设置编辑器使用空格自动替换制表符，并消除行位空格。&lt;/p&gt;
&lt;h3 id="linelength"&gt;行宽（Line Length）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;The maximum line length for Objective-C files is 100 columns.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;You can make violations easier to spot by enabling &lt;em&gt;Preferences &amp;gt; Text Editing &amp;gt;&lt;br&gt;
Page guide at column: 100&lt;/em&gt; in Xcode.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Objective-C最大行宽为100列（100字符宽度）。在xCode中，通过设置Preferences &amp;gt; Text Editing &amp;gt; Page guide at column:为100，可以轻松检查超宽地方。&lt;/p&gt;
&lt;h3 id="methoddeclarationsanddefinitions"&gt;方法声明与定义（Method Declarations and Definitions）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;One space should be used between the &lt;code&gt;-&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt; and the return type, and no&lt;br&gt;
spacing in the parameter list except between parameters.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;-&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt; 后与返回值之间须有一个空格，参数名与参数类型间无空格，参数列表不同参数间有一个空格；&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Methods should look like this:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;方法示例如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

- (void)doSomethingWithString:(NSString *)theString {
  ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;The spacing before the asterisk is optional. When adding new code, be consistent&lt;br&gt;
with the surrounding file's style.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;星号前可以有一个空格。新添加的代码要与文件代码风格保持一致。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If a method declaration does not fit on a single line, put each parameter on its&lt;br&gt;
own line. All lines except the first should be indented at least four spaces.&lt;br&gt;
Colons before parameters should be aligned on all lines. If the colon before the&lt;br&gt;
parameter on the first line of a method declaration is positioned such that&lt;br&gt;
colon alignment would cause indentation on a subsequent line to be less than&lt;br&gt;
four spaces, then colon alignment is only required for all lines except the&lt;br&gt;
first.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果一个方法声明一行放不下，需要将不同参数各占一行。除首行外，其余所有行都要至少缩进4个空格。不同参数前的冒号要对齐。如果方法声明第一行中参数前的冒号所在位置，对齐所有冒号后，后面的参数前面缩进的空格数少于4个，这种情况只需要将函数声明中第一行之外的其他行冒号对齐即可。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

- (void)doSomethingWithFoo:(GTMFoo *)theFoo
                      rect:(NSRect)theRect
                  interval:(float)theInterval {
  ...
}

- (void)shortKeyword:(GTMFoo *)theFoo
            longerKeyword:(NSRect)theRect
    someEvenLongerKeyword:(float)theInterval
                    error:(NSError **)theError {
  ...
}

- (id&amp;lt;UIAdaptivePresentationControllerDelegate&amp;gt;)
    adaptivePresentationControllerDelegateForViewController:(UIViewController *)viewController;

- (void)presentWithAdaptivePresentationControllerDelegate:
    (id&amp;lt;UIAdaptivePresentationControllerDelegate&amp;gt;)delegate;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="functiondeclarationsanddefinitions"&gt;方法声明与定义（Function Declarations and Definitions）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Prefer putting the return type on the same line as the function name and append&lt;br&gt;
all parameters on the same line if they will fit. Wrap parameter lists which do&lt;br&gt;
not fit on a single line as you would wrap arguments in a &lt;a href="#Function_Calls"&gt;function&lt;br&gt;
call&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;将方法返回类型和方法名放于同一行，后面跟其他参数，如果一行能放下，则参数放于同一行。若一行放不下，就像函数调用一样，来包装参数列表。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

NSString *GTMVersionString(int majorVersion, minorVersion) {
  ...
}

void GTMSerializeDictionaryToFileOnDispatchQueue(
    NSDictionary&amp;lt;NSString *, NSString *&amp;gt; *dictionary,
    NSString *filename,
    dispatch_queue_t queue) {
  ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Function declarations and definitions should also satisfy the following&lt;br&gt;
conditions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The opening parenthesis must always be on the same line as the function&lt;br&gt;
name.&lt;/li&gt;
&lt;li&gt;If you cannot fit the return type and the function name on a single line,&lt;br&gt;
break between them and do not indent the function name.&lt;/li&gt;
&lt;li&gt;There should never be a space before the opening parenthesis.&lt;/li&gt;
&lt;li&gt;There should never be a space between function parentheses and parameters.&lt;/li&gt;
&lt;li&gt;The open curly brace is always on the end of the last line of the function&lt;br&gt;
declaration, not the start of the next line.&lt;/li&gt;
&lt;li&gt;The close curly brace is either on the last line by itself or on the same&lt;br&gt;
line as the open curly brace.&lt;/li&gt;
&lt;li&gt;There should be a space between the close parenthesis and the open curly&lt;br&gt;
brace.&lt;/li&gt;
&lt;li&gt;All parameters should be aligned if possible.&lt;/li&gt;
&lt;li&gt;Function scopes should be indented 2 spaces.&lt;/li&gt;
&lt;li&gt;Wrapped parameters should have a 4 space indent.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;函数声明和定义也需要满足以下条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数名后的左括号必须和函数名在同一行；&lt;/li&gt;
&lt;li&gt;若返回值类型和函数名不能放在同一行，在他们之间换行，并且不缩进函数名；&lt;/li&gt;
&lt;li&gt;函数名后的左括号前无空格；&lt;/li&gt;
&lt;li&gt;函数括号和参数间无空格；&lt;/li&gt;
&lt;li&gt;函数左大括号在函数声明后，不可另起一行；&lt;/li&gt;
&lt;li&gt;函数右大括号在函数最后独占一行，或和左大括号同一行；&lt;/li&gt;
&lt;li&gt;函数左大括号和函数参数右括号间，有一个空格；&lt;/li&gt;
&lt;li&gt;所有参数尽量对齐（冒号对齐）；&lt;/li&gt;
&lt;li&gt;函数作用域缩进2个空格；&lt;/li&gt;
&lt;li&gt;封装参数缩进4个空格；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="conditionals"&gt;条件判断（Conditionals）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Include a space after &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, and &lt;code&gt;switch&lt;/code&gt;, and around comparison&lt;br&gt;
operators.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;if&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;,  &lt;code&gt;switch&lt;/code&gt;后有一个空格，比较运算符两边有空格。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

for (int i = 0; i &amp;lt; 5; ++i) {
}

while (test) {};
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Braces may be omitted when a loop body or conditional statement fits on a single&lt;br&gt;
line.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;若循环体或条件语句可放置一行中时，可以省略大括号；&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

if (hasSillyName) LaughOutLoud();

for (int i = 0; i &amp;lt; 10; i++) {
  BlowTheHorn();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// AVOID:

if (hasSillyName)
  LaughOutLoud();               // AVOID.

for (int i = 0; i &amp;lt; 10; i++)
  BlowTheHorn();                // AVOID.
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;If an &lt;code&gt;if&lt;/code&gt; clause has an &lt;code&gt;else&lt;/code&gt; clause, both clauses should use braces.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;若 &lt;code&gt;if&lt;/code&gt; 语句后有 &lt;code&gt;else&lt;/code&gt; 语句，两部分都需要使用大括号。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

if (hasBaz) {
  foo();
} else {  // The else goes on the same line as the closing brace.
  bar();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// AVOID:

if (hasBaz) foo();
else bar();        // AVOID.

if (hasBaz) {
  foo();
} else bar();      // AVOID.
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Intentional fall-through to the next case should be documented with a comment&lt;br&gt;
unless the case has no intervening code before the next case.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;除非两个case语句之间没有其他代码，有意添加的case连续执行情况，需要增加注释说明。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

switch (i) {
  case 1:
    ...
    break;
  case 2:
    j++;
    // Falls through.
  case 3: {
    int k;
    ...
    break;
  }
  case 4:
  case 5:
  case 6: break;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="expressions"&gt;表达式（Expressions）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Use a space around binary operators and assignments. Omit a space for a unary&lt;br&gt;
operator. Do not add spaces inside parentheses.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;二进制运算符、赋值运算符左右两边都需要添加空格。一元运算符可以省略空格。圆括号（左括号右边、右括号左边）不用空格。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

x = 0;
v = w * x + y / z;
v = -y * (x + z);
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Factors in an expression may omit spaces.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;某些表达式运算符左右可能省略空格。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

v = w*x + y/z;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="methodinvocations"&gt;方法调动（Method Invocations）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Method invocations should be formatted much like method declarations.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;方法调用的格式应与方法声明一致。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;When there's a choice of formatting styles, follow the convention already used&lt;br&gt;
in a given source file. Invocations should have all arguments on one line:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;若源码中有现有的编码规范使用惯例，请保持一致继续使用。方法调用的所有参数都放在一行。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

[myObject doFooWith:arg1 name:arg2 error:arg3];
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;or have one argument per line, with colons aligned:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;或每个参数放在单独一行，冒号对齐。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

[myObject doFooWith:arg1
               name:arg2
              error:arg3];
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Don't use any of these styles:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不要使用下列编码风格：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// AVOID:

[myObject doFooWith:arg1 name:arg2  // some lines with &amp;gt;1 arg
              error:arg3];

[myObject doFooWith:arg1
               name:arg2 error:arg3];

[myObject doFooWith:arg1
          name:arg2  // aligning keywords instead of colons
          error:arg3];
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;As with declarations and definitions, when the first keyword is shorter than the&lt;br&gt;
others, indent the later lines by at least four spaces, maintaining colon&lt;br&gt;
alignment:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;与声明和定义一样，当第一个关键字比其他字段短，将后面的参数缩进至少4个空格，并将冒号对齐。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

[myObj short:arg1
          longKeyword:arg2
    evenLongerKeyword:arg3
                error:arg4];
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Invocations containing multiple inlined blocks may have their parameter names&lt;br&gt;
left-aligned at a four space indent.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;方法调用包含多个内嵌block时，将这些参数缩进4个空格，并左对齐。&lt;/p&gt;
&lt;h3 id="functioncalls"&gt;函数调用（Function Calls）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Function calls should include as many parameters as fit on each line, except&lt;br&gt;
where shorter lines are needed for clarity or documentation of the parameters.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;函数调用要尽可能多的将参数填满每一行，如果某些参数需要说明参数含义或添加文档说明，将这行参数不填满整行。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Continuation lines for function parameters may be indented to align with the&lt;br&gt;
opening parenthesis, or may have a four-space indent.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;换行后的参数需要与函数的左括号对齐，或者使用4个空格进行缩进。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

CFArrayRef array = CFArrayCreate(kCFAllocatorDefault, objects, numberOfObjects,
                                 &amp;amp;kCFTypeArrayCallBacks);

NSString *string = NSLocalizedStringWithDefaultValue(@&amp;quot;FEET&amp;quot;, @&amp;quot;DistanceTable&amp;quot;,
    resourceBundle,  @&amp;quot;%@ feet&amp;quot;, @&amp;quot;Distance for multiple feet&amp;quot;);

UpdateTally(scores[x] * y + bases[x],  // Score heuristic.
            x, y, z);

TransformImage(image,
               x1, x2, x3,
               y1, y2, y3,
               z1, z2, z3);
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Use local variables with descriptive names to shorten function calls and reduce&lt;br&gt;
nesting of calls.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用具有描述性名称的局部变量来缩短函数调用和减少内嵌调用。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

double scoreHeuristic = scores[x] * y + bases[x];
UpdateTally(scoreHeuristic, x, y, z);

// AVOID
UpdateTally((scores[x] * y + bases[x]), x, y, z);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="exceptions"&gt;异常（Exceptions）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Format exceptions with &lt;code&gt;@catch&lt;/code&gt; and &lt;code&gt;@finally&lt;/code&gt; labels on the same line as the&lt;br&gt;
preceding &lt;code&gt;}&lt;/code&gt;. Add a space between the &lt;code&gt;@&lt;/code&gt; label and the opening brace (&lt;code&gt;{&lt;/code&gt;), as&lt;br&gt;
well as between the &lt;code&gt;@catch&lt;/code&gt; and the caught object declaration. If you must use&lt;br&gt;
Objective-C exceptions, format them as follows. However, see &lt;a href="#Avoid_Throwing_Exceptions"&gt;Avoid Throwing&lt;br&gt;
Exceptions&lt;/a&gt; for reasons why you should not be using&lt;br&gt;
exceptions.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用 &lt;code&gt;@catch&lt;/code&gt; 和 &lt;code&gt;@finally&lt;/code&gt; 标签要与左大括号在同一行。标签与左大括号之间添加一个空格， &lt;code&gt;@catch&lt;/code&gt; 与异常对象声明之间也添加一个空格。如果必须使用Objective-C异常类型，请按下面方式进行格式化。但是，请参考[避免抛异常（Avoid Throwing Exceptions）](#避免抛异常（Avoid Throwing Exceptions）) 以便了解避免抛出异常的原因。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objectivec"&gt;// GOOD:

@try {
  foo();
} @catch (NSException *ex) {
  bar(ex);
} @finally {
  baz();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="functionlength"&gt;函数长度（Function Length）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Prefer small and focused functions.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;推荐小而功能专注的函数。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Long functions and methods are occasionally appropriate, so no hard limit is&lt;br&gt;
placed on function length. If a function exceeds about 40 lines, think about&lt;br&gt;
whether it can be broken up without harming the structure of the program.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;长方法或者函数某些情况下也是可以的，所以关于函数长度没有固定的限制。如果一个函数长度超过了40个字符，请考虑如何在不破坏代码结构的基础上，将它拆分。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Even if your long function works perfectly now, someone modifying it in a few&lt;br&gt;
months may add new behavior. This could result in bugs that are hard to find.&lt;br&gt;
Keeping your functions short and simple makes it easier for other people to read&lt;br&gt;
and modify your code.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;即便你现在的长方法可以完美运行，可能几个月后的某些修改会给他添加新特性。这也导致出现问题难以发现。保持函数简练可以使代码易读，利于修改。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;When updating legacy code, consider also breaking long functions into smaller&lt;br&gt;
and more manageable pieces.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当更新遗留代码时，也需要考虑将长函数分解成更小更利于管理维护的部分。&lt;/p&gt;
&lt;h3 id="verticalwhitespace"&gt;垂直空白（Vertical Whitespace）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Use vertical whitespace sparingly.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;谨慎使用垂直空白。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;To allow more code to be easily viewed on a screen, avoid putting blank lines&lt;br&gt;
just inside the braces of functions.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了让更多代码能够一屏展示，在函数大括号内，避免使用空行。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Limit blank lines to one or two between functions and between logical groups of&lt;br&gt;
code.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不同函数间或不同代码逻辑组之间，空行限制在1-2行。&lt;/p&gt;
&lt;h2 id="objectivecobjectivecstyleexceptions"&gt;Objective-C风格异常（Objective-C Style Exceptions）&lt;/h2&gt;
&lt;h3 id="indicatingstyleexceptions"&gt;指明风格异常（Indicating style exceptions）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Lines of code that are not expected to adhere to these style recommendations&lt;br&gt;
require &lt;code&gt;// NOLINT&lt;/code&gt; at the end of the line or &lt;code&gt;// NOLINTNEXTLINE&lt;/code&gt; at the end of&lt;br&gt;
the previous line. Sometimes it is required that parts of Objective-C code must&lt;br&gt;
ignore these style recommendations (for example code may be machine generated or&lt;br&gt;
code constructs are such that its not possible to style correctly).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;预计不符合这些规范的代码行，需要在行尾添加&lt;code&gt;// NOLINT&lt;/code&gt;或者在前一行添加 &lt;code&gt;// NOLINTNEXTLINE&lt;/code&gt; 标识。有时一部分代码需要忽略某些推荐的编码风格规范（例如某些机器生成的代码或者某些结构是不可能设置为正式样式的代码）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A &lt;code&gt;// NOLINT&lt;/code&gt; comment on that line or &lt;code&gt;// NOLINTNEXTLINE&lt;/code&gt; on the previous line&lt;br&gt;
can be used to indicate to the reader that code is intentionally ignoring style&lt;br&gt;
guidelines. In addition these annotations can also be picked up by automated&lt;br&gt;
tools such as linters and handle code correctly. Note that there is a single&lt;br&gt;
space between &lt;code&gt;//&lt;/code&gt; and &lt;code&gt;NOLINT*&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一行中的 &lt;code&gt;// NOLINT&lt;/code&gt; 标注和前一行的 &lt;code&gt;// NOLINTNEXTLINE&lt;/code&gt; 标注可以被用来告诉读者，某些代码是故意忽略遵守使用编码规范的，此外，这些标注也可以让一些自动化工具（如linters）正确处理代码。&lt;/p&gt;
&lt;p&gt;注意 &lt;code&gt;//&lt;/code&gt; 和 &lt;code&gt;NOLINT*&lt;/code&gt;之间有一个空格。&lt;/p&gt;
&lt;/div&gt;</content:encoded></item><item><title>iOS端查看PDF文档实现方案</title><description>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;文 · Mark&lt;/p&gt;
&lt;p&gt;在不同端查看一些文档时，往往会展现出千奇百怪的格式，呈现给用户的也是不同的展示效果。为了保持原始文稿的格式，保证展现效果的统一，PDF文稿可以很好解决格式在不同端文稿展现格式差异，保持原始文稿的展现效果。&lt;/p&gt;
&lt;p&gt;对于移动端的开发工作中，查看PDF也是常见的需求，本文针对iOS端查看PDF文档给出实现方案，包括通过网络端读取和本地读取两种方式查看PDF文档。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;读取方式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网络读取&lt;/li&gt;
&lt;li&gt;本地读取&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;测试文稿样本&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://i.loli.net/2018/03/21/5ab1fe2b4e3e5.png"&gt;Accessory Design Guidelines for Apple Devices&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;作者：Apple Inc.&lt;/li&gt;
&lt;li&gt;分辨率：612 * 792 px&lt;/li&gt;
&lt;li&gt;大小： 22.1 MB&lt;/li&gt;
&lt;li&gt;页数： 177&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=""&gt;实现方式&lt;/h3&gt;
&lt;p&gt;经过调研，目前针对网络读取，可以使用UIWebView进行PDF文档加载及展示；针对本地PDF文档读取，可以通过QLPreviewController进行读取并展示。&lt;/p&gt;
&lt;h4 id="uiwebview"&gt;UIWebView展现&lt;/h4&gt;
&lt;p&gt;本方法用于在线展示云端PDF文档;&lt;/p&gt;
&lt;p&gt;关键代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objective-c"&gt;self.webViewPDFViewer = [[UIWebView alloc] initWithFrame:&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description><link>http://localhost:2368/2018/03/21/iosduan-cha-kan-pdfwen-dang-shi-xian-fang-an/</link><guid isPermaLink="false">5ab2104efd03b3d90a96fee1</guid><dc:creator>Mark Chen</dc:creator><pubDate>Wed, 21 Mar 2018 07:58:33 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;文 · Mark&lt;/p&gt;
&lt;p&gt;在不同端查看一些文档时，往往会展现出千奇百怪的格式，呈现给用户的也是不同的展示效果。为了保持原始文稿的格式，保证展现效果的统一，PDF文稿可以很好解决格式在不同端文稿展现格式差异，保持原始文稿的展现效果。&lt;/p&gt;
&lt;p&gt;对于移动端的开发工作中，查看PDF也是常见的需求，本文针对iOS端查看PDF文档给出实现方案，包括通过网络端读取和本地读取两种方式查看PDF文档。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;读取方式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网络读取&lt;/li&gt;
&lt;li&gt;本地读取&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;测试文稿样本&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://i.loli.net/2018/03/21/5ab1fe2b4e3e5.png"&gt;Accessory Design Guidelines for Apple Devices&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;作者：Apple Inc.&lt;/li&gt;
&lt;li&gt;分辨率：612 * 792 px&lt;/li&gt;
&lt;li&gt;大小： 22.1 MB&lt;/li&gt;
&lt;li&gt;页数： 177&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=""&gt;实现方式&lt;/h3&gt;
&lt;p&gt;经过调研，目前针对网络读取，可以使用UIWebView进行PDF文档加载及展示；针对本地PDF文档读取，可以通过QLPreviewController进行读取并展示。&lt;/p&gt;
&lt;h4 id="uiwebview"&gt;UIWebView展现&lt;/h4&gt;
&lt;p&gt;本方法用于在线展示云端PDF文档;&lt;/p&gt;
&lt;p&gt;关键代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objective-c"&gt;self.webViewPDFViewer = [[UIWebView alloc] initWithFrame:CGRectMake(0, NAVIGATION_BAR_AND_STATUS_BAR_HEIGHT, SCREEN_WIDTH, SCREEN_HEIGHT-NAVIGATION_BAR_AND_STATUS_BAR_HEIGHT)];
self.webViewPDFViewer.delegate = self;
[self.view addSubview:self.webViewPDFViewer];

// Load the PDF document online
NSURLRequest *urlRequest = [[NSURLRequest alloc] initWithURL:[NSURL URLWithString:PDF_FILE_URL]];
[self.webViewPDFViewer loadRequest:urlRequest];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;展现截图：&lt;/p&gt;
&lt;img src="https://i.loli.net/2018/03/21/5ab1fe2b4e3e5.png" style="zoom:0.5"&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过WebView加载网络端过程中会有等待情况，建议增加Loading提示&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="qlpreviewcontroller"&gt;QLPreviewController展现&lt;/h4&gt;
&lt;p&gt;&lt;a href="https://developer.apple.com/documentation/quicklook/qlpreviewcontroller"&gt;该方式&lt;/a&gt;可查看多种文件类型，主要适用于本地文件读取展示，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;iWork documents&lt;/li&gt;
&lt;li&gt;Microsoft Office documents (Office ‘97 and newer)&lt;/li&gt;
&lt;li&gt;Rich Text Format (RTF) documents&lt;/li&gt;
&lt;li&gt;PDF files&lt;/li&gt;
&lt;li&gt;Images&lt;/li&gt;
&lt;li&gt;Text files whose uniform type identifier (UTI) conforms to the &lt;code&gt;public.text&lt;/code&gt; type (see &lt;a href="https://developer.apple.com/library/content/documentation/Miscellaneous/Reference/UTIRef/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009257"&gt;Uniform Type Identifiers Reference&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Comma-separated value (csv) files&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;关键代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objective-c"&gt;/*!
 * @abstract Returns the item that the preview controller should preview.
 * @param panel The Preview Controller.
 * @param index The index of the item to preview.
 * @result An item conforming to the QLPreviewItem protocol.
 */
- (id &amp;lt;QLPreviewItem&amp;gt;)previewController:(QLPreviewController *)controller previewItemAtIndex:(NSInteger)index {
    NSString *pdfFilePath = [[NSBundle mainBundle] pathForResource:@&amp;quot;Accessory-Design-Guidelines&amp;quot; ofType:@&amp;quot;pdf&amp;quot;];
    return [NSURL fileURLWithPath:pdfFilePath];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在iOS11.2 系统上，查看云端PDF文档会出现如下错误：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;... : [default] Couldn't issue file extension for url: https://developer.apple.com/accessories/Accessory-Design-Guidelines.pdf #PreviewItem
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href="https://forums.developer.apple.com/thread/91835"&gt;相关链接及解决方法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;若使用该方法查看PDF文档，建议先将文件进行下载，保存到App的Document某一目录，再进行文件展示。&lt;/p&gt;
&lt;h4 id="pdfkit"&gt;PDFKit展现&lt;/h4&gt;
&lt;p&gt;该方式是iOS11.0 SDK添加，支持PDF文件读取和写入。&lt;/p&gt;
&lt;p&gt;考虑到此API版本需要的系统版本较高，本文暂不调研，后续会进行专门补充。&lt;/p&gt;
&lt;/div&gt;</content:encoded></item><item><title>Beacon初识</title><description>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;文 · Mark&lt;/p&gt;
&lt;h2 id="beacon"&gt;什么是Beacon&lt;/h2&gt;
&lt;p&gt;Beacon  ['biːk(ə)n] 这个单词的中文意思是&lt;em&gt;信号浮标、灯塔&lt;/em&gt;，此文所说的Beacon其特点如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;采用BLE技术发射信号的小设备&lt;/li&gt;
&lt;li&gt;运算能力几乎为零，但功耗很低，续航持久&lt;/li&gt;
&lt;li&gt;有效范围几十厘米到几米&lt;/li&gt;
&lt;li&gt;信号为单向发射，只能发射小数据包，例如128bit UUID&lt;/li&gt;
&lt;li&gt;一般将智能手机作为接收方&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=""&gt;主流标准&lt;/h2&gt;
&lt;p&gt;目前，在市场上Beacon类解决方案有哪些？&lt;/p&gt;
&lt;h4 id="ibeacon"&gt;&lt;a href="https://developer.apple.com/ibeacon/"&gt;iBeacon&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;iBeacon由Apple在WWDC13推出，其设计初衷也可以联想到，目前主要用来做室内定位标志物（至少需要两个iBeacon信标）&lt;/p&gt;
&lt;p&gt;原理是利用低功耗BLE蓝牙技术，不断广播自己的特有ID，广播范围是有一定的区域限制，进入该范围的手机设备可以感知此信标的存在。通过读取广播中的ID，经过加工，满足业务需求。&lt;/p&gt;
&lt;p&gt;该标准闭源，而且只兼容苹果公司的“i系列”产品；&lt;/p&gt;
&lt;h4 id="eddystone"&gt;&lt;a href="https://developers.google.com/beacons/"&gt;Eddystone&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;2015年，Google推出的开源低功耗BLE平台项目，名字来源于英国Eddystone灯塔，在iOS、Android平台上均可使用。&lt;/p&gt;
&lt;p&gt;该项目的目标在于试图创建一个鲁棒、可扩展的Beacon标准，平台应用范围比iBeacon要广；&lt;/p&gt;
&lt;p&gt;苹果的iBeacon和谷歌的&lt;a href="https://google.github.io/physical-web/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/2018/01/30/beacon/</link><guid isPermaLink="false">5a703ab1e4699cc1ae3488d0</guid><category>设计</category><category>Beacon</category><category>Ble</category><dc:creator>Mark Chen</dc:creator><pubDate>Tue, 30 Jan 2018 09:30:38 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;文 · Mark&lt;/p&gt;
&lt;h2 id="beacon"&gt;什么是Beacon&lt;/h2&gt;
&lt;p&gt;Beacon  ['biːk(ə)n] 这个单词的中文意思是&lt;em&gt;信号浮标、灯塔&lt;/em&gt;，此文所说的Beacon其特点如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;采用BLE技术发射信号的小设备&lt;/li&gt;
&lt;li&gt;运算能力几乎为零，但功耗很低，续航持久&lt;/li&gt;
&lt;li&gt;有效范围几十厘米到几米&lt;/li&gt;
&lt;li&gt;信号为单向发射，只能发射小数据包，例如128bit UUID&lt;/li&gt;
&lt;li&gt;一般将智能手机作为接收方&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=""&gt;主流标准&lt;/h2&gt;
&lt;p&gt;目前，在市场上Beacon类解决方案有哪些？&lt;/p&gt;
&lt;h4 id="ibeacon"&gt;&lt;a href="https://developer.apple.com/ibeacon/"&gt;iBeacon&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;iBeacon由Apple在WWDC13推出，其设计初衷也可以联想到，目前主要用来做室内定位标志物（至少需要两个iBeacon信标）&lt;/p&gt;
&lt;p&gt;原理是利用低功耗BLE蓝牙技术，不断广播自己的特有ID，广播范围是有一定的区域限制，进入该范围的手机设备可以感知此信标的存在。通过读取广播中的ID，经过加工，满足业务需求。&lt;/p&gt;
&lt;p&gt;该标准闭源，而且只兼容苹果公司的“i系列”产品；&lt;/p&gt;
&lt;h4 id="eddystone"&gt;&lt;a href="https://developers.google.com/beacons/"&gt;Eddystone&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;2015年，Google推出的开源低功耗BLE平台项目，名字来源于英国Eddystone灯塔，在iOS、Android平台上均可使用。&lt;/p&gt;
&lt;p&gt;该项目的目标在于试图创建一个鲁棒、可扩展的Beacon标准，平台应用范围比iBeacon要广；&lt;/p&gt;
&lt;p&gt;苹果的iBeacon和谷歌的&lt;a href="https://google.github.io/physical-web/"&gt;The Physical Web&lt;/a&gt;都只支持一种框架。而Eddystone支持通用唯一识别码（Universally Unique Identifier，UUID）、&lt;strong&gt;URL链接&lt;/strong&gt;、临时标识（Ephemeral Identifiers，EID）以及遥测数据等四种框架类型。&lt;/p&gt;
&lt;p&gt;当然，除了上述两种Beacon标准之外，还有一些开源标准，但目前还处于发展阶段，差异明显；&lt;/p&gt;
&lt;h2 id=""&gt;解决方案&lt;/h2&gt;
&lt;p&gt;目前针对上述需求，可以满足的解决方案提供商有很多，但主流方向有以下几种：&lt;/p&gt;
&lt;h4 id="sensoro"&gt;&lt;a href="https://www.sensoro.com/zh/case.html"&gt;SENSORO&lt;/a&gt;等&lt;/h4&gt;
&lt;p&gt;国内物联网解决方案提供商，初创公司，但已经为微软、Facebook提供过解决方案；&lt;/p&gt;
&lt;p&gt;该类型公司国内外有很多，确定方案后，可以再做商业调研；&lt;/p&gt;
&lt;h4 id="vendor"&gt;Vendor合作&lt;/h4&gt;
&lt;p&gt;自有或者vendor研发有自由定制优势，而且可以自定义私有协议，安全性方面有一定优势。但同时存在设计和生产成本高的问题，同时，沟通成本有可能升高。&lt;/p&gt;
&lt;h4 id=""&gt;自主研发&lt;/h4&gt;
&lt;p&gt;优势是可定制性强，对于满足需求十分灵活，但缺点是成本较高，对软硬件生产均有要求。&lt;/p&gt;
&lt;h2 id=""&gt;无线测距&lt;/h2&gt;
&lt;p&gt;通过BLE硬件，可以实现无线测距功能，该功能有一定的误差，所以，适用于对误差宽容度比较高的业务场景。&lt;/p&gt;
&lt;p&gt;基本公式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Distance =10^((abs(RSSI) - A) / (10*n)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Distance是计算距离&lt;/li&gt;
&lt;li&gt;RSSI是信号强度，BLE设备均有此信息&lt;/li&gt;
&lt;li&gt;A为发射点与接收端相隔1m时的信号强度&lt;/li&gt;
&lt;li&gt;n是环境衰减银子，通常取经验值，该经验值需要调试确定&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=""&gt;参考文献&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://developer.apple.com/ibeacon/Getting-Started-with-iBeacon.pdf"&gt;Apple - Getting Started with iBeacon&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developers.google.com/beacons/eddystone#beacon_manufacturers"&gt;Google - Eddystone&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content:encoded></item><item><title>Bluetooth Low Energy Introduction</title><description>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;文 · Mark&lt;/p&gt;
&lt;h2 id="ble"&gt;关于BLE&lt;/h2&gt;
&lt;p&gt;BLE，即Bluetooth Low Energy，也被称作Bluetooth Smart。相对于传统经典蓝牙，BLE是一个轻量级子集，在标准蓝牙协议4.0版本被引入。虽然和经典蓝牙协议有很多相似之处，但是实际上BLE和经典蓝牙的血统完全不同，BLE由Nokia进行研发，研发代号“Wibree”，而后来才被Bluetooth SIG所接受认可。&lt;/p&gt;
&lt;p&gt;目前，有很多无线通信协议供工程师和产品设计师选择，但是能够轻松与众多移动平台（包括iOS、Android、Windows Phone等）连接并相互通信，才是BLE这么有趣的真正原因。尤其是你不用大费周折，申请各种认证，使你的产品支持苹果设备。&lt;/p&gt;
&lt;p&gt;以下说明文档会快速为大家提供关于BLE的速览，例如低功耗蓝牙通信数据结构，蓝牙设备如何广播当前连接状态，以供连接并开始数据通信。&lt;/p&gt;
&lt;h2 id="ble"&gt;BLE平台支持&lt;/h2&gt;
&lt;p&gt;以下主流平台支持Bluetooth 4.0以及BLE：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;iOS 5+ （iOS7.0以上版本是首选版本）&lt;/li&gt;
&lt;li&gt;Android 4.3+ （相对来说Android 4.4会更稳定，&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</description><link>http://localhost:2368/2017/04/06/bluetooth-low-energy-introduction/</link><guid isPermaLink="false">5a702c40f2c769befd9f2f32</guid><category>Ble</category><dc:creator>Mark Chen</dc:creator><pubDate>Thu, 06 Apr 2017 13:03:57 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;文 · Mark&lt;/p&gt;
&lt;h2 id="ble"&gt;关于BLE&lt;/h2&gt;
&lt;p&gt;BLE，即Bluetooth Low Energy，也被称作Bluetooth Smart。相对于传统经典蓝牙，BLE是一个轻量级子集，在标准蓝牙协议4.0版本被引入。虽然和经典蓝牙协议有很多相似之处，但是实际上BLE和经典蓝牙的血统完全不同，BLE由Nokia进行研发，研发代号“Wibree”，而后来才被Bluetooth SIG所接受认可。&lt;/p&gt;
&lt;p&gt;目前，有很多无线通信协议供工程师和产品设计师选择，但是能够轻松与众多移动平台（包括iOS、Android、Windows Phone等）连接并相互通信，才是BLE这么有趣的真正原因。尤其是你不用大费周折，申请各种认证，使你的产品支持苹果设备。&lt;/p&gt;
&lt;p&gt;以下说明文档会快速为大家提供关于BLE的速览，例如低功耗蓝牙通信数据结构，蓝牙设备如何广播当前连接状态，以供连接并开始数据通信。&lt;/p&gt;
&lt;h2 id="ble"&gt;BLE平台支持&lt;/h2&gt;
&lt;p&gt;以下主流平台支持Bluetooth 4.0以及BLE：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;iOS 5+ （iOS7.0以上版本是首选版本）&lt;/li&gt;
&lt;li&gt;Android 4.3+ （相对来说Android 4.4会更稳定，所以首选4.4）&lt;/li&gt;
&lt;li&gt;Apple OS X 10.6+&lt;/li&gt;
&lt;li&gt;Windows 8 (&lt;em&gt;XP, Vista, Windows 7只支持蓝牙2.1协议，注意！&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;GNU / Linux Vanilla BlueZ 4.93+&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="gap"&gt;GAP&lt;/h2&gt;
&lt;p&gt;这不是你经常买的那个衣服牌子。&lt;/p&gt;
&lt;p&gt;GAP是Generic Access Profile协议，它用来控制BLE设备广播和连接。GAP让你的设备被外界可见，也就是可以被搜索到，也决定连接后的两个设备如何进行交互，同时也定义了设备的角色。例如，iBeacon设备只进行信息广播，是不能进行连接的，而野兽智能设备可以为外界所知，可以被手机平台连接。&lt;/p&gt;
&lt;h3 id=""&gt;设备角色&lt;/h3&gt;
&lt;p&gt;GAP定义了很多种设备角色，关键两个是Central和Peripheral&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Central&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;中心设备，通常是移动设备，包括手机、平板等，中心设备可以连接附属设备，内存及处理能力也比附属设备强大的多。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Peripheral&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从属设备，一般常见的都体积较小，低功耗，自由比较有限（内存，处理能力等），这个角色的设备可以被其他一些处理能力更强大的设备所连接。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=""&gt;广播与扫描数据&lt;/h2&gt;
&lt;p&gt;通过GAP可以使用两种方式将广播数据广播出来，一种是广播数据&lt;em&gt;Advertising Data Payload&lt;/em&gt;，另一种是扫描应答数据&lt;em&gt;Scan Response Payload&lt;/em&gt;；&lt;/p&gt;
&lt;p&gt;两种方式最大可携带数据量为31字节，但是广播数据是必选的，因为无论如何，你必须让外界知道你的设备的存在。扫描应答数据是可选的，这部分应答数据一般用于需要在广播、扫描阶段进行简短的数据通信，例如，中心设备需要从属设备应答一部分设备信息，例如设备名、ID、验证码等信息。&lt;/p&gt;
&lt;h2 id=""&gt;广播流程&lt;/h2&gt;
&lt;p&gt;下面图片可以很好的说明设备广播的流程，以及广播中的两种Payload，即&lt;em&gt;Advertising Data Payload&lt;/em&gt;和&lt;em&gt;Scan Response Payload&lt;/em&gt;是如何工作的。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://pu4d7sa3m.bkt.clouddn.com/2017040660712microcontrollers_Advertising2.png" alt="2017040660712microcontrollers_Advertising2.png"&gt;&lt;/p&gt;
&lt;p&gt;广播数据可以设置发送间隔，即ADVERTISING INTERVAL，间隔越长越省电，越短被发现的越慢。&lt;/p&gt;
&lt;p&gt;如果扫描设备需要Scan Response Payload，那该设备可以请求SCAN RESPONSE Data，即发送Scan Response Request，从属设备会将Scan Response Payload数据回复给监听设备。&lt;/p&gt;
&lt;h2 id="ble"&gt;BLE广播拓扑模型&lt;/h2&gt;
&lt;p&gt;一旦从属设备发起广播，并允许连接时，从属设备与中心设备会建立连接，广播拓扑模型如下：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://pu4d7sa3m.bkt.clouddn.com/201704066897microcontrollers_BroadcastTopology.png" alt="201704066897microcontrollers_BroadcastTopology.png"&gt;&lt;/p&gt;
&lt;p&gt;这里的广播是BLE中的一对多数据传输，Apple的iBeacon原理与此类似。一旦Peripheral和Central设备建立连接，广播数据就会停止。&lt;/p&gt;
&lt;p&gt;注意，此时GATT开始要登场了。&lt;/p&gt;
&lt;h2 id="gatt"&gt;GATT&lt;/h2&gt;
&lt;p&gt;BLE蓝牙连接都建立在GATT（Generic Attribute Profile）协议栈之上。关于GATT，官方的介绍如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;GATT is an acronym for the Generic Attribute Profile, and it defines the way that two Bluetooth Low Energy devices transfer data back and forth using concepts called &lt;strong&gt;Services&lt;/strong&gt; and &lt;strong&gt;Characteristics&lt;/strong&gt;. It makes use of a generic data protocol called the &lt;strong&gt;Attribute Protocol (ATT)&lt;/strong&gt;, which is used to store Services, Characteristics and related data in a simple lookup table using 16-bit IDs for each entry in the table.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="gatt"&gt;GATT连接拓扑模型&lt;/h3&gt;
&lt;p&gt;一个从属设备同时只能连接一个中心设备，中心设备可以同时连接多个从属设备。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://pu4d7sa3m.bkt.clouddn.com/2017040628845microcontrollers_ConnectedTopology.png" alt="2017040628845microcontrollers_ConnectedTopology.png"&gt;&lt;/p&gt;
&lt;p&gt;如果两个从属设备之间需要通信，通用的做法是Central设备用来做Mailbox系统，所有信息都会通过Central设备来进行中转。&lt;/p&gt;
&lt;p&gt;一旦建立了连接，通信就变成双向的了，注意，广播数据是单向的数据通信。&lt;/p&gt;
&lt;h3 id="gatt"&gt;GATT通信事务&lt;/h3&gt;
&lt;p&gt;一旦两个设备建立起了连接，GATT 就开始起作用了，这也意味着，你已经完成了履行前面的 GAP 协议。这里需要说明的是，GATT 连接，必需先经过 GAP 协议。实际上，我们在 Android 开发中，可以直接使用设备的 MAC 地址，发起连接，可以不经过扫描的步骤。这并不意味不需要经过 GAP，实际上在芯片级别已经给你做好了，蓝牙芯片发起连接，总是先扫描设备，扫描到了才会发起连接。&lt;/p&gt;
&lt;p&gt;当连接简历完成之后，从属设备会主动发起确认一个**连接间隔‘Connection Interval’**的东西，这是一个GATT通信的连接间隔，这个间隔由从属设备建议，传输到中心设备，中心设备会按照这个时间不断查看从属设备中是否有新数据。当然，这个时间间隔由从属设备发起建议，中心设备可能也不会理会，会继续用自己的连接间隔做数据通信。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://pu4d7sa3m.bkt.clouddn.com/2017040615489microcontrollers_GattMasterSlaveTransactions.png" alt="2017040615489microcontrollers_GattMasterSlaveTransactions.png"&gt;&lt;/p&gt;
&lt;p&gt;可以看到所有的数据通信请求每次都是由中心设备发起，从属设备进行应答。&lt;/p&gt;
&lt;h3 id="gatt"&gt;GATT结构&lt;/h3&gt;
&lt;p&gt;GATT结构中主要有三个概念，如下&lt;/p&gt;
&lt;p&gt;&lt;img src="http://pu4d7sa3m.bkt.clouddn.com/2017040689874microcontrollers_GattStructure.png" alt="2017040689874microcontrollers_GattStructure.png"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Profile&lt;/p&gt;
&lt;p&gt;Profile 并不是实际存在于 BLE 外设上的，它只是一个被 Bluetooth SIG 或者外设设计者预先定义的 Service 的集合。例如&lt;a href="https://developer.bluetooth.org/TechnologyOverview/Pages/HRP.aspx"&gt;心率Profile（Heart Rate Profile）&lt;/a&gt;就是结合了 Heart Rate Service 和 Device Information Service。所有官方通过 GATT Profile 的列表可以从&lt;a href="http://developer.bluetooth.org/TechnologyOverview/Pages/Profiles.aspx#GATT"&gt;这里&lt;/a&gt;找到；&lt;/p&gt;
&lt;p&gt;一个设备中可以包含多个Profile；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Service&lt;/p&gt;
&lt;p&gt;Service把数据分成一个个的独立逻辑项，它包含一个或者多个 Characteristic。每个 Service 有一个 UUID 唯一标识。 UUID 有 16 bit 的，或者 128 bit 的。16 bit 的 UUID 是官方通过认证的，需要花钱购买，128 bit 是自定义的，这个就可以自己随便设置。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.bluetooth.com/specifications/gatt/services"&gt;官方预置的Service列表&lt;/a&gt;中，可以看到心率Service的UUID为0x180D，&lt;a href="https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.service.cycling_speed_and_cadence.xml"&gt;Cycling Speed and Cadence&lt;/a&gt;的UUID为0x1816，其他类似。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Characteristic&lt;/p&gt;
&lt;p&gt;Characteristic是GATT事务划分中最底层的逻辑单元，属于叶子节点。Characteristic从属于Service，一个Service可以包含多个Characteristic。每个Characteristic都有一个唯一的UUID作为标识符，16bit是Bluetooth SIG预置的（&lt;a href="https://developer.bluetooth.org/gatt/characteristics/Pages/CharacteristicsHome.aspx"&gt;standard characteristics defined by the Bluetooth SIG&lt;/a&gt;），128bit可自定义.&lt;/p&gt;
&lt;p&gt;例如，心率Service中的&lt;a href="https://developer.bluetooth.org/gatt/characteristics/Pages/CharacteristicViewer.aspx?u=org.bluetooth.characteristic.heart_rate_measurement.xml"&gt;Heart Rate Measurement characteristic&lt;/a&gt;是该Service强制要求必须要有的，UUID是0x2A37，其中的数据字段参考具体说明。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.service.cycling_speed_and_cadence.xml"&gt;骑行踏频及速度Characteristic官方说明&lt;/a&gt;供参考。&lt;/p&gt;
&lt;p&gt;我们在做蓝牙数据通信时，Characteristic是最经常用到的一个概念。不论是Peripheral还是Central中，都会涉及到Characteristic，用来传输数据，你可以从Characteristic读数据，也可以向Characteristic中写数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=""&gt;传输速度&lt;/h2&gt;
&lt;p&gt;每个Characteristic中的数据包最大长度是20字节，根据蓝牙BLE协议， 物理层physical layer的传输速率是1Mbps，相当于每秒125K字节。事实上，其只是基准传输速率，协议规定BLE不能连续不断地传输数据包，否则就不能称为低功耗蓝牙了。连续传输自然会带来高功耗。所以，蓝牙的最高传输速率并不由物理层的工作频率决定的。&lt;/p&gt;
&lt;p&gt;在实际的操作过程中，如果主机连线不断地发送数据包，要么丢包严重要么连接出现异常而断开。&lt;/p&gt;
&lt;p&gt;在BLE里面，传输速度受其连接参数所影响。连接参数定义如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;连接间隔&lt;/strong&gt;，蓝牙基带是跳频工作的，主机和从机会商定多长时间进行跳频连接，连接上才能进行数据传输。这个连接和广播状态和连接状态的连接不是一样的意思。主机在从机广播时进行连接是应用层的主动软件行为。而跳频过程中的连接是蓝牙基带协议的规定，完全由硬件控制，对应用层透明。明显，如果这个连接间隔时间越短，那么传输的速度就增大。连接上传完数据后，蓝牙基带即进入休眠状态，保证低功耗。其是1.25毫秒一个单位。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;连接延迟&lt;/strong&gt; 其是为了低功耗考虑，允许从机在跳频过程中不理会主机的跳频指令，继续睡眠一段时间。而主机不能因为从机睡眠而认为其断开连接了。其是1.25毫秒一个单位。明显，这个数值越小，传输速度也高。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;蓝牙BLE协议规定连接参数最小是5，即7.25毫秒；而&lt;a href="http://lib.csdn.net/base/android"&gt;Android&lt;/a&gt;手机规定连接参数最小是8，即10毫秒。&lt;a href="http://lib.csdn.net/base/ios"&gt;iOS&lt;/a&gt;规定是16，即20毫秒。&lt;/p&gt;
&lt;p&gt;连接参数完全由主机决定，但从机可以发出更新参数申请，主机可以接受也可以拒绝。Android手机一部接受，而ios比较严格，拒绝的概率比较高。&lt;/p&gt;
&lt;p&gt;​	一般场景，连接参数设置16，即20毫秒，一般的传输速率是50* 20 = 1000字节/每秒。如果每个连接事件传输更多的包，可以获得更高的传输速率。&lt;/p&gt;
&lt;h2 id=""&gt;参考文献&lt;/h2&gt;
&lt;h3 id="bluetoothsigresources"&gt;Bluetooth SIG Resources&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.bluetooth.com/specifications/gatt"&gt;Bluetooth GATT Specifications&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;官方通过的 &lt;a href="https://developer.bluetooth.org/TechnologyOverview/Pages/Profiles.aspx#GATT"&gt;BLE Profile&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;官方通过的 &lt;a href="https://developer.bluetooth.org/gatt/services/Pages/ServicesHome.aspx"&gt;BLE Service&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;官方通过的 &lt;a href="https://developer.bluetooth.org/gatt/characteristics/Pages/CharacteristicsHome.aspx"&gt;BLE Characteristic&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="adafruitresources"&gt;Adafruit Resources&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://learn.adafruit.com/introduction-to-bluetooth-low-energy?view=all"&gt;BLE Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.android.com/guide/topics/connectivity/bluetooth-le.html"&gt;Android BLE Guide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content:encoded></item><item><title>骑行运动卡路里计算方法</title><description>Email: chenjian345@gmail.com</description><link>http://localhost:2368/2017/03/01/qi-xing-yun-dong-qia-lu-li-ji-suan-fang-fa/</link><guid isPermaLink="false">5a702c40f2c769befd9f2f31</guid><category>工具</category><dc:creator>Mark Chen</dc:creator><pubDate>Wed, 01 Mar 2017 11:48:42 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;文 · Mark&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="http://baike.baidu.com/view/14058.htm"&gt;卡路里&lt;/a&gt;（简称卡，缩写为cal），由英文Calorie音译而来，其定义为在1个大气压下，将1克水提升1摄氏度所需要的&lt;a href="http://baike.baidu.com/view/62743.htm"&gt;热量&lt;/a&gt;；&lt;/p&gt;
&lt;p&gt;卡路里（calorie）是&lt;a href="http://baike.baidu.com/view/14394.htm"&gt;能量&lt;/a&gt;单位，现在仍被广泛使用在营养计量和健身手册上，国际标准的能量单位是&lt;a href="http://baike.baidu.com/view/4336.htm"&gt;焦耳&lt;/a&gt;（joule）。&lt;/p&gt;
&lt;p&gt;作为食物热量的法定单位，在欧洲普遍使用焦耳，美国则采用卡路里。虽然焦耳是&lt;a href="http://baike.baidu.com/view/61891.htm"&gt;中国&lt;/a&gt;大陆与&lt;a href="http://baike.baidu.com/view/2200.htm"&gt;台湾&lt;/a&gt;地区的法定单位，然而由于沿袭传统，卡路里在中国大陆与台湾地区仍然被广泛的使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=""&gt;计量单位&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;小卡，记做cal, 1卡路里的能量或热量可将1克水在一个大气压下的温度升高1摄氏度;&lt;/li&gt;
&lt;li&gt;大卡，记作Cal, 1大卡相当于1000小卡&lt;/li&gt;
&lt;li&gt;焦耳
&lt;ul&gt;
&lt;li&gt;詹姆斯·普雷斯科特·焦耳（James Prescott Joule，1818年12月24日－1889年10月11日），出生于&lt;a href="http://baike.baidu.com/view/127481.htm"&gt;曼彻斯特&lt;/a&gt;近郊的沙弗特，英国皇家学会会员，英国物理学家。&lt;/li&gt;
&lt;li&gt;由于他在&lt;a href="http://baike.baidu.com/view/78151.htm"&gt;热学&lt;/a&gt;、&lt;a href="http://baike.baidu.com/view/78147.htm"&gt;热力学&lt;/a&gt;和&lt;a href="http://baike.baidu.com/view/14957.htm"&gt;电&lt;/a&gt;方面的贡献，&lt;a href="http://baike.baidu.com/view/1339035.htm"&gt;皇家学会&lt;/a&gt;授予他最高荣誉的&lt;a href="http://baike.baidu.com/view/23595.htm"&gt;科普利奖章&lt;/a&gt;（Copley Medal）。后人为了纪念他，把能量或&lt;a href="http://baike.baidu.com/view/14447.htm"&gt;功&lt;/a&gt;的单位命名为“&lt;a href="http://baike.baidu.com/view/4336.htm"&gt;焦耳&lt;/a&gt;”，简称“焦”；并用焦耳姓氏的第一个字母“J”来标记热量以及“功”的物理量。&lt;/li&gt;
&lt;li&gt;焦耳在研究热的本质时，发现了热和功之间的转换关系，并由此得到了能量守恒定律，最终发展出热力学第一定律。国际单位制导出单位中，能量的单位——焦耳，就是以他的名字命名。他和开尔文合作发展了温度的绝对尺度。他还观测过磁致伸缩效应，发现了导体电阻、通过导体电流及其产生热能之间的关系，也就是常称的焦耳定律。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;BMR
&lt;ul&gt;
&lt;li&gt;Basal Metabolism Rate 基础代谢率&lt;/li&gt;
&lt;li&gt;基础代谢(basal metabolism,BM)是指人体在清醒而又极端安静的状态下，不受肌肉活动、&lt;a href="http://baike.baidu.com/view/1461402.htm"&gt;环境温度&lt;/a&gt;、食物及精神紧张等影响时的&lt;a href="http://baike.baidu.com/view/1696565.htm"&gt;能量代谢率&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://baike.baidu.com/view/264238.htm"&gt;基础代谢率&lt;/a&gt;随着性别、年龄等不同而有生理变动。男子的基础代谢率平均比女子高，&lt;a href="http://baike.baidu.com/view/1254775.htm"&gt;幼年&lt;/a&gt;比成年高；年龄越大，&lt;a href="http://baike.baidu.com/subview/434238/434238.htm"&gt;代谢率&lt;/a&gt;越低。一般来说，基础代谢率的实际数值与正常的平均值相差10%－15%之内都属于正常。超过正常值20%时，才能算病理状态。甲状腺机能减退时，基础代谢率比正常标准低20－40%；甲状腺功能亢进时，基础代谢率比正常标准高出25-80%。其他如&lt;a href="http://baike.baidu.com/subview/1197005/1197005.htm"&gt;肾上腺皮质&lt;/a&gt;和脑下垂体机能低下时，基础代谢率也要降低。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;METs
&lt;ul&gt;
&lt;li&gt;Metabolic Equivalent of Task (MET)，某项活动的代谢当量，不同运动类型，代谢当量不同；&lt;/li&gt;
&lt;li&gt;A MET is the ratio of the work metabolic rate to the resting metabolic rate. One MET is defined as 1 kcal/kg/hour and is roughly equivalent to the energy cost of sitting quietly. For example: the energy cost of playing rugby is 8.3 METS, which means you use 8.3 times more energy than if you were to sit quietly and rest.&lt;/li&gt;
&lt;li&gt;代谢当量是以安静且坐位时的能量消耗为基础，表达各种活动时相对能量代谢水平的常用指标。可以用来评估心肺功能。1MET=耗氧量3.5ml/(kg·min)。例如人在静坐时MET约为1.0，速度为9.6km/h的跑步MET约为10.0等。右图为某些体育运动和日常活动。&lt;/li&gt;
&lt;li&gt;A MET can also defined as oxygen uptake in ml/kg/min with one MET equal to the oxygen cost of sitting quietly, equivalent to 3.5 ml/kg/min.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=""&gt;换算关系&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;1000 cal(小卡) = 1 Cal(大卡) = 1.0 kcal(千卡)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;1 kcal = 4.184 kJ
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;1 KJ = 0.239 kcal
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=""&gt;计算公式&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;卡路里计算公式&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Calories(kcal) = BMR * METs/24 * Hour
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;BMR计算公式&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Women: BMR = 655.1 + (9.563 × weight in kg) + (1.850 × height in cm) – (4.676 × age in years)
 
Men: BMR = 66.5 + (13.75 × weight in kg) + (5.003 × height in cm) – (6.755 × age in years)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;METs表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;参考2011 Compendium&lt;/em&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align:center"&gt;METs&lt;/th&gt;
&lt;th style="text-align:left"&gt;Type Of Bicycling&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align:center"&gt;7.5&lt;/td&gt;
&lt;td style="text-align:left"&gt;Bicycling, General&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align:center"&gt;3.5&lt;/td&gt;
&lt;td style="text-align:left"&gt;bicycling, leisure, 5.5 mph&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align:center"&gt;5.8&lt;/td&gt;
&lt;td style="text-align:left"&gt;bicycling, leisure, 9.4 mph&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align:center"&gt;6.8&lt;/td&gt;
&lt;td style="text-align:left"&gt;bicycling, 10-11.9 mph, leisure, slow, light effort&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align:center"&gt;8.0&lt;/td&gt;
&lt;td style="text-align:left"&gt;bicycling, 12-13.9 mph, leisure, moderate effort&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align:center"&gt;10.0&lt;/td&gt;
&lt;td style="text-align:left"&gt;bicycling, 14-15.9 mph, racing or leisure, fast, vigorous effort&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align:center"&gt;12.0&lt;/td&gt;
&lt;td style="text-align:left"&gt;bicycling, 16-19 mph, racing/not drafting or &amp;gt; 19 mph drafting, very fast, racing general&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align:center"&gt;15.8&lt;/td&gt;
&lt;td style="text-align:left"&gt;bicycling, &amp;gt; 20 mph, racing, not drafting&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;欢迎交流指正！&lt;/p&gt;
&lt;p&gt;ENJOY~&lt;/p&gt;
&lt;p&gt;2017.3.1&lt;/p&gt;
&lt;h2 id=""&gt;参考链接&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://keisan.casio.com/exec/system/1350958587"&gt;Bicycling Calorie Calculator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://sites.google.com/site/compendiumofphysicalactivities/Activity-Categories/bicycling"&gt;2011 Compendium categories&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://calcuworld.com/health-calculators/calories-burnt-whilst-cycling-calculator/"&gt;Calories Burnt Whilst Cycling Calculator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://baike.baidu.com/item/%E5%8D%A1%E8%B7%AF%E9%87%8C"&gt;百度百科 - 卡路里&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.mapmyride.com/improve/calorie_calculator/"&gt;MapMyRide - CALORIE CALCULATOR&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content:encoded></item><item><title>近期遇到的奇葩Bug之解决从入门到懵逼</title><description>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;文• Mark&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;此事发生在2016年10月，后与朋友分享过，朋友希望能写下来分享。因当时较忙，暂未整理，一直拖到现在。清晨早醒，整理之，以飨读者。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所谓Bug即软件中存在的小错误导致异常。奇葩Bug则是那些遇到时让人无所适从，解决时狂挠头发而不知所以，解决后又能仰天大笑，悲喜交加。&lt;/p&gt;
&lt;p&gt;以前知乎上搜到过一个朋友分享硬件开发中，把脚放在桌子上，Bug出现，把脚拿下来的就没事的奇葩Bug分享，当时也只是开心一笑。没想到，最近，我与我的同事们也遇到了一个奇葩Bug。&lt;/p&gt;
&lt;p&gt;此Bug，时间和空间因素都是诱因，但小勿入。&lt;/p&gt;
&lt;p&gt;硬件固件和App版本初发布，热心用户反馈无法同步数据，在此再次感谢🙏 这些用户。但我们相关开发同事都清楚，数据同步部分都没有动过，怎么之前是好的，现在突然有问题了? Review版本修改，数据同步模块也没有做过任何修改，怪！但这种问题绝不能忍，遂与同事两人尝试模拟复现，这也是这次奇葩Bug之旅的主角。&lt;/p&gt;
&lt;h1 id=""&gt;历程🐳🐳🐳&lt;/h1&gt;
&lt;h3 id=""&gt;第一天🐢&lt;/h3&gt;
&lt;p&gt;复测一天均为复现，查找log也并无异常，茫然一天即将过去，晚上还在思考问题可能出在哪，不得解，第二天继续吧。此时下班时，&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/2017/02/22/jin-qi-yu-dao-de-qi-pa-bugzhi-jie-jue-cong-ru-men-dao-meng-bi/</link><guid isPermaLink="false">5a702c40f2c769befd9f2f30</guid><dc:creator>Mark Chen</dc:creator><pubDate>Wed, 22 Feb 2017 04:42:50 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;文• Mark&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;此事发生在2016年10月，后与朋友分享过，朋友希望能写下来分享。因当时较忙，暂未整理，一直拖到现在。清晨早醒，整理之，以飨读者。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所谓Bug即软件中存在的小错误导致异常。奇葩Bug则是那些遇到时让人无所适从，解决时狂挠头发而不知所以，解决后又能仰天大笑，悲喜交加。&lt;/p&gt;
&lt;p&gt;以前知乎上搜到过一个朋友分享硬件开发中，把脚放在桌子上，Bug出现，把脚拿下来的就没事的奇葩Bug分享，当时也只是开心一笑。没想到，最近，我与我的同事们也遇到了一个奇葩Bug。&lt;/p&gt;
&lt;p&gt;此Bug，时间和空间因素都是诱因，但小勿入。&lt;/p&gt;
&lt;p&gt;硬件固件和App版本初发布，热心用户反馈无法同步数据，在此再次感谢🙏 这些用户。但我们相关开发同事都清楚，数据同步部分都没有动过，怎么之前是好的，现在突然有问题了? Review版本修改，数据同步模块也没有做过任何修改，怪！但这种问题绝不能忍，遂与同事两人尝试模拟复现，这也是这次奇葩Bug之旅的主角。&lt;/p&gt;
&lt;h1 id=""&gt;历程🐳🐳🐳&lt;/h1&gt;
&lt;h3 id=""&gt;第一天🐢&lt;/h3&gt;
&lt;p&gt;复测一天均为复现，查找log也并无异常，茫然一天即将过去，晚上还在思考问题可能出在哪，不得解，第二天继续吧。此时下班时，测试设备一直开着…说实话是忘关了。&lt;/p&gt;
&lt;h3 id=""&gt;第二天🦀️&lt;/h3&gt;
&lt;p&gt;早晨上班，一个同事说不能同步了，但再次尝试开启新纪录又可以同步数据，只好继续留意观察。晩上下班我们有意把测试设备保持昨晩的状态，跑一晚明天再看是不是还能复现&lt;/p&gt;
&lt;h3 id=""&gt;第三天🐚&lt;/h3&gt;
&lt;p&gt;早晨上班，还是这个同事，突然触电般跳起来说：擦，不能数据同步了，什么鬼？！👹 顿时神经紧绷，召集硬件同事保持信息同步，但硬件同事也百思不得姐。&lt;/p&gt;
&lt;p&gt;会不会是因为模拟跑一晚，距离很长，点数太多就会复现？但测一次要一晚，太久不能忍😁，机智的我们🤓 🤔 打算改造 它，在保证硬件性能可以Hold住的情况下， 提高数据采集频率10倍，提高速度10倍， 保证每两次数据采集距离相同，点数相同，但 所花的时间缩小十倍，以快速排除上述怀疑。&lt;/p&gt;
&lt;p&gt;改造完成，但Bug并未复现.&lt;/p&gt;
&lt;p&gt;茫然...🤕 🤒 🤥&lt;/p&gt;
&lt;h5 id=""&gt;下午&lt;/h5&gt;
&lt;p&gt;硬件同事告诉我们，他好像发现了什么，室外貌似可以模拟复现。赶快试一下，果然。但晚上室内复现的那两次又如何解释呢？激动不已，内取满面！&lt;/p&gt;
&lt;p&gt;那么，现在这个Bug不仅和时间维度相关， 还和空间维度相关了！😓 🔯 ⏱&lt;/p&gt;
&lt;p&gt;一口老血 💣 💣 💣&lt;/p&gt;
&lt;p&gt;室内和室外的差别就是室外可以接收到并处理GPS信号，看看GPS处理模块在搞什么鬼， 果然．有个地方出问题了。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://ww1.sinaimg.cn/large/006tKfTcly1fcz593e6bcj30gs037q3b.jpg" alt=""&gt;&lt;/p&gt;
&lt;p&gt;这也解释了为什么这个Bug只在10月出现👩🏼‍🚒&lt;/p&gt;
&lt;p&gt;那两个晚上测试出现的结果如何解释呢？🌶&lt;/p&gt;
&lt;p&gt;👉 办公室白天人多，干扰多，GPS信号飘不进来，模拟测试设备接收不到GPS信号，所以Bug不出现！&lt;br&gt;
👉 办公室晚上人少，干扰少，GPS信号可以飘进来，模拟测试设备可以接收到GPS信号，Bug出现！&lt;/p&gt;
&lt;h3 id="bug"&gt;Bug亮点🌋🌋🌋&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;室内夜深人静时出现&lt;/li&gt;
&lt;li&gt;只在10月出现&lt;/li&gt;
&lt;li&gt;空旷室外可出现&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;搞定！又可以出去浪啦！🏔🗽⛲️🗼🗻🏜&lt;/p&gt;
&lt;h3 id=""&gt;感受💡&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;硬件相关要注意其物理环境因素&lt;/li&gt;
&lt;li&gt;感谢勇于面对和解决问题的同事，向你们致敬！&lt;/li&gt;
&lt;li&gt;鄙视遇到问题退缩没有担当的菜鸡&lt;/li&gt;
&lt;li&gt;时间和空间维度因素都可能是诱因&lt;/li&gt;
&lt;li&gt;测试很重要，感谢测试同事&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总有一些曾经让你感到痛苦的事情，会在若干时间后，笑着讲出来！&lt;/p&gt;
&lt;p&gt;文笔不好，多指正！&lt;/p&gt;
&lt;p&gt;ENJOY~&lt;/p&gt;
&lt;/div&gt;</content:encoded></item><item><title>Apple Siri接入开发（一）</title><description>&lt;div class="kg-card-markdown"&gt;&lt;blockquote&gt;
&lt;p&gt;随着iOS10.0发布脚步的临近，作为开发者，相信很多人也和我一样，可以提前体验一些新系统的新功能，也更关注新版iOS系统带来的技术开发方面的新特性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对新事物，尤其是软件开发新技术的好奇心驱使我最近尝试了一些iOS10.0推出的新特性的开发，其中就包括本次iOS系统更新开发的SiriKit接入。下面，我就详细讲述一下SiriKit接入的相关开发过程及注意事项，个人见解，如有错误，欢迎大家交流指正。&lt;/p&gt;
&lt;h3 id="sirikit"&gt;关于SiriKit&lt;/h3&gt;
&lt;p&gt;SiriKit是Apple历经4年时间，不断打磨优化，第一次开发给开发者的一份关于Siri功能的礼物。利用SiriKit，第三方开发者可以像一些系统应用一样，通过语音完成第三方应用希望完成的一些功能，比如用户可以直接通过语音直接告诉Siri打车、锻炼、寻找美食、寻找相册中的照片、甚至付给朋友AA的账单费用，以及控制家里智能家居等。&lt;/p&gt;
&lt;h3 id=""&gt;概念概览&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Domain - 被苹果划分的不同业务领域，每个领域中可以执行不同的任务&lt;/li&gt;
&lt;li&gt;Intent - 领域中的任务或意图指令&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=""&gt;实现机制&lt;/h3&gt;
&lt;p&gt;和Android的语音接入Service类似，SiriKit中，将不同的类型的需求统一汇总为若干个Domain，然后在每个Domain中再次细分为不同的Intent。系统通过语音识别获取到的Domain信息以及Intent信息，下发到已注册的Domain中进行处理，然后用户解析处理不同的Intent，来实现自定义的操作。&lt;/p&gt;
&lt;p&gt;SiriKit的接入方式和Watch OS的接入有相似之处，都是以Extension形式存在，该Extension会声明本应用所能处理的Domain内容及Intent种类，告知Siri该应用所能处理的功能范畴.&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/2017/02/07/apple-sirijie-ru-kai-fa-yi/</link><guid isPermaLink="false">5a702c40f2c769befd9f2f2b</guid><category>iOS</category><category>技术</category><category>技术调研</category><category>Siri</category><dc:creator>Mark Chen</dc:creator><pubDate>Tue, 07 Feb 2017 06:34:23 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;blockquote&gt;
&lt;p&gt;随着iOS10.0发布脚步的临近，作为开发者，相信很多人也和我一样，可以提前体验一些新系统的新功能，也更关注新版iOS系统带来的技术开发方面的新特性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对新事物，尤其是软件开发新技术的好奇心驱使我最近尝试了一些iOS10.0推出的新特性的开发，其中就包括本次iOS系统更新开发的SiriKit接入。下面，我就详细讲述一下SiriKit接入的相关开发过程及注意事项，个人见解，如有错误，欢迎大家交流指正。&lt;/p&gt;
&lt;h3 id="sirikit"&gt;关于SiriKit&lt;/h3&gt;
&lt;p&gt;SiriKit是Apple历经4年时间，不断打磨优化，第一次开发给开发者的一份关于Siri功能的礼物。利用SiriKit，第三方开发者可以像一些系统应用一样，通过语音完成第三方应用希望完成的一些功能，比如用户可以直接通过语音直接告诉Siri打车、锻炼、寻找美食、寻找相册中的照片、甚至付给朋友AA的账单费用，以及控制家里智能家居等。&lt;/p&gt;
&lt;h3 id=""&gt;概念概览&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Domain - 被苹果划分的不同业务领域，每个领域中可以执行不同的任务&lt;/li&gt;
&lt;li&gt;Intent - 领域中的任务或意图指令&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=""&gt;实现机制&lt;/h3&gt;
&lt;p&gt;和Android的语音接入Service类似，SiriKit中，将不同的类型的需求统一汇总为若干个Domain，然后在每个Domain中再次细分为不同的Intent。系统通过语音识别获取到的Domain信息以及Intent信息，下发到已注册的Domain中进行处理，然后用户解析处理不同的Intent，来实现自定义的操作。&lt;/p&gt;
&lt;p&gt;SiriKit的接入方式和Watch OS的接入有相似之处，都是以Extension形式存在，该Extension会声明本应用所能处理的Domain内容及Intent种类，告知Siri该应用所能处理的功能范畴.这样，即便你的应用当前并没有打开或在后台运行，通过Siri也可以唤醒你的应用，处理相关逻辑。&lt;/p&gt;
&lt;h4 id="domains"&gt;Domains&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;VoIP Calling - 语音通信相关，如微信、Facebook Messager、Line等;&lt;/li&gt;
&lt;li&gt;Payments - 适用于支付类应用，如PayPal、支付宝等；&lt;/li&gt;
&lt;li&gt;Photo - 与图库相关应用，如Instagram等；&lt;/li&gt;
&lt;li&gt;Workouts - 运动健康类应用，如Strava、NikeRun、野兽骑行等；&lt;/li&gt;
&lt;li&gt;Ride booking - 适用于出行类应用，如Uber、滴滴打车等；&lt;/li&gt;
&lt;li&gt;CarPlay（automotive vendors only）- 车载及自动驾驶相关，尚不明晰&lt;/li&gt;
&lt;li&gt;Restarurant reservations(Requires addtional support from Apple) - 酒店服务类，具体需求上不明晰&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="intents"&gt;Intents&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;VoIP Calling&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Start an audio call -开始语音通话&lt;/li&gt;
&lt;li&gt;Start a video call - 开始视频通话&lt;/li&gt;
&lt;li&gt;Search the user’s call history -搜寻通话历史&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Messaging&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Send a message&lt;/li&gt;
&lt;li&gt;Search for messages&lt;/li&gt;
&lt;li&gt;Set attributes on a message&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Photos&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Search for photos&lt;/li&gt;
&lt;li&gt;Play a photo slideshow&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Payments&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Send a payment to another user&lt;/li&gt;
&lt;li&gt;Request a payment from another user&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Workouts&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Start a workout&lt;/li&gt;
&lt;li&gt;Pause a workout&lt;/li&gt;
&lt;li&gt;Resume a workout&lt;/li&gt;
&lt;li&gt;End a workout&lt;/li&gt;
&lt;li&gt;Cancel a workout&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ride Booking&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Get a list of available rides (Maps only)&lt;/li&gt;
&lt;li&gt;Book a ride&lt;/li&gt;
&lt;li&gt;Get the status of a booked ride&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CarPlay&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Change the audio source&lt;/li&gt;
&lt;li&gt;Change the climate control settings&lt;/li&gt;
&lt;li&gt;Change the defroster settings&lt;/li&gt;
&lt;li&gt;Saving vehicle settings to a profile&lt;/li&gt;
&lt;li&gt;Restoring vehicle settings from a profile&lt;/li&gt;
&lt;li&gt;Change the seat temperature&lt;/li&gt;
&lt;li&gt;Change the radio station&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Restaurant Reservations&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Get the user’s current restaurant reservations&lt;/li&gt;
&lt;li&gt;Get information about the user to associate with a booking.&lt;/li&gt;
&lt;li&gt;Get default values to use when requesting reservation times.&lt;/li&gt;
&lt;li&gt;Get the reservation times that are currently available.&lt;/li&gt;
&lt;li&gt;Book a reservation for the user.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意，经过开发实践，每种Domain及Intents都有固定或相似的语法形式，为增加识别度，可以参考官网说明，按照说明中自然语言语法形式唤起相应的Siri功能，例如：”用XXX开始跑步“ 要比仅仅说 “XXX开始跑步”能更好的识别出应用XXX。&lt;/p&gt;
&lt;p&gt;由于Siri所使用的识别技术及语言模型是在云端训练并完成数据解析，可能还有些不完善。在我们刚开始开发时，就遇到了这样的问题，中文普通话的有些Intent会有支持不完整的情况，导致语音识别不出来，无法完成语义解析，相关回调方法不被调用等问题，如有大家也遇到了类似问题，建议使用英文进行测试。&lt;/p&gt;
&lt;p&gt;对于此问题，也已经向Apple Siri开发团队反应，相关训练任务已经在进行中，很惊喜的是，在之后的开发中，有些之前不支持的Intent语义识别也已经可以使用了。&lt;/p&gt;
&lt;h3 id=""&gt;开发流程&lt;/h3&gt;
&lt;p&gt;上面简述了SiriKit的一些背景知识及实现机制，下面简单介绍一下我在接入SiriKit时使用的开发流程.&lt;/p&gt;
&lt;h3 id=""&gt;开发环境&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;MacbookPro. OSX EI Capitan 10.11.6&lt;/li&gt;
&lt;li&gt;xCode 8.0 beta6(8S201h)&lt;/li&gt;
&lt;li&gt;iPhone6 iOS10.0 beta6&lt;/li&gt;
&lt;li&gt;iTerms2, git, etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=""&gt;支持类型&lt;/h3&gt;
&lt;p&gt;对于向现有iOS应用中加入对Siri的支持有两种形式，一种是Intents Extension，另一种是Intents UI Extension，前者没有UI界面，类似一个后台逻辑处理服务，这项Extension是必选的。&lt;/p&gt;
&lt;p&gt;而Siri UI Extensions是可选内容，用于展示一些确认信息等操作。经负责该功能的Apple SiriKit工程师确认，UI Siri Extensions的声明周期比较短，部分应用可根据实际需要采用，但Workout类应用目前试用范围较宅，本例中未采用。&lt;/p&gt;
&lt;h3 id=""&gt;接入步骤&lt;/h3&gt;
&lt;p&gt;本次接入SiriKit开发中，采用Workout类应用，此处Workout并不是Apple WatchOS 3.0中新增的Workout App, 而是指一类运动锻炼相关应用，例如，Strava, Nike Run一类。由于Apple SiriKit中限制了7类不同的Domain，如果需要接入其他类别的应用，如天气，支付等，可以参考官方接入指南进行相关开发。&lt;/p&gt;
&lt;h4 id="step1siricapability"&gt;Step1. 打开应用的Siri Capability&lt;/h4&gt;
&lt;p&gt;在Xcode8中，选中应用Target，选择Capability标签，打开Siri Capability打开，如图所示：&lt;br&gt;
&lt;img src="http://okzqhpqwj.bkt.clouddn.com/201702072461357c303f4ab644135ea06285a.png" alt="201702072461357c303f4ab644135ea06285a.png"&gt;&lt;/p&gt;
&lt;p&gt;打开该属性后，工程文件的Entitlements文件会增加如下内容：&lt;br&gt;
&lt;img src="http://okzqhpqwj.bkt.clouddn.com/201702071729357c303f4ab644135ea06285b.png" alt="201702071729357c303f4ab644135ea06285b.png"&gt;&lt;/p&gt;
&lt;h4 id="step2siriintentsextension"&gt;Step2:  创建支持Siri的Intents Extension&lt;/h4&gt;
&lt;p&gt;首先选中App工程，为该App添加对Siri的Intents Extension支持的Target，如图：&lt;br&gt;
&lt;img src="http://okzqhpqwj.bkt.clouddn.com/201702075782857c303f4ab644135ea062857.png" alt="201702075782857c303f4ab644135ea062857.png"&gt;&lt;/p&gt;
&lt;p&gt;选择Intents Extension&lt;br&gt;
&lt;img src="http://okzqhpqwj.bkt.clouddn.com/201702076878357c303f4ab644135ea062858.png" alt="201702076878357c303f4ab644135ea062858.png"&gt;&lt;/p&gt;
&lt;p&gt;命名并选择是否UI Extension，可根据自我业务需求确定，本例中，对UI Extension不进行支持。&lt;br&gt;
&lt;img src="http://okzqhpqwj.bkt.clouddn.com/20170207372957c303f4ab644135ea062859.png" alt="20170207372957c303f4ab644135ea062859.png"&gt;&lt;/p&gt;
&lt;p&gt;创建完成后，Siri Intents Extension的target会显示在Target列表中。&lt;/p&gt;
&lt;h3 id="step3intent"&gt;Step3: 定义所支持的Intent&lt;/h3&gt;
&lt;p&gt;该步骤相当于告诉Siri及iOS系统，本应用中所支持的Domain和Intents都有哪些，这样iOS系统及Siri就知道你的应用可以处理哪些请求，不能处理哪些请求。&lt;br&gt;
打开Siri Intents Extension工程中的Info.plist文件，选中NSExtension，修改所支持的Intent类型，具体类型字符串可以查询开发文档，添加后的内容如下：&lt;br&gt;
&lt;img src="http://okzqhpqwj.bkt.clouddn.com/201702076763357c30921ab644133ed0638de.png" alt="201702076763357c30921ab644133ed0638de.png"&gt;&lt;/p&gt;
&lt;p&gt;IntentsRestrictedWhileLocked是可选项，用来控制锁屏状态下，对不同命令的响应行为。&lt;/p&gt;
&lt;h4 id="step4siri"&gt;Step4：添加对主应用Siri权限支持&lt;/h4&gt;
&lt;p&gt;在主应用Info.plist文件中添加NSSiriUsageDescription Key，该key用来标记应用与Extension所沟通的数据类型，用于告知用户，你的应用为何要支持Siri的描述信息，比如Workout类应用，我可以这么写：“健身锻炼的信息会发送到Siri，更快捷的记录健身数据”&lt;/p&gt;
&lt;p&gt;仅仅添加NSSiriUsageDescription这个Key到Info.plist文件中是不够的，当应用第一次启动时，我们需要用户打开应用的Siri支持权限，默认情况下，这个权限是关闭的，所以，需要我们通过调用INPreferences的类方法equestSiriAuthorization: 来通知用户打开Siri权限支持。&lt;/p&gt;
&lt;h4 id="step5"&gt;Step5. 添加逻辑&lt;/h4&gt;
&lt;p&gt;OK，到此为止，我们已经把所有接入Siri Intents Extension的前期准备工作都已经完成，现在我们要进入正题，实现相应的逻辑处理代码编写工作。&lt;br&gt;
修改IntentHandling.swift文件，根据需要，修改所需要实现的协议内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objective-c"&gt;class  IntentHandler:INExtension,INStartWorkoutIntentHandling,INPauseWorkoutIntentHandling,INResumeWorkoutIntentHandling,INEndWorkoutIntentHandling{
	...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;OK，到此为止，我们已经把所有接入Siri Intents Extension的前期准备工作都已经完成，现在我们要进入正题，实现相应的逻辑处理代码编写工作。&lt;br&gt;
修改IntentHandling.swift文件，根据需要，修改所需要实现的协议内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objective-c"&gt;class IntentHandler:INExtension,INStartWorkoutIntentHandling
    ,INPauseWorkoutIntentHandling,INResumeWorkoutIntentHandling
    ,INEndWorkoutIntentHandling{
	...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改所需要实现的﻿不同场景下的逻辑回调部分，调用所在iOS App的相关业务逻辑，满足产品需求，例如&lt;/p&gt;
&lt;p&gt;开始锻炼&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/*!
@briefhandlingmethod
@abstractExecutethetaskrepresentedbytheINStartWorkoutIntentthat
    'spassedin
@discussionThismethodiscalledtoactuallyexecutetheintent
    .Theappmustreturnaresponseforthisintent.
@paramstartWorkoutIntentTheinputintent
@paramcompletionTheresponsehandlingblocktakesaINStartWorkoutIn
    tentResponsecontainingthedetailsoftheresultofhavingexecutedthe
    intent
@seeINStartWorkoutIntentResponse
*/
public func handle(startWorkoutintent:INStartWorkoutIntent,completion
    :@escaping(INStartWorkoutIntentResponse)-&amp;gt;Swift.Void){
	print(&amp;quot;HereisStartworkoutcalledbySiri&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;暂停锻炼&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//MARK:-INPauseWorkoutIntentHandling
/*!
@briefhandlingmethod
@abstractExecutethetaskrepresentedbytheINPauseWorkoutIntentthat
    'spassedin
@discussionThismethodiscalledtoactuallyexecutetheintent
    .Theappmustreturnaresponseforthisintent.
@parampauseWorkoutIntentTheinputintent
@paramcompletionTheresponsehandlingblocktakesaINPauseWorkoutIn
    tentResponsecontainingthedetailsoftheresultofhavingexecutedthe
    intent
@seeINPauseWorkoutIntentResponse
*/
public func handle(pauseWorkoutintent:INPauseWorkoutIntent,completion
    :@escaping(INPauseWorkoutIntentResponse)-&amp;gt;Swift.Void){
	print(&amp;quot;HereisPauseworkoutcalledbySiri&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;恢复锻炼&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//MARK:-INResumeWorkoutIntentHandling
/*!
@briefhandlingmethod
@abstractExecutethetaskrepresentedbytheINResumeWorkoutIntenttha
    t'spassedin
@discussionThismethodiscalledtoactuallyexecutetheintent
    .Theappmustreturnaresponseforthisintent.
@paramresumeWorkoutIntentTheinputintent
@paramcompletionTheresponsehandlingblocktakesaINResumeWorkoutI
    ntentResponsecontainingthedetailsoftheresultofhavingexecutedth
    eintent
@seeINResumeWorkoutIntentResponse
*/
public func handle(resumeWorkoutintent:INResumeWorkoutIntent
    ,completion:@escaping(INResumeWorkoutIntentResponse)-&amp;gt;Swift.Void){
	print(&amp;quot;HereisResumeworkoutcalledbySiri&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结束锻炼&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//MARK:-INEndWorkoutIntentHandling
/*!
@briefhandlingmethod
@abstractExecutethetaskrepresentedbytheINEndWorkoutIntentthat's
    passedin
@discussionThismethodiscalledtoactuallyexecutetheintent
    .Theappmustreturnaresponseforthisintent.
@paramendWorkoutIntentTheinputintent
@paramcompletionTheresponsehandlingblocktakesaINEndWorkoutInte
    ntResponsecontainingthedetailsoftheresultofhavingexecutedthei
    ntent
@seeINEndWorkoutIntentResponse
*/
public func handle(endWorkoutintent:INEndWorkoutIntent,completion
    :@escaping(INEndWorkoutIntentResponse)-&amp;gt;Swift.Void){
	print(&amp;quot;HereisEndworkoutcalledbySiri&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=""&gt;总结&lt;/h3&gt;
&lt;p&gt;以上就完成了所有接入SiriKit的工作，剩余的应用就是测试成果，此处有一些技巧，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;技巧一：由于SiriKit首次发布，有些语言支持尚不完善，建议使用英文进行测试，这样可以避开一些Intent在不同语言中支持不完整的问题。&lt;/li&gt;
&lt;li&gt;技巧二：iPhone6s及以后设备已经支持了通过“Hey, Siri”语音唤醒的特性，所以用iPhone6s可以方便的不用按住Home就可进行测试，很方便，对于iPhone6 &amp;amp; iPhone6P，插入数据线，连接电脑，也可以通过“Hey, Siri”唤醒，直接进行相应业务需求测试。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上就是接入SiriKit的背景知识点以及基本流程，在接入过程中，与Apple SiriKit开发团队接触过程中，发现了若干问题，也收获了许多知识，在后续文章中，我会单独抽出一篇来与大家分享。文章中间如有错误之处，欢迎大家批评指正，共同成长。&lt;/p&gt;
&lt;p&gt;Enjoy your Siri trip.&lt;/p&gt;
&lt;p&gt;参考文献&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://developer.apple.com/library/prerelease/content/documentation/Intents/Conceptual/SiriIntegrationGuide/"&gt;Apple SiriKit Programming Guide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content:encoded></item><item><title>Apple Watch产品设计经验 FROM 去哪网</title><description>&lt;div class="kg-card-markdown"&gt;&lt;blockquote&gt;
&lt;p&gt;在参与2016WWDC过程中，听取了【去哪网】某位从业人员的关于Apple Watch产品设计技术相关的分享，将要点整理如下，作为学习提纲之用，供参考&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;文中Apple WatchOS应该是基于WatchOS 2.0版本，但某些设计和产品经验同样适用于Apple WatchOS 3.0.&lt;/p&gt;
&lt;h5 id=""&gt;初识 &amp;amp; 迷惘&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;Watch OS Glance？问题：状态展示？如何更新？有无用户交互？
&lt;ul&gt;
&lt;li&gt;只适合进行时间相关的内容展现&lt;/li&gt;
&lt;li&gt;运营相关的内容意义不大，手表是效率工具&lt;/li&gt;
&lt;li&gt;使用类似健身记录的圆环展示方式并不适用于第三方App,最大的Lower也只有XXX像素&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;色彩略单调，watch lib;&lt;/li&gt;
&lt;li&gt;人们不会一直使用某个App;&lt;/li&gt;
&lt;li&gt;操作要简单，10-30s完成;&lt;/li&gt;
&lt;li&gt;推送展现，只有watch在手上才会推送到watch上;&lt;/li&gt;
&lt;li&gt;app group是什么鬼？现在常用于进行非实时简单数据通讯！&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=""&gt;产品层面&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;明亮色彩提升产品感受;&lt;/li&gt;
&lt;li&gt;尽量减少滚动，一屏展示所表现的内容;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=""&gt;技术层面&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;Phone &amp;amp; Watch￼&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</description><link>http://localhost:2368/2017/02/07/guan-yu-apple-watchchan-pin-qu-na-wang-da-shen-fen-xiang/</link><guid isPermaLink="false">5a702c40f2c769befd9f2f25</guid><category>iOS</category><category>Apple watchOS</category><category>产品</category><category>设计</category><category>技术</category><dc:creator>Mark Chen</dc:creator><pubDate>Tue, 07 Feb 2017 03:39:31 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;blockquote&gt;
&lt;p&gt;在参与2016WWDC过程中，听取了【去哪网】某位从业人员的关于Apple Watch产品设计技术相关的分享，将要点整理如下，作为学习提纲之用，供参考&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;文中Apple WatchOS应该是基于WatchOS 2.0版本，但某些设计和产品经验同样适用于Apple WatchOS 3.0.&lt;/p&gt;
&lt;h5 id=""&gt;初识 &amp;amp; 迷惘&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;Watch OS Glance？问题：状态展示？如何更新？有无用户交互？
&lt;ul&gt;
&lt;li&gt;只适合进行时间相关的内容展现&lt;/li&gt;
&lt;li&gt;运营相关的内容意义不大，手表是效率工具&lt;/li&gt;
&lt;li&gt;使用类似健身记录的圆环展示方式并不适用于第三方App,最大的Lower也只有XXX像素&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;色彩略单调，watch lib;&lt;/li&gt;
&lt;li&gt;人们不会一直使用某个App;&lt;/li&gt;
&lt;li&gt;操作要简单，10-30s完成;&lt;/li&gt;
&lt;li&gt;推送展现，只有watch在手上才会推送到watch上;&lt;/li&gt;
&lt;li&gt;app group是什么鬼？现在常用于进行非实时简单数据通讯！&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=""&gt;产品层面&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;明亮色彩提升产品感受;&lt;/li&gt;
&lt;li&gt;尽量减少滚动，一屏展示所表现的内容;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=""&gt;技术层面&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;Phone &amp;amp; Watch￼代码复用￼￼￼&lt;/li&gt;
&lt;li&gt;URL Schema做跳转协议，使用Extension和App的交互接口相统一；&lt;/li&gt;
&lt;li&gt;与iPhone App同步，使用MMWormhole触发，如退出登录等；&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id="applewatchos20changes"&gt;Apple Watch OS 2.0 Changes&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;App无法与Watch Extension共享Framework；&lt;/li&gt;
&lt;li&gt;不在要求运行Watch App时必须与手机处于联通状态；&lt;/li&gt;
&lt;li&gt;MMWormhole仍然可用，但也可以使用WatchConnectivity替换（WatchConnectivity更推荐使用）；&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=""&gt;性能 &amp;amp; 优化&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;Network优化点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用压缩协议优化减少Request &amp;amp; Response&lt;/li&gt;
&lt;li&gt;隐藏不必要的JSON，需要什么给什么，不多不少&lt;/li&gt;
&lt;li&gt;发送对应的Watch大小的图片，38&amp;quot; or 42&amp;quot;&lt;/li&gt;
&lt;li&gt;对于List，针对Watch设定每一页的大小（经验值：5）&lt;/li&gt;
&lt;li&gt;对于UI团队提供的图片资源，图片尺寸要恰好适配Watch
&lt;ul&gt;
&lt;li&gt;App中使用setImageNamed&lt;/li&gt;
&lt;li&gt;Watch中使用setImageData &lt;code&gt;性能考虑&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;UI性能&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减少UI复杂度，大简至美&lt;/li&gt;
&lt;li&gt;WKInterfaceTable第一次加载的行数不要太多&lt;/li&gt;
&lt;li&gt;在RowController的willActivate方法中使用dispatch来请求图片&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;WatchOS 2.0 New Features&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Digital Crown&lt;/li&gt;
&lt;li&gt;ClockKit&lt;/li&gt;
&lt;li&gt;Animation (还有很多局限)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;WatchOS 3.0 New Features&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The Dock&lt;/li&gt;
&lt;li&gt;Stickiness&lt;/li&gt;
&lt;li&gt;Gesture support&lt;/li&gt;
&lt;li&gt;Direct access to the Digital Crown&lt;/li&gt;
&lt;li&gt;Improved notification support&lt;/li&gt;
&lt;li&gt;Extra large complications&lt;/li&gt;
&lt;li&gt;Workout app improvements&lt;/li&gt;
&lt;li&gt;Background App Refresh&lt;/li&gt;
&lt;li&gt;Faster interactions&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id="watchos"&gt;WatchOS开发中遇到的坑&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;证书签名： WatchApp没有Build Setting
&lt;ul&gt;
&lt;li&gt;解决办法： 手动修改project文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;WKInterfaceMap在1.0版本中内存泄露
&lt;ul&gt;
&lt;li&gt;最终在第一版本中暂时去掉了Map&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;XCode 6.2 中的CI（xcodebuild）不支持导出带有Watch的archive
&lt;ul&gt;
&lt;li&gt;XCode7解决了这个问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;建议使用XCode自动去管理证书&lt;/code&gt;&lt;/p&gt;
&lt;h5 id="watchos"&gt;Watch OS开发的优势&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;了解新技术，Watch会逼着你用StoryBoard&lt;/li&gt;
&lt;li&gt;Share Framework使用；&lt;/li&gt;
&lt;li&gt;Watch的一些新技术和架构，可以看出苹果对新技术的一些态度及思考
&lt;ul&gt;
&lt;li&gt;如WKInterfaceTable vs UITableView&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=""&gt;参考链接&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://developer.apple.com/watchos/human-interface-guidelines/overview/"&gt;watchOS Human Interface Guidelines&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ENJOY~&lt;/p&gt;
&lt;/div&gt;</content:encoded></item><item><title>XCode中iOS工程文件布局规范</title><description>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;以下是iOS工程中关于文件的布局规范参考链接，仅供备忘参考.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://limboy.me/ios/2013/09/23/build-ios-application.html"&gt;Limboy - iOS项目的目录结构和开发流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/TheAppLifeCycle/TheAppLifeCycle.html#//apple_ref/doc/uid/TP40007072-CH2-SW1"&gt;Apple iOS Dev Document - App Programming Guide for iOS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://calvingit.gitbooks.io/appscomm-coding-guidelines-for-cocoa/content/Xcode_Project.html"&gt;乐源移动开发团队 iOS开发规范.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://zh-google-styleguide.readthedocs.org/en/latest/google-objc-styleguide/contents/"&gt;Google开源项目风格指南 - Objective-C风格指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/raywenderlich/objective-c-style-guide"&gt;From Github Someone's project.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ENJOY~&lt;/p&gt;
&lt;/div&gt;</description><link>http://localhost:2368/2017/02/07/xcodezhong-iosgong-cheng-wen-jian-bu-ju-gui-fan/</link><guid isPermaLink="false">5a702c40f2c769befd9f2f21</guid><category>xCode</category><category>iOS</category><category>技术</category><dc:creator>Mark Chen</dc:creator><pubDate>Tue, 07 Feb 2017 03:04:46 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;以下是iOS工程中关于文件的布局规范参考链接，仅供备忘参考.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://limboy.me/ios/2013/09/23/build-ios-application.html"&gt;Limboy - iOS项目的目录结构和开发流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/TheAppLifeCycle/TheAppLifeCycle.html#//apple_ref/doc/uid/TP40007072-CH2-SW1"&gt;Apple iOS Dev Document - App Programming Guide for iOS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://calvingit.gitbooks.io/appscomm-coding-guidelines-for-cocoa/content/Xcode_Project.html"&gt;乐源移动开发团队 iOS开发规范.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://zh-google-styleguide.readthedocs.org/en/latest/google-objc-styleguide/contents/"&gt;Google开源项目风格指南 - Objective-C风格指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/raywenderlich/objective-c-style-guide"&gt;From Github Someone's project.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ENJOY~&lt;/p&gt;
&lt;/div&gt;</content:encoded></item><item><title>iOS-LZMA类压缩算法使用</title><description>&lt;div class="kg-card-markdown"&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;LZMA&lt;/strong&gt;（&lt;a href="https://zh.wikipedia.org/w/index.php?title=Abraham_Lempel&amp;amp;action=edit&amp;amp;redlink=1"&gt;Lempel&lt;/a&gt;-&lt;a href="https://zh.wikipedia.org/w/index.php?title=Jacob_Ziv&amp;amp;action=edit&amp;amp;redlink=1"&gt;Ziv&lt;/a&gt;-&lt;a href="https://zh.wikipedia.org/wiki/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E9%93%BE"&gt;Markov chain&lt;/a&gt;-&lt;a href="https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95"&gt;Algorithm&lt;/a&gt;的缩写）是2001年以来得到发展的一个&lt;a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9"&gt;数据压缩&lt;/a&gt;算法，它用于&lt;a href="https://zh.wikipedia.org/wiki/7-Zip"&gt;7-Zip&lt;/a&gt;归档工具中的&lt;a href="https://zh.wikipedia.org/wiki/7z"&gt;7z&lt;/a&gt;格式和 &lt;a href="https://zh.wikipedia.org/wiki/Unix-like"&gt;Unix-like&lt;/a&gt; 下的 &lt;a href="https://zh.wikipedia.org/wiki/Xz"&gt;xz&lt;/a&gt; 格式。它使用类似于&lt;a href="https://zh.wikipedia.org/wiki/LZ77%E4%B8%8ELZ78"&gt;LZ77&lt;/a&gt;的&lt;a href="https://zh.wikipedia.org/w/index.php?title=%E5%AD%97%E5%85%B8%E7%BC%96%E7%A0%81&amp;amp;action=edit&amp;amp;redlink=1"&gt;字典编码&lt;/a&gt;机制，在一般的情况下压缩率比&lt;a href="https://zh.wikipedia.org/wiki/Bzip2"&gt;bzip2&lt;/a&gt;为高，用于压缩的字典文件大小可达4GB。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://zh.wikipedia.org/wiki/C%2B%2B"&gt;C++&lt;/a&gt;语言写成的LZMA&lt;a href="https://zh.wikipedia.org/wiki/%E5%BC%80%E6%94%BE%E6%BA%90%E7%A0%81"&gt;开放源码&lt;/a&gt;压缩库使用了&lt;a href="https://zh.wikipedia.org/wiki/%E5%8C%BA%E9%97%B4%E7%BC%96%E7%A0%81"&gt;区间编码&lt;/a&gt;支持的&lt;a href="https://zh.wikipedia.org/wiki/LZ77%E4%B8%8ELZ78"&gt;LZ77&lt;/a&gt;改进压缩算法以及特殊的用于二进制的预处理程序。LZMA 对数据流、重复序列大小以及重续序列位置单独进行了压缩。LZMA支持几种&lt;a href="https://zh.wikipedia.org/w/index.php?title=%E6%95%A3%E5%88%97%E9%93%BE&amp;amp;action=edit&amp;amp;redlink=1"&gt;散列链&lt;/a&gt;变体、&lt;a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91"&gt;二叉树&lt;/a&gt;以及&lt;a href="https://zh.wikipedia.org/wiki/%E5%9F%BA%E6%95%B0%E6%A0%91"&gt;基数树&lt;/a&gt;作为它的字典查找算法基础。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="lzma"&gt;LZMA算法引入&lt;/h2&gt;&lt;/div&gt;</description><link>http://localhost:2368/2016/12/18/ios-lzmalei-ya-suo-suan-fa-shi-yong/</link><guid isPermaLink="false">5a702c40f2c769befd9f2f1d</guid><category>iOS</category><category>技术</category><category>技术调研</category><dc:creator>Mark Chen</dc:creator><pubDate>Sun, 18 Dec 2016 04:49:33 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;LZMA&lt;/strong&gt;（&lt;a href="https://zh.wikipedia.org/w/index.php?title=Abraham_Lempel&amp;amp;action=edit&amp;amp;redlink=1"&gt;Lempel&lt;/a&gt;-&lt;a href="https://zh.wikipedia.org/w/index.php?title=Jacob_Ziv&amp;amp;action=edit&amp;amp;redlink=1"&gt;Ziv&lt;/a&gt;-&lt;a href="https://zh.wikipedia.org/wiki/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E9%93%BE"&gt;Markov chain&lt;/a&gt;-&lt;a href="https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95"&gt;Algorithm&lt;/a&gt;的缩写）是2001年以来得到发展的一个&lt;a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9"&gt;数据压缩&lt;/a&gt;算法，它用于&lt;a href="https://zh.wikipedia.org/wiki/7-Zip"&gt;7-Zip&lt;/a&gt;归档工具中的&lt;a href="https://zh.wikipedia.org/wiki/7z"&gt;7z&lt;/a&gt;格式和 &lt;a href="https://zh.wikipedia.org/wiki/Unix-like"&gt;Unix-like&lt;/a&gt; 下的 &lt;a href="https://zh.wikipedia.org/wiki/Xz"&gt;xz&lt;/a&gt; 格式。它使用类似于&lt;a href="https://zh.wikipedia.org/wiki/LZ77%E4%B8%8ELZ78"&gt;LZ77&lt;/a&gt;的&lt;a href="https://zh.wikipedia.org/w/index.php?title=%E5%AD%97%E5%85%B8%E7%BC%96%E7%A0%81&amp;amp;action=edit&amp;amp;redlink=1"&gt;字典编码&lt;/a&gt;机制，在一般的情况下压缩率比&lt;a href="https://zh.wikipedia.org/wiki/Bzip2"&gt;bzip2&lt;/a&gt;为高，用于压缩的字典文件大小可达4GB。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://zh.wikipedia.org/wiki/C%2B%2B"&gt;C++&lt;/a&gt;语言写成的LZMA&lt;a href="https://zh.wikipedia.org/wiki/%E5%BC%80%E6%94%BE%E6%BA%90%E7%A0%81"&gt;开放源码&lt;/a&gt;压缩库使用了&lt;a href="https://zh.wikipedia.org/wiki/%E5%8C%BA%E9%97%B4%E7%BC%96%E7%A0%81"&gt;区间编码&lt;/a&gt;支持的&lt;a href="https://zh.wikipedia.org/wiki/LZ77%E4%B8%8ELZ78"&gt;LZ77&lt;/a&gt;改进压缩算法以及特殊的用于二进制的预处理程序。LZMA 对数据流、重复序列大小以及重续序列位置单独进行了压缩。LZMA支持几种&lt;a href="https://zh.wikipedia.org/w/index.php?title=%E6%95%A3%E5%88%97%E9%93%BE&amp;amp;action=edit&amp;amp;redlink=1"&gt;散列链&lt;/a&gt;变体、&lt;a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91"&gt;二叉树&lt;/a&gt;以及&lt;a href="https://zh.wikipedia.org/wiki/%E5%9F%BA%E6%95%B0%E6%A0%91"&gt;基数树&lt;/a&gt;作为它的字典查找算法基础。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="lzma"&gt;LZMA算法引入&lt;/h2&gt;
&lt;p&gt;对于数据传输，传输时间和传输质量是主要的两个参考维度。对于传输时间的压缩，数据压缩又是一个很好地可选项。目前正在处理蓝牙BLE（&lt;strong&gt;Bluetooth low energy&lt;/strong&gt; (&lt;strong&gt;Bluetooth LE&lt;/strong&gt;, &lt;strong&gt;BLE&lt;/strong&gt;, marketed as &lt;strong&gt;Bluetooth Smart&lt;/strong&gt;[&lt;a href="https://en.wikipedia.org/wiki/Bluetooth_low_energy#cite_note-1"&gt;1]&lt;/a&gt;)）调试，其中数据传输过程中，发现由于速度限制，传输时间较长，为了缩短传输时间，想利用压缩算法对所要传输的数据进行压缩处理后再进行传输，压缩完成之后再进行传输，以提高传输效率及节省传输时间。经过查阅各种资料，初步使用LZMA压缩算法进行压缩。&lt;/p&gt;
&lt;p&gt;之所以选择&lt;a href="https://zh.wikipedia.org/wiki/LZMA"&gt;LZMA&lt;/a&gt;算法进行压缩处理，原因有以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开源&lt;/li&gt;
&lt;li&gt;iOS &amp;amp; Android平台均支持，可夸平台使用&lt;/li&gt;
&lt;li&gt;使用广泛稳定，7zip即采用该算法及衍生算法&lt;/li&gt;
&lt;li&gt;压缩效率较高&lt;/li&gt;
&lt;li&gt;多线程支持&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="ioslzma"&gt;iOS引入使用LZMA压缩算法方法&lt;/h2&gt;
&lt;h4 id="1lzma"&gt;选项1. 利用系统默认支持的LZMA压缩算法&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;The libcompression library provides an API for two styles of data compression:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Block compression, where all of the input data is compressed or decompressed by one call to the compression or decompression function.&lt;/li&gt;
&lt;li&gt;Streaming compression, where the compression or decompression function is called repeatedly to compress or decompress data from a source buffer to a destination buffer. Between calls, processed data is moved out of the destination buffer and new data is loaded into the source buffer.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;Apple提供了一套通用的无损压缩算法，其中就支持LZMA、LZMA2压缩.&lt;/p&gt;
&lt;h5 id=""&gt;支持的压缩类型&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;Block Compression&lt;/li&gt;
&lt;li&gt;Stream Compression&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=""&gt;支持的平台如下：&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;iOS 9.0+&lt;/li&gt;
&lt;li&gt;macOS 10.11+&lt;/li&gt;
&lt;li&gt;tvOS 9.0+&lt;/li&gt;
&lt;li&gt;watchOS 2.0+&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=""&gt;支持的压缩算法&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;COMPRESSION_LZ4&lt;/li&gt;
&lt;li&gt;COMPRESSION_ZLIB&lt;/li&gt;
&lt;li&gt;COMPRESSION_LZMA&lt;/li&gt;
&lt;li&gt;COMPRESSION_LZFSE&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;提供的代码调用很简单，我根据我的需要，所使用的方法如下：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://developer.apple.com/reference/compression/1480986-compression_encode_buffer"&gt;压缩算法&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;size_t compression_encode_buffer(uint8_t *restrict dst_buffer, size_t dst_size, const uint8_t *restrict src_buffer, size_t src_size, void *restrict scratch_buffer, compression_algorithm algorithm);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href="https://developer.apple.com/reference/compression/1481000-compression_decode_buffer?language=objc"&gt;解压方法&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;size_t compression_decode_buffer(uint8_t *restrict dst_buffer, size_t dst_size, const uint8_t *restrict src_buffer, size_t src_size, void *restrict scratch_buffer, compression_algorithm algorithm);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;详细的调用代码如下&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objective-c"&gt;- (void)testLZMA {
	// Data source file path.
	NSString *sourceFilePath = [NSString stringWithFormat:@&amp;quot;%@/source_data.txt&amp;quot;, SYSTEM_DOCUMENT_PATH];
	// Compressed file path.
	NSString *zipFilePath = [NSString stringWithFormat:@&amp;quot;%@/compressed_data.7z&amp;quot;, SYSTEM_DOCUMENT_PATH];
    
    NSData *fileData = [NSData dataWithContentsOfFile:sourceFilePath];
    DDLogDebug(@&amp;quot;Before compress: %ld bytes&amp;quot;, fileData.length);
    
    uint8_t dstBuffer[fileData.length];
    memset(dstBuffer, 0, fileData.length);
    
    size_t compressResultLength = compression_encode_buffer(dstBuffer, fileData.length, [fileData bytes], fileData.length, NULL, COMPRESSION_LZMA);
    if(compressResultLength &amp;gt; 0) {
        NSData *dataAfterCompress = [NSData dataWithBytes:dstBuffer length:compressResultLength];
        DDLogDebug(@&amp;quot;Compress successfully. After compress：%ld bytes&amp;quot;, dataAfterCompress.length;
        // Write compressed data into file.
        [dataAfterCompress writeToFile:zipFilePath atomically:YES];
    } else {
        DDLogError(@&amp;quot;Compress FAILED!!!&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该方法集成使用起来非常简单，对于基本的压缩需求足够可以满足，且不会对App的大小造成太大影响，不会很大增加，如果没有特殊需求，该方法是首选。&lt;/p&gt;
&lt;h4 id="2lzmasdkojbcframework"&gt;选项2. 集成第三方库&lt;a href="https://github.com/ChenJian345/LzmaSDKOjbcFramework"&gt;LzmaSDKOjbcFramework&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;这是我最先走的一条路，通过查阅相关资料，引入相关的开源库，自己实现了一个支持LZMA压缩算法的iOS工程用于Build Framework，现已开源到Github上，即&lt;a href="https://github.com/ChenJian345/LzmaSDKOjbcFramework"&gt;LzmaSDKOjbcFramework&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;虽然最终采用的方案一，但在制作&lt;a href="https://github.com/ChenJian345/LzmaSDKOjbcFramework"&gt;LzmaSDKOjbcFramework&lt;/a&gt;过程中，也有一些收获，现分享给大家，愿对大家有些帮助。&lt;/p&gt;
&lt;p&gt;最初找到的LZMA的iOS支持库是 &lt;a href="https://github.com/OlehKulykov/LzmaSDKObjC"&gt;LzmaSDKObjC&lt;/a&gt;，但是这个库在引入开发工程中过程中，由于使用的cocoaPods， 必须使用&lt;code&gt;use_frameworks!&lt;/code&gt; 才可以使用，但是由于podfile中存在其他引入的第三方库，这些库不适用&lt;code&gt;use_frameworks!&lt;/code&gt;限制。&lt;/p&gt;
&lt;p&gt;此时陷入两难境地，使用&lt;code&gt;use_frameworks!&lt;/code&gt;导致其他不支持framework的库不可用，如果不使用，LzmaSDKObjC则会报如下错误:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Codec was not compiled in or stripped by static linking. 
Make sure you are using 'use_frameworks!' and/or dynamic linking ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而CocoaPods又不支持针对某一第三方库来规定使用&lt;code&gt;use_frameworks!&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;既然这样，我打算自己创建一个iOS Framework工程开源，供团队内部及所有人方便使用。&lt;/p&gt;
&lt;h4 id=""&gt;使用步骤&lt;/h4&gt;
&lt;h5 id="step1"&gt;Step1&lt;/h5&gt;
&lt;p&gt;在&lt;a href="https://github.com/ChenJian345/LzmaSDKOjbcFramework"&gt;LzmaSDKOjbcFramework&lt;/a&gt;工程目录下，由于工程需要&lt;code&gt;Inlineobjc&lt;/code&gt;库，所以使用CocoaPods进行安装，命令行执行如下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pod install
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id="step2"&gt;Step2&lt;/h5&gt;
&lt;p&gt;打开workspace工程文件，xCode中看到的内容如下：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://camo.githubusercontent.com/184a2b2cee82d0a9ccb5e542ad7d7c2ab131e25c/687474703a2f2f7777312e73696e61696d672e636e2f6c617267652f303036744e6337396a773166613135326c626d316e6a333069653074716163702e6a7067"&gt;&lt;img src="https://camo.githubusercontent.com/184a2b2cee82d0a9ccb5e542ad7d7c2ab131e25c/687474703a2f2f7777312e73696e61696d672e636e2f6c617267652f303036744e6337396a773166613135326c626d316e6a333069653074716163702e6a7067" alt="img"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h5 id="step3"&gt;Step3&lt;/h5&gt;
&lt;p&gt;Archive工程并导出&lt;code&gt;LzmaSDKObjC.framework&lt;/code&gt;文件到所需的工程路径下使用，使用如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-objc"&gt;- (void)testLZMA {
	NSString *sourceFilePath = [NSString stringWithFormat:@&amp;quot;%@/source_data.txt&amp;quot;, SYSTEM_DOCUMENT_PATH];
    NSString *zipFilePath = [NSString stringWithFormat:@&amp;quot;%@/compressed_data.7z&amp;quot;, SYSTEM_DOCUMENT_PATH];
	DDLogDebug(@&amp;quot;\n\n ********** LZMA ********** \nSrc File: %@\n7Zip File:%@\n\n&amp;quot;, sourceFilePath, zipFilePath);
    // Create writer
    LzmaSDKObjCWriter * writer = [[LzmaSDKObjCWriter alloc] initWithFileURL:[NSURL fileURLWithPath:zipFilePath]];
    
    // Add file data's or paths
//    [writer addData:[NSData ...] forPath:@&amp;quot;MyArchiveFileName.txt&amp;quot;]; // Add file data
    [writer addPath:sourceFilePath forPath:@&amp;quot;.&amp;quot;]; // Add file at path
//    [writer addPath:@&amp;quot;/Path/SomeDirectory&amp;quot; forPath:@&amp;quot;SomeDirectory&amp;quot;]; // Recursively add directory with all contents
    
    // Setup writer
    writer.delegate = self; // Track progress
//    writer.passwordGetter = ^NSString*(void) { // Password getter
//        return @&amp;quot;1234&amp;quot;;
//    };
    
    // Optional settings
    writer.method = LzmaSDKObjCMethodLZMA; // or LzmaSDKObjCMethodLZMA
    writer.solid = YES;
    writer.compressionLevel = 7;
    writer.encodeContent = YES;
    writer.encodeHeader = YES;
    writer.compressHeader = YES;
    writer.compressHeaderFull = YES;
    writer.writeModificationTime = NO;
    writer.writeCreationTime = NO;
    writer.writeAccessTime = NO;
    
    // Open archive file
    NSError * error = nil;
    [writer open:&amp;amp;error];
    
    // Write archive within current thread
    [writer write];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该方式的优点是支持的可选项较广，可以广泛的定制各种参数，但缺点是导入库后会导致应用包的体积变大，所以需要根据自身需求来选择。&lt;/p&gt;
&lt;p&gt;ENJOY.&lt;/p&gt;
&lt;/div&gt;</content:encoded></item><item><title>地图导航SDK调研</title><description>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;文 · Mark&lt;/p&gt;
&lt;p&gt;百度地图SDK&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;免费&lt;/li&gt;
&lt;li&gt;国内地图SDK，国内使用普遍&lt;/li&gt;
&lt;li&gt;支持路线规划，不支持Turn-by-Turn导航 Pass&lt;/li&gt;
&lt;li&gt;国际化很难(据悉在扩展海外国际化，时间不可预估) Pass&lt;/li&gt;
&lt;li&gt;支持iOS/Android/Web;&lt;/li&gt;
&lt;li&gt;提供离线地图;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;百度导航SDK&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;免费&lt;/li&gt;
&lt;li&gt;国内地图SDK，国内使用普遍&lt;/li&gt;
&lt;li&gt;支持路线规划，支持Turn-by-Turn导航，但没有实时导航回调接口 Pass&lt;/li&gt;
&lt;li&gt;国内使用普遍，国际化很难(据悉在扩展海外国际化，时间不可预估) Pass&lt;/li&gt;
&lt;li&gt;支持iOS/Android/Web;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;百度导航HUD SDK&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;免费&lt;/li&gt;
&lt;li&gt;国内地图SDK，国内使用普遍&lt;/li&gt;
&lt;li&gt;支持路线规划，支持Turn-by-Turn导航，但没有实时导航回调接口 Pass&lt;/li&gt;
&lt;li&gt;国际化很难(据悉在扩展海外国际化，时间不可预估) Pass&lt;/li&gt;
&lt;li&gt;必须依赖 百度导航（非 百度地图）&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</description><link>http://localhost:2368/2016/12/08/untitled/</link><guid isPermaLink="false">5a702c40f2c769befd9f2f1a</guid><category>技术</category><category>技术调研</category><dc:creator>Mark Chen</dc:creator><pubDate>Thu, 08 Dec 2016 07:26:52 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;文 · Mark&lt;/p&gt;
&lt;p&gt;百度地图SDK&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;免费&lt;/li&gt;
&lt;li&gt;国内地图SDK，国内使用普遍&lt;/li&gt;
&lt;li&gt;支持路线规划，不支持Turn-by-Turn导航 Pass&lt;/li&gt;
&lt;li&gt;国际化很难(据悉在扩展海外国际化，时间不可预估) Pass&lt;/li&gt;
&lt;li&gt;支持iOS/Android/Web;&lt;/li&gt;
&lt;li&gt;提供离线地图;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;百度导航SDK&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;免费&lt;/li&gt;
&lt;li&gt;国内地图SDK，国内使用普遍&lt;/li&gt;
&lt;li&gt;支持路线规划，支持Turn-by-Turn导航，但没有实时导航回调接口 Pass&lt;/li&gt;
&lt;li&gt;国内使用普遍，国际化很难(据悉在扩展海外国际化，时间不可预估) Pass&lt;/li&gt;
&lt;li&gt;支持iOS/Android/Web;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;百度导航HUD SDK&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;免费&lt;/li&gt;
&lt;li&gt;国内地图SDK，国内使用普遍&lt;/li&gt;
&lt;li&gt;支持路线规划，支持Turn-by-Turn导航，但没有实时导航回调接口 Pass&lt;/li&gt;
&lt;li&gt;国际化很难(据悉在扩展海外国际化，时间不可预估) Pass&lt;/li&gt;
&lt;li&gt;必须依赖 百度导航（非 百度地图）App Pass&lt;/li&gt;
&lt;li&gt;支持iOS/Android/Web;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;高德地图SDK&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;免费&lt;/li&gt;
&lt;li&gt;国内地图SDK，国内使用普遍&lt;/li&gt;
&lt;li&gt;支持路线规划，不支持Turn-by-Turn导航 Pass&lt;/li&gt;
&lt;li&gt;使用国际化很难 Pass&lt;/li&gt;
&lt;li&gt;支持iOS/Android/Web;&lt;/li&gt;
&lt;li&gt;提供离线地图;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;高德导航SDK&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;免费&lt;/li&gt;
&lt;li&gt;国内地图SDK，国内使用普遍&lt;/li&gt;
&lt;li&gt;支持路线规划，支持Turn-by-Turn导航，但没有实时导航回调接口 Pass&lt;/li&gt;
&lt;li&gt;使用国际化很难(据悉在扩展海外国际化，时间不可预估) Pass&lt;/li&gt;
&lt;li&gt;支持iOS/Android/Web;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;腾讯地图SDK&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不想多说，考虑其他的吧&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;360地图SDK&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更不想多说，竟然没有iOS SDK，考虑其他的吧&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Scout&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;收费，试用免费，收费计划；&lt;/li&gt;
&lt;li&gt;提供路线规划，支持Turn-by-Turn导航 很慢，且非毕现不成功&lt;/li&gt;
&lt;li&gt;使用厂商Strava、Smart等Showcase;&lt;/li&gt;
&lt;li&gt;支持iOS/Android/Web;&lt;/li&gt;
&lt;li&gt;提供离线地图;&lt;/li&gt;
&lt;li&gt;海外产品，国际化支持，skobbler&lt;/li&gt;
&lt;li&gt;提供路线规划；&lt;/li&gt;
&lt;li&gt;提供Turn-by-Turn导航功能（但国内不好用）; Pass&lt;/li&gt;
&lt;li&gt;国内加载速度慢，真的是奇慢！&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Here&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;收费，支持试用&lt;/li&gt;
&lt;li&gt;前Nokia旗下企业&lt;/li&gt;
&lt;li&gt;提供离线地图&lt;/li&gt;
&lt;li&gt;提供路线规划功能, 提供Turn-by-Turn导航功能&lt;/li&gt;
&lt;li&gt;支持Android/iOS/Web&lt;/li&gt;
&lt;li&gt;国际化支持&lt;/li&gt;
&lt;li&gt;海外SDK&lt;/li&gt;
&lt;li&gt;只支持Walking和Driving导航，不提供骑行导航&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Mapbox&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;收费，支持试用&lt;/li&gt;
&lt;li&gt;移动端导航申请页面&lt;/li&gt;
&lt;li&gt;提供离线地图&lt;/li&gt;
&lt;li&gt;国际化支持&lt;/li&gt;
&lt;li&gt;支持Android/iOS/Web等&lt;/li&gt;
&lt;li&gt;海外SDK&lt;/li&gt;
&lt;li&gt;提供路线规划，不支持Turn-by-Turn导航功能Pass（据悉尚在开发过程中）&lt;/li&gt;
&lt;li&gt;国内加载速度慢，且路线规划非毕现不成功；&lt;/li&gt;
&lt;li&gt;支持骑行路线规划&lt;/li&gt;
&lt;li&gt;Showcases&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Apple MapKit&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;免费&lt;/li&gt;
&lt;li&gt;不提供离线地图&lt;/li&gt;
&lt;li&gt;可提供国际化支持&lt;/li&gt;
&lt;li&gt;支持iOS，不支Android Pass&lt;/li&gt;
&lt;li&gt;不提供离线地图&lt;/li&gt;
&lt;li&gt;提供路线规划，不支持Turn-by-Turn导航功能;&lt;/li&gt;
&lt;li&gt;国内加载速度快&lt;/li&gt;
&lt;li&gt;不支持骑行路线规划&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;GoogleMap&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一定数量内免费，频繁请求后存在限制&lt;/li&gt;
&lt;li&gt;国际化支持良好&lt;/li&gt;
&lt;li&gt;Android/iOS SDK不提供路线规划及导航支持，需通过网络请求来获取；&lt;/li&gt;
&lt;li&gt;稳定&lt;/li&gt;
&lt;li&gt;不提供离线地图&lt;/li&gt;
&lt;li&gt;提供路线规划，不支持Turn-by-Turn导航功能;&lt;/li&gt;
&lt;li&gt;支持骑行路线规划&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Q&amp;amp;A相关链接&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;getting-routes-and-turn-by-turn-navigation-in-an-iphone-app&lt;/li&gt;
&lt;li&gt;turn-by-turn-navigation-for-our-driver-app&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/20905797/google-maps-ios-sdk-getting-directions-between-2-locations"&gt;google-maps-ios-sdk-getting-directions-between-2-locations&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;2016-5-5 On the Train to Shanghai.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;</content:encoded></item><item><title>Protobuf初探</title><description>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;文 · Mark&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于软件开发者，尤其是移动端（Android &amp;amp; iOS）开发者来说，XML和JSON两种文件传输格式并不陌生，尤其是JSON，仅在上述两种开发领域中就广泛应用。随之而来的，是各种JSON的解析库，此文中，笔者不想介绍各个平台丰富多彩的JSON解析库，而是想和大家分享发现的一种新的文件传输格式，Protobuf。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="protobuf"&gt;Protobuf是什么鬼&lt;/h3&gt;
&lt;p&gt;初次相遇Protobuf，这是我的第一反应。那么Protobuf到底是什么鬼？&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;Protobuf是一种灵活高效的、用于跨平台数据通信的数据传输格式，全称Protocol Buffers，类似XML和JSON。下面，我们先看一个protobuf的简单例子，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;message Person {
  required string name = 1;
  required int32 id = 2;
  optional string email = 3;

  enum PhoneType {
    MOBILE = 0;
    HOME = 1;
    WORK&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description><link>http://localhost:2368/2016/12/08/protobufchu-tan/</link><guid isPermaLink="false">5a702c40f2c769befd9f2f15</guid><category>Android</category><category>iOS</category><category>C++</category><category>技术调研</category><dc:creator>Mark Chen</dc:creator><pubDate>Thu, 08 Dec 2016 07:23:20 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;文 · Mark&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于软件开发者，尤其是移动端（Android &amp;amp; iOS）开发者来说，XML和JSON两种文件传输格式并不陌生，尤其是JSON，仅在上述两种开发领域中就广泛应用。随之而来的，是各种JSON的解析库，此文中，笔者不想介绍各个平台丰富多彩的JSON解析库，而是想和大家分享发现的一种新的文件传输格式，Protobuf。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="protobuf"&gt;Protobuf是什么鬼&lt;/h3&gt;
&lt;p&gt;初次相遇Protobuf，这是我的第一反应。那么Protobuf到底是什么鬼？&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;Protobuf是一种灵活高效的、用于跨平台数据通信的数据传输格式，全称Protocol Buffers，类似XML和JSON。下面，我们先看一个protobuf的简单例子，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;message Person {
  required string name = 1;
  required int32 id = 2;
  optional string email = 3;

  enum PhoneType {
    MOBILE = 0;
    HOME = 1;
    WORK = 2;
  }

  message PhoneNumber {
    required string number = 1;
    optional PhoneType type = 2 [default = HOME];
  }

  repeated PhoneNumber phone = 4;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实，Protobuf出身名门Google，采用C++实现，在Google内部已应用多年，并有与平台无关，与语言无关，可高效序列化传输等特点，当前最新的Protobuf版本为3.0。&lt;/p&gt;
&lt;h3 id=""&gt;发展现状&lt;/h3&gt;
&lt;p&gt;Google最初为了解决统一内部传输问题，自己制定了一套高效的数据传输格式定义协议，即Protobuf，并逐步在Google内部项目中使用。随着Protobuf在Google内部被越来越多的项目所采用，本身性能也在逐步被改良提高。&lt;br&gt;
在2008年7月7日，将Protobuf贡献给开源社区进行了开源，目前，Github上可以找到相应源码。&lt;br&gt;
目前Protobuf不仅在Google内部广泛使用，在RPC通信中广泛使用，在国外，Facebook在部分项目中采用了Protobuf作为通信的编解码工具。在国内，Protobuf在百度，腾讯TDW平台，阿里巴巴部分项目中，也被作为基础库充分利用。除此之外，还有一些其他公司也在使用Protobuf左右数据通信的基础类库。&lt;br&gt;
但是，在移动平台开发中，应用还不是很广泛。&lt;/p&gt;
&lt;h3 id=""&gt;支持的语言&lt;/h3&gt;
&lt;p&gt;Google官方对Protobuf提供C++、Java、Python三种语言提供官方支持。对于proto3，还支持Go、JavaNano、Ruby和C#。当然，几乎所有当前的编程语言，都有相应的Protobuf支持库，所以，对于Protobuf的支持的语言还是很全面的。&lt;/p&gt;
&lt;h3 id=""&gt;工作原理&lt;/h3&gt;
&lt;p&gt;使用Protobuf，只需要根据Protobuf的语法规范，定义需要传输的数据内容格式，定义Protobuf的文件为.proto文件，例如，定义一个具有name和email字段的Person信息对象时，.proto文件内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;message Person {
    required string name = 1;
    optional string email = 2;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义好数据格式之后，我们只需要使用我们需要的语言的Protobuf编译器对.proto文件进行编译即可，输出我们需要的对应语言的Model定义类源码文件，在该文件中会自动生成序列化方法，getter和setter方法等，例如对于C++语言，上述.proto文件编译命令为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;protoc --cpp_out=cpp_dir person.proto
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;protobuf编译器根据.proto文件对Message Person定义，编译生成对应的源码文件，包含.h、.cpp文件，其中.h文件如下，下面我们就看一下具体生成了哪些内容。&lt;/p&gt;
&lt;p&gt;基本Person类框架，包括Person对象的构建函数，析构函数，等于运算符重载，Descriptor函数等；&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  class Person;
...
  class Person : public ::google::protobuf::Message {
  public:
    Person();
    virtual ~Person();

    Person(const Person&amp;amp; from);

    inline Person&amp;amp; operator=(const Person&amp;amp; from) {
      CopyFrom(from);
      return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet&amp;amp; unknown_fields() const {
      return _unknown_fields_;
    }

    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
      return &amp;amp;_unknown_fields_;
    }

    static const ::google::protobuf::Descriptor* descriptor();
    static const Person&amp;amp; default_instance();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由剩余部分代码可以清晰的看出，Protobuf编译器已经帮我们生成好了Model构建的方法，各属性的getter、setter方法、以及序列化方法，在后续过程中，我们只需要调用相关方法即可；&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    // required string name = 1;
    inline bool has_name() const;
    inline void clear_name();
    static const int kNameFieldNumber = 1;
    inline const ::std::string&amp;amp; name() const;
    inline void set_name(const ::std::string&amp;amp; value);
    inline void set_name(const char* value);
    inline void set_name(const char* value, size_t size);
    inline ::std::string* mutable_name();
    inline ::std::string* release_name();
    inline void set_allocated_name(::std::string* name);

    // optional string email = 2;
    inline bool has_email() const;
    inline void clear_email();
    static const int kEmailFieldNumber = 2;
    inline const ::std::string&amp;amp; email() const;
    inline void set_email(const ::std::string&amp;amp; value);
    inline void set_email(const char* value);
    inline void set_email(const char* value, size_t size);
    inline ::std::string* mutable_email();
    inline ::std::string* release_email();
    inline void set_allocated_email(::std::string* email);

    // @@protoc_insertion_point(class_scope:Person)
  private:
    inline void set_has_name();
    inline void clear_has_name();
    inline void set_has_email();
    inline void clear_has_email();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么，我们通过protobuf编译器protoc编译出了我们需要的Model定义类Person.h和Person.cpp，剩下的工作只需要调用进行使用了。下面我们简单调用一下我们生成的相应Person Model代码。&lt;br&gt;
调用代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;fstream&amp;gt;
#include &amp;lt;string&amp;gt;

#include &amp;quot;person.pb.h&amp;quot;

using namespace std;


// Main function:  Reads the entire person info. from a file,
//   adds one person based on user input, then writes it back out to the same
//   file.
int main(int argc, char* argv[]) {
  // Verify that the version of the library that we linked against is
  // compatible with the version of the headers we compiled against.
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ...

  Person *person = new Person();
  person-&amp;gt;set_name(&amp;quot;Mark CJ&amp;quot;);
  person-&amp;gt;set_email(&amp;quot;markcjemail@google.com&amp;quot;);

  cout &amp;lt;&amp;lt; &amp;quot;Person Info : name &amp;quot; &amp;lt;&amp;lt; person.name() &amp;lt;&amp;lt; &amp;quot;, email : &amp;quot; &amp;lt;&amp;lt; person.email() &amp;lt;&amp;lt; endl;

  {
    // Read the existing person object.
    fstream input(argv[1], ios::in | ios::binary);
    if (!input) {
      cout &amp;lt;&amp;lt; argv[1] &amp;lt;&amp;lt; &amp;quot;: File not found.  Creating a new file.&amp;quot; &amp;lt;&amp;lt; endl;
    } else if (!person.ParseFromIstream(&amp;amp;input)) {
      cerr &amp;lt;&amp;lt; &amp;quot;Failed to parse person object.&amp;quot; &amp;lt;&amp;lt; endl;
      return -1;
    }
  }

 ...

  {
    // Write the new person object back to disk.
    fstream output(argv[1], ios::out | ios::trunc | ios::binary);
    if (!person.SerializeToOstream(&amp;amp;output)) {
      cerr &amp;lt;&amp;lt; &amp;quot;Failed to write person object.&amp;quot; &amp;lt;&amp;lt; endl;
      return -1;
    }
  }

  // Optional:  Delete all global objects allocated by libprotobuf.
  google::protobuf::ShutdownProtobufLibrary();

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="protobuf"&gt;Protobuf优势&lt;/h3&gt;
&lt;p&gt;Protobuf是用于结构化数据串行化的灵活、高效、自动的方法，类似XML，不过它比XML更小、更快、也更简单。你可以定义自己的数据结构，然后使用代码生成器生成的代码来读写这个数据结构。你甚至可以在无需重新部署程序的情况下更新数据结构。&lt;/p&gt;
&lt;h3 id=""&gt;体积更小、速度更快&lt;/h3&gt;
&lt;p&gt;相对于XML，Protobuf只有XML文件的1/10到1/3大小。&lt;br&gt;
例如，当需要传输一个带有&lt;code&gt;name&lt;/code&gt;和&lt;code&gt;email&lt;/code&gt;字段的&lt;code&gt;Person&lt;/code&gt;对象信息时，使用XML格式如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;person&amp;gt;
    &amp;lt;name&amp;gt;John Doe&amp;lt;/name&amp;gt;
    &amp;lt;email&amp;gt;jdoe@example.com&amp;lt;/email&amp;gt;
&amp;lt;/person&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果剔除空格，该XML体积为69字节，会大概话费5000-10000 nm解析上述数据。&lt;br&gt;
而使用Protobuf的message形式，转为人类可读内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Textual representation of a protocol buffer.
# This is *not* the binary format used on the wire.
person {
    name: &amp;quot;John Doe&amp;quot;
    email: &amp;quot;jdoe@example.com&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但当上述Protobuf的Person信息转为二进制形式（Protobuf传输时使用二进制）时，约28字节，大概话费100-200nm解析使用。&lt;/p&gt;
&lt;p&gt;以下是针对于Protobuf及相关竞品做的一份性能测试&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;浅蓝色为序列化时间，深蓝色为反序列化时间&lt;/strong&gt;&lt;br&gt;
&lt;img src="https://camo.githubusercontent.com/75941272e9741d49d04f00337c367b78cdac4e80/68747470733a2f2f63686172742e676f6f676c65617069732e636f6d2f63686172743f6368743d626873266368733d36303078333734266368643d743a3234382c3433332c3433322c3530312c3532362c3635302c3539372c3732332c3739362c3733322c313137332c3931332c313238302c3838382c313431372c313435352c3838372c313035387c3339352c3633342c3638342c3637342c3830362c3639352c3735382c313038322c313035322c313134372c3731382c313137352c3830382c313233382c3735382c3733312c313332392c31323431266368636f3d3564393966392c346438396639266368646c703d7426636862683d313526636864733d302c3232393926636878723d312c302c3232393926636878743d792c78266368786c3d303a7c6a736f6e253246666173746a736f6e2532466461746162696e647c6a736f6e2d636f6c2532466a61636b736f6e2532466461746162696e647c7468726966747c666c6174627566666572737c63626f722532466a61636b736f6e25324261667465726275726e65722532466461746162696e647c7468726966742d636f6d706163747c736d696c652532466a61636b736f6e25324261667465726275726e65722532466461746162696e647c70726f746f6275667c63626f722d636f6c2532466a61636b736f6e2532466461746162696e647c6d73677061636b2532466461746162696e647c736d696c652d636f6c2532466a61636b736f6e2532466461746162696e647c6b72796f2d666c61742d7072657c6a736f6e2d6172726179253246666173746a736f6e2532466461746162696e647c6a736f6e25324664736c2d706c6174666f726d7c6673742d666c61742d7072657c6d696e69666965642d6a736f6e25324664736c2d706c6174666f726d7c70726f746f73747566667c636f6c666572" alt="序列号反序列化对比"&gt;&lt;/p&gt;
&lt;p&gt;内存占用情况对比&lt;br&gt;
&lt;img src="https://camo.githubusercontent.com/8e204e325f4d882d420e5ba4399f1b10da4c23ad/68747470733a2f2f63686172742e676f6f676c65617069732e636f6d2f63686172743f6368743d626873266368733d36303078333734266368643d743a3133322c3134362c3134382c3135302c3134392c3134382c3136352c3136352c3136352c3134372c3136332c3137382c3332372c3234312c3139372c3235322c3139372c3234367c38302c38372c39302c38392c39302c39322c38362c38362c38372c3130382c3131382c3131352c31302c39372c3135322c3130302c3135362c313531266368636f3d3564393966392c346438396639266368646c703d7426636862683d313526636864733d302c33393726636878723d312c302c33393726636878743d792c78266368786c3d303a7c63626f722532466a61636b736f6e25324261667465726275726e65722532466461746162696e647c6d696e69666965642d6a736f6e25324664736c2d706c6174666f726d7c736d696c652532466a61636b736f6e25324261667465726275726e65722532466461746162696e647c7468726966747c736d696c652532466a61636b736f6e2532466461746162696e647c786d6c2532466578692d6d616e75616c7c6a736f6e2d636f6c2532466a61636b736f6e2532466461746162696e647c6a736f6e2d6172726179253246666173746a736f6e2532466461746162696e647c7363616c612532467362696e6172797c736d696c652d636f6c2532466a61636b736f6e2532466461746162696e647c63626f722d636f6c2532466a61636b736f6e2532466461746162696e647c6673742d666c61742d7072657c7468726966742d636f6d706163747c70726f746f6275667c70726f746f73747566667c636f6c6665727c6d73677061636b2532466461746162696e647c6b72796f2d666c61742d707265" alt="内存占用对比"&gt;&lt;/p&gt;
&lt;h3 id=""&gt;书写简单、更少歧义&lt;/h3&gt;
&lt;p&gt;当编程输出Model内容时，采用C++，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cout &amp;lt;&amp;lt; &amp;quot;Name: &amp;quot; &amp;lt;&amp;lt; person.name() &amp;lt;&amp;lt; endl;
cout &amp;lt;&amp;lt; &amp;quot;E-mail: &amp;quot; &amp;lt;&amp;lt; person.email() &amp;lt;&amp;lt; endl;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但当采用XML，对获取到的Person信息进行解析时，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cout &amp;lt;&amp;lt; &amp;quot;Name: &amp;quot;
       &amp;lt;&amp;lt; person.getElementsByTagName(&amp;quot;name&amp;quot;)-&amp;gt;item(0)-&amp;gt;innerText()
       &amp;lt;&amp;lt; endl;
cout &amp;lt;&amp;lt; &amp;quot;E-mail: &amp;quot;
       &amp;lt;&amp;lt; person.getElementsByTagName(&amp;quot;email&amp;quot;)-&amp;gt;item(0)-&amp;gt;innerText()
       &amp;lt;&amp;lt; endl;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;相比于JSON，除了语义更简单之外，Protobuf中被编号的字段可以排除所谓的版本检查，保证无偿的向后兼容。&lt;br&gt;
由上面所述可见，我们也可以使用Protobuf中的&lt;code&gt;@required&lt;/code&gt;、&lt;code&gt;@optional&lt;/code&gt;、&lt;code&gt;@repeated&lt;/code&gt;等属性，将一些常识性的调试操作，转换为正式的拓展，比如将原来&lt;code&gt;@optional&lt;/code&gt;的字段内容转换为&lt;br&gt;
&lt;code&gt;@required&lt;/code&gt;的字段。&lt;/p&gt;
&lt;h3 id="protobuf"&gt;Protobuf劣势&lt;/h3&gt;
&lt;p&gt;虽然Protobuf的效率以及体积控制很出色，但是万物都有优点，也有缺点，当然Protobuf也不例外。&lt;/p&gt;
&lt;p&gt;相对于XML， Protobuf的功能略显简单，无法表达较为复杂的概念定义，所以，对于复杂的定义需求，无法有效的实现。&lt;/p&gt;
&lt;p&gt;由于XML在多行业中被广泛、长期的使用，所以，使用XML已经成为了部分行业的标准工具，而Protobuf只在Google内部使用较多，所以对于被更广泛的其他行业所使用，还有很长的路要走。&lt;br&gt;
为了缩减Protobuf的传输数据文件大小，也为了加快解析速度，Protobuf采用二进制格式进行存储，所以导致存储后或传输过程中的数据，对人类可读性差，不利于中间代码数据调试。&lt;/p&gt;
&lt;p&gt;和XML相比，Protobuf也适用描述标记语言的传输，比较适用于描述数据结构，而XML在这两方面，均可适用。&lt;/p&gt;
&lt;p&gt;而相对于JSON，Protobuf在序列化速度和反序列化速度方面还略有差距，这一点也是Protobuf需要补强的一部分。同时，在服务端和Web端数据通信中，JSON的使用广泛性还是要高于Protobuf，这也源于前端原生库及第三方库对JSON的有效支持，而Protobuf在Web端，还没有如此广泛的支持。&lt;/p&gt;
&lt;h3 id=""&gt;小结&lt;/h3&gt;
&lt;p&gt;以上只是对Protobuf的初探内容，本想找到一种可以替代JSON的解决方案，但是并不是完全没有收获，虽然现在Protobuf没有在移动端广泛应用，因为当前JSON的各项性能均与其类似，但是Protobuf有些设计思想还是可以供大家借鉴的。如果有朋友想深入了解，可以访问Google官网及查看相关源码，笔者文笔较差，欢迎批评指正，多多交流。&lt;/p&gt;
&lt;p&gt;在学习Protobuf的过程中，发现了一个名叫Protostuff的好东西，protostuff针对protobuf进行了部分优化，包括可选免去预编译等操作，初探比XML及JSON效率都要高效，有兴趣的朋友也可以深入了解一下。&lt;/p&gt;
&lt;/div&gt;</content:encoded></item><item><title>Homebrew常用Cheatsheet</title><description>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="homebrew"&gt;安装Homebrew&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;ruby -e &amp;quot;$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=""&gt;搜索&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;brew search &amp;lt;target-name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;e.g. brew search mysql
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=""&gt;查询软件列表&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;brew list		// 可列出可安装的软件列表, 可结合管道使用，查找需要的软件
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=""&gt;安装软件&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;brew install &amp;lt;target-name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=""&gt;删除软件&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;brew uninstall &amp;lt;target-name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=""&gt;查询&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;brew info &amp;lt;target-name&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description><link>http://localhost:2368/2016/12/08/welcome-to-ghost/</link><guid isPermaLink="false">5a702c40f2c769befd9f2f12</guid><category>技术</category><category>工具</category><dc:creator>Mark Chen</dc:creator><pubDate>Thu, 08 Dec 2016 06:55:59 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;h3 id="homebrew"&gt;安装Homebrew&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;ruby -e &amp;quot;$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=""&gt;搜索&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;brew search &amp;lt;target-name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;e.g. brew search mysql
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=""&gt;查询软件列表&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;brew list		// 可列出可安装的软件列表, 可结合管道使用，查找需要的软件
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=""&gt;安装软件&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;brew install &amp;lt;target-name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=""&gt;删除软件&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;brew uninstall &amp;lt;target-name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=""&gt;查询&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;brew info &amp;lt;target-name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;e.g. brew search mysql
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="homebrew"&gt;更新Homebrew信息&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;brew update		// 更新Homebrew信息，包括Homebrew自身以及包信息等；
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="homebrew"&gt;Homebrew体检&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;brew doctor		// 会详细列出过期或者废弃的信息
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=""&gt;升级软件&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;brew upgrade	// 通过Homebrew升级所有可以升级的软件们
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=""&gt;清理&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;brew cleanup	// 清理不需要的版本、安装包、缓存等内容
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=""&gt;查看升级信息&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;brew outdated	// 查看所有可升级的软件，aka. 知道哪些软件有新版本啦
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=""&gt;软件定向升级&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;brew upgrade &amp;lt;target-name&amp;gt;		// 对某一软件进行针对性升级
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ENJOY.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Author: Mark C.J.	2016.6.15&lt;/p&gt;
&lt;p&gt;Flight &lt;strong&gt;HU7711&lt;/strong&gt;. From Beijing to Shenzhen.&lt;/p&gt;
&lt;/div&gt;</content:encoded></item></channel></rss>