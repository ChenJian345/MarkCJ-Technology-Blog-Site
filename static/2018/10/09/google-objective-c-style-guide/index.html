<!DOCTYPE html>
<html lang="ch">
<head>

    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <title>Google Objective-C编码规范-中英对照</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="stylesheet" type="text/css" href="../../../../assets/main/css/main.css?v=db5bd3ff41" />

    <meta name="description" content="翻译者：Mark C.J. 

警告：文章原始版权归Google所有，本文档翻译部分归作者Mark所有，只供学习使用，禁止以营利为目的或其他商业使用！" />
    <link rel="shortcut icon" href="../../../../favicon.png" type="image/png" />
    <link rel="canonical" href="index.html" />
    <meta name="referrer" content="no-referrer-when-downgrade" />
    <link rel="amphtml" href="amp/index.html" />
    
    <meta property="og:site_name" content="Crazy Mark" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content="Google Objective-C编码规范-中英对照" />
    <meta property="og:description" content="翻译者：Mark C.J. 

警告：文章原始版权归Google所有，本文档翻译部分归作者Mark所有，只供学习使用，禁止以营利为目的或其他商业使用！" />
    <meta property="og:url" content="http://localhost:2368/2018/10/09/google-objective-c-style-guide/" />
    <meta property="article:published_time" content="2018-10-09T12:00:00.000Z" />
    <meta property="article:modified_time" content="2019-12-24T08:28:17.000Z" />
    <meta property="article:tag" content="style guide" />
    <meta property="article:tag" content="iOS" />
    <meta property="article:tag" content="技术" />
    
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:title" content="Google Objective-C编码规范-中英对照" />
    <meta name="twitter:description" content="翻译者：Mark C.J. 

警告：文章原始版权归Google所有，本文档翻译部分归作者Mark所有，只供学习使用，禁止以营利为目的或其他商业使用！" />
    <meta name="twitter:url" content="http://localhost:2368/2018/10/09/google-objective-c-style-guide/" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="Mark C.J." />
    <meta name="twitter:label2" content="Filed under" />
    <meta name="twitter:data2" content="style guide, iOS, 技术" />
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "Crazy Mark",
        "logo": {
            "@type": "ImageObject",
            "url": "http://localhost:2368/favicon.png",
            "width": 60,
            "height": 60
        }
    },
    "author": {
        "@type": "Person",
        "name": "Mark C.J.",
        "url": "http://localhost:2368/author/mark/",
        "sameAs": []
    },
    "headline": "Google Objective-C编码规范-中英对照",
    "url": "http://localhost:2368/2018/10/09/google-objective-c-style-guide/",
    "datePublished": "2018-10-09T12:00:00.000Z",
    "dateModified": "2019-12-24T08:28:17.000Z",
    "keywords": "style guide, iOS, 技术",
    "description": "注意：文章原始版权归Google所有，本文档翻译部分归作者Mark所有，只供学习使用，禁止以营利为目的或其他商业使用！\n\n&gt; Objective-C is a dynamic, object-oriented extension of C. It&#x27;s designed to be\neasy to use and read, while enabling sophisticated object-oriented design. It\nis the primary development language for applications on OS X and on iOS.\n\nObjective-C是基于C语言的动态化、面向对象程序设计语言。它被设计的易读易使用，同时支持复杂的面向对象程序设计。Objective-C是OS\nX和iOS应用程序开发的首选语言。\n\nApple has already written a very good, and widely accepted, Cocoa Coding\nGuidelines\n[https://developer.apple.com/",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "http://localhost:2368/"
    }
}
    </script>

    <meta name="generator" content="Ghost 3.2" />
    <link rel="alternate" type="application/rss+xml" title="Crazy Mark" href="../../../../rss/index.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-113294116-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-113294116-1');
</script>

<!-- Google Adsense -->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-8998210359913715",
          enable_page_level_ads: true
     });
</script>

</head>
<body class="is-preload post-template tag-style-guide tag-ios tag-ji-zhu">

    <div id="wrapper">
        <main id="main">
            <div class="inner">

                <header id="header">
                        <a href="../../../../index.html" class="logo">Crazy Mark</a>
                    <ul class="icons">
                        <li><a href="https://feedly.com/i/subscription/feed/http://localhost:2368/rss/" class="icon fa-rss" target="_blank" rel="noopener"><span class="label" title="RSS">RSS</span></a></li>
                    </ul>
                </header>

                
<section>

    <header class="main content">
        <span class="date">October 9, 2018</span>
        <h1>Google Objective-C Style Guide [中英对照]</h1>
    </header>


    <div class="content">
        <!--kg-card-begin: markdown--><p><strong>注意：文章原始版权归Google所有，本文档翻译部分归作者Mark所有，只供学习使用，禁止以营利为目的或其他商业使用！</strong></p>
<blockquote>
<p>Objective-C is a dynamic, object-oriented extension of C. It's designed to be<br>
easy to use and read, while enabling sophisticated object-oriented design. It<br>
is the primary development language for applications on OS X and on iOS.</p>
<p>Objective-C是基于C语言的动态化、面向对象程序设计语言。它被设计的易读易使用，同时支持复杂的面向对象程序设计。Objective-C是OS X和iOS应用程序开发的首选语言。</p>
<p>Apple has already written a very good, and widely accepted, <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html">Cocoa Coding<br>
Guidelines</a><br>
for Objective-C. Please read it in addition to this guide.</p>
<p>苹果公司已经为Objective-C撰写了优秀且被广泛接受的 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html">Cocoa开发代码规范</a>，除本文档外，可以参考上述文档。</p>
<p>The purpose of this document is to describe the Objective-C (and<br>
Objective-C++) coding guidelines and practices that should be used for iOS and<br>
OS X code. These guidelines have evolved and been proven over time on other<br>
projects and teams.<br>
Open-source projects developed by Google conform to the requirements in this guide.</p>
<p>本文档用于描述在用于iOS和OS X程序开发时，Objective-C (Objective-C++)语言的代码规范和最佳实践。该规范已经被其他项目和团队广泛使用并被时间验证。Google的开源项目均采用该代码开发规范。</p>
<p>Note that this guide is not an Objective-C tutorial. We assume that the reader<br>
is familiar with the language. If you are new to Objective-C or need a<br>
refresher, please read <a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html">Programming with<br>
Objective-C</a>.</p>
<p>注意本文档不是Objective-C语言教程。我们假设读者已经熟知Objective-C开发语言。如果你是Objective-C新人或需要复习该语言，请阅读<a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html">Programming with Objective-C</a>。</p>
</blockquote>
<h2 id="principles">原则（Principles）</h2>
<h3 id="optimizeforthereadernotthewriter">关注读者，而非作者（Optimize for the reader, not the writer）</h3>
<blockquote>
<p>Codebases often have extended lifetimes and more time is spent reading the code<br>
than writing it. We explicitly choose to optimize for the experience of our<br>
average software engineer reading, maintaining, and debugging code in our<br>
codebase rather than the ease of writing said code. For example, when something<br>
surprising or unusual is happening in a snippet of code, leaving textual hints<br>
for the reader is valuable.</p>
</blockquote>
<p>阅读代码库中的代码的时间往往远大于书写的时间。我们很明确的选择优化普通软件开发工程师对于代码阅读、维护和调试的体验，而不是写出简易（指简陋甚至）的代码。例如，当对于一小段代码会让人感到惊奇或不寻常时（不可奇技淫巧），给读者书写一段文本注释或说明是非常可贵的。</p>
<h3 id="beconsistent">保持一致性 （Be consistent）</h3>
<blockquote>
<p>When the style guide allows multiple options it is preferable to pick one option<br>
over mixed usage of multiple options. Using one style consistently throughout a<br>
codebase lets engineers focus on other (more important) issues. Consistency also<br>
enables better automation because consistent code allows more efficient<br>
development and operation of tools that format or refactor code. In many cases,<br>
rules that are attributed to &quot;Be Consistent&quot; boil down to &quot;Just pick one and<br>
stop worrying about it&quot;; the potential value of allowing flexibility on these<br>
points is outweighed by the cost of having people argue over them.</p>
</blockquote>
<p>当编码风格规范中提供规范供选择时，选择一种规范要优于多种规范混用。代码库中使用一致的规范，会帮助工程师节省时间，将精力放在其他更重要的事情上（指减少因为编码规范不统一导致的各种误解）。由于一致的代码风格可以高效的开发和使用工具组件，所以，一致性也可以提高自动化程度。在很多场景中，保持一致性可以归结为“（快速）选一个，然后就不要再担心它”，这种选择的灵活性做法，对比花费更多时间争论选择哪种规范来使用，更具潜在价值。</p>
<h3 id="applesdksbeconsistentwithapplesdks">与Apple SDKs保持一致（Be consistent with Apple SDKs）</h3>
<blockquote>
<p>Consistency with the way Apple SDKs use Objective-C has value for the same<br>
reasons as consistency within our code base. If an Objective-C feature solves a<br>
problem that's an argument for using it. However, sometimes language features<br>
and idioms are flawed, or were just designed with assumptions that are not<br>
universal. In those cases it is appropriate to constrain or ban language<br>
features or idioms.</p>
</blockquote>
<p>与上面说的保持一致性一样，与苹果Objective-C SDKs保持一致性同样具有价值。如果一个Objective-C的功能特性解决了一个由于参数使用导致的问题。然而，有时语言的特性和惯用语法是有缺陷的，或者本来就被设计的不是通用的。此时，避免或者禁用这些特性或惯用语法往往更好。</p>
<h3 id="stylerulesshouldpulltheirweight">风格规范要适度（Style rules(编码规范) should pull their weight）</h3>
<blockquote>
<p>The benefit of a style rule must be large enough to justify asking engineers to<br>
remember it. The benefit is measured relative to the codebase we would get<br>
without the rule, so a rule against a very harmful practice may still have a<br>
small benefit if people are unlikely to do it anyway. This principle mostly<br>
explains the rules we don’t have, rather than the rules we do: for example, goto<br>
contravenes many of the following principles, but is not discussed due to its<br>
extreme rarity.</p>
</blockquote>
<p>编码规范必须被证明足够有益，以便让工程师信服。这些收益是相对于我们拿一个完全没有规范的代码库来对比的，若工程师执行一个非常糟糕的编码规范，也比完全没有规范好一些。这一原则主要解释我们没有的规则，而不是我们已有的规则。例如，goto违反很多下述原则，但我们由于其极其少见，我们在此不讨论。</p>
<h2 id="example">示例 (Example)</h2>
<blockquote>
<p>They say an example is worth a thousand words, so let's start off with an<br>
example that should give you a feel for the style, spacing, naming, and so on.</p>
</blockquote>
<blockquote>
<p>Here is an example header file, demonstrating the correct commenting and spacing<br>
for an <code>@interface</code> declaration.</p>
</blockquote>
<p>俗话说，一个例子胜过千言万语，所以我们举个例子，来初步感受一下编码风格、空格空行布局、命名等等编码规范。</p>
<p>下面头文件的例子，演示如何声明一个<code>@interface</code>正确的注释及代码空格空行编码风格。</p>
<pre><code class="language-objectivec">// GOOD:

#import &lt;Foundation/Foundation.h&gt;

@class Bar;

/**
 * A sample class demonstrating good Objective-C style. All interfaces,
 * categories, and protocols (read: all non-trivial top-level declarations
 * in a header) MUST be commented. Comments must also be adjacent to the
 * object they're documenting.
 */
@interface Foo : NSObject

/** The retained Bar. */
@property(nonatomic) Bar *bar;

/** The current drawing attributes. */
@property(nonatomic, copy) NSDictionary&lt;NSString *, NSNumber *&gt; *attributes;

/**
 * Convenience creation method.
 * See -initWithBar: for details about @c bar.
 *
 * @param bar The string for fooing.
 * @return An instance of Foo.
 */
+ (instancetype)fooWithBar:(Bar *)bar;

/**
 * Initializes and returns a Foo object using the provided Bar instance.
 *
 * @param bar A string that represents a thing that does a thing.
 */
- (instancetype)initWithBar:(Bar *)bar NS_DESIGNATED_INITIALIZER;

/**
 * Does some work with @c blah.
 *
 * @param blah
 * @return YES if the work was completed; NO otherwise.
 */
- (BOOL)doWorkWithBlah:(NSString *)blah;

@end
</code></pre>
<blockquote>
<p>An example source file, demonstrating the correct commenting and spacing for the<br>
<code>@implementation</code> of an interface.</p>
</blockquote>
<p>实现一个<code>@implementation</code> 的正确编码规范示例，展示正确的注释和间距（包括空行，回车，空格等）</p>
<pre><code class="language-objectivec">// GOOD:

#import &quot;Shared/Util/Foo.h&quot;

@implementation Foo {
  /** The string used for displaying &quot;hi&quot;. */
  NSString *_string;
}

+ (instancetype)fooWithBar:(Bar *)bar {
  return [[self alloc] initWithBar:bar];
}

- (instancetype)init {
  // Classes with a custom designated initializer should always override
  // the superclass's designated initializer.
  return [self initWithBar:nil];
}

- (instancetype)initWithBar:(Bar *)bar {
  self = [super init];
  if (self) {
    _bar = [bar copy];
    _string = [[NSString alloc] initWithFormat:@&quot;hi %d&quot;, 3];
    _attributes = @{
      @&quot;color&quot; : [UIColor blueColor],
      @&quot;hidden&quot; : @NO
    };
  }
  return self;
}

- (BOOL)doWorkWithBlah:(NSString *)blah {
  // Work should be done here.
  return NO;
}

@end
</code></pre>
<h2 id="naming">命名（Naming）</h2>
<blockquote>
<p>Names should be as descriptive as possible, within reason. Follow standard<br>
<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html">Objective-C naming rules</a>.</p>
</blockquote>
<p>命名需要自达意（即看到命名，即可清楚知道代表的意义）且合理，参照<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html">Objective-C naming rules</a>.</p>
<blockquote>
<p>Avoid non-standard abbreviations (including non-standard acronyms and<br>
initialisms). Don't worry about saving horizontal space as it is far more<br>
important to make your code immediately understandable by a new reader. For<br>
example:</p>
</blockquote>
<p>禁用非标准缩写（包括非标准首字母缩略词）。 相对节约内存空间来说，对于一个新的读者来说，能够立即理解意义会更为重要，例如：</p>
<pre><code class="language-objectivec">// GOOD:

// Good names.
int numberOfErrors = 0;
int completedConnectionsCount = 0;
tickets = [[NSMutableArray alloc] init];
userInfo = [someObject object];
port = [network port];
NSDate *gAppLaunchDate;
</code></pre>
<pre><code class="language-objectivec">// AVOID:

// Names to avoid.
int w;
int nerr;
int nCompConns;
tix = [[NSMutableArray alloc] init];
obj = [someObject object];
p = [network port];
</code></pre>
<blockquote>
<p>Any class, category, method, function, or variable name should use all capitals<br>
for acronyms and <a href="https://en.wikipedia.org/wiki/Initialism">initialisms</a><br>
within the name. This follows Apple's standard of using all capitals within a<br>
name for acronyms such as URL, ID, TIFF, and EXIF.</p>
</blockquote>
<p>任何类、扩展、方法、函数或者变量名，简称或者缩略语必须大写。对于名字，可参照苹果缩略语或简称大写字母标准，例如URL, ID, TIFF, EXIF。</p>
<blockquote>
<p>Names of C functions and typedefs should be capitalized and use camel case as<br>
appropriate for the surrounding code.</p>
</blockquote>
<p>C语言函数或者typedef命名须首字母大写，使用驼峰命名方式区分大小写；</p>
<h3 id="filenames">文件命名（File Names）</h3>
<blockquote>
<p>File names should reflect the name of the class implementation that they<br>
contain—including case.</p>
</blockquote>
<p>文件命名须与该文件中实现的类名保持一致，包括大小写；</p>
<blockquote>
<p>Follow the convention that your project uses.<br>
File extensions should be as follows:</p>
</blockquote>
<p>文件扩展名，约定如下：</p>
<table>
<thead>
<tr>
<th>扩展名（Extension）</th>
<th>类型（Type）</th>
</tr>
</thead>
<tbody>
<tr>
<td>.h</td>
<td>C/C++/Objective-C头文件（C/C++/Objective-C header file）</td>
</tr>
<tr>
<td>.m</td>
<td>Objective-C（类）实现文件（Objective-C implementation file）</td>
</tr>
<tr>
<td>.mm</td>
<td>Objective-C++（类）实现文件（Objective-C++ implementation file）</td>
</tr>
<tr>
<td>.cc</td>
<td>纯C++实现文件（Pure C++ implementation file）</td>
</tr>
<tr>
<td>.c</td>
<td>C实现文件（C implementation file）</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Files containing code that may be shared across projects or used in a large<br>
project should have a clearly unique name, typically including the project or<br>
class <a href="index.html#prefixes">prefix</a>.</p>
</blockquote>
<p>包含跨工程或者较大工程中共用的代码的文件，必须有一个清晰唯一的名字，一般用工程或类名作为前缀。</p>
<blockquote>
<p>File names for categories should include the name of the class being extended,<br>
like GTMNSString+Utils.h or NSTextView+GTMAutocomplete.h</p>
</blockquote>
<p>扩展类的文件名，须包含被扩展类的类名，例如GTMNSString+Utils.h或NSTextView+GTMAutocomplete.h</p>
<h3 id="prefixes">前缀（Prefixes）</h3>
<blockquote>
<p>Prefixes are commonly required in Objective-C to avoid naming collisions in a<br>
global namespace. Classes, protocols, global functions, and global constants<br>
should generally be named with a prefix that begins with a capital letter<br>
followed by one or more capital letters or numbers.</p>
</blockquote>
<p>前缀被用来避免全局命名空间的命名冲突。类名、协议、全局方法和全局常量命名，要添加前缀，并且首字母大写，后面包含一个或几个数字或大写字母。</p>
<blockquote>
<p>WARNING: Apple reserves two-letter prefixes—see<br>
<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Conventions/Conventions.html">Conventions in Programming with Objective-C</a>—so<br>
prefixes with a minimum of three characters are considered best practice.</p>
</blockquote>
<p>警告：苹果使用两个字母的前缀，参考<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Conventions/Conventions.html">Conventions in Programming with Objective-C</a>，所以，建议最好使用最少三个字符的前缀。</p>
<pre><code class="language-objectivec">// GOOD:

/** An example error domain. */
extern NSString *GTMExampleErrorDomain;

/** Gets the default time zone. */
extern NSTimeZone *GTMGetDefaultTimeZone(void);

/** An example delegate. */
@protocol GTMExampleDelegate &lt;NSObject&gt;
@end

/** An example class. */
@interface GTMExample : NSObject
@end

</code></pre>
<h3 id="classnames">类命名（Class Names）</h3>
<blockquote>
<p>Class names (along with category and protocol names) should start as uppercase<br>
and use mixed case to delimit words.</p>
</blockquote>
<p>类命名（连同扩展和协议命名）需要使用首字母大写，大小写混合的方式来界定不同单词。</p>
<blockquote>
<p>Classes and protocols in code shared across multiple applications must have an<br>
appropriate <a href="index.html#prefixes">prefix</a> (e.g. GTMSendMessage). Prefixes are recommended,<br>
but not required, for other classes and protocols.</p>
</blockquote>
<p>跨应用使用的类和协议必须使用合适的前缀（例如：GTMSendMessage）。对于其他类和协议，前缀被推荐使用，但不是必须的。</p>
<h3 id="categorycategorynaming">Category命名（Category Naming ）</h3>
<blockquote>
<p>Category names should start with an appropriate <a href="index.html#prefixes">prefix</a> identifying<br>
the category as part of a project or open for general use.</p>
</blockquote>
<p>Category名要使用合适的前缀，来表明该扩展是某一工程的一部分或可以通用。</p>
<blockquote>
<p>Category source file names should begin with the class being extended followed<br>
by a plus sign and the name of the category, e.g., <code>NSString+GTMParsing.h</code>.<br>
Methods in a category should be prefixed with a lowercase version of the prefix<br>
used for the category name followed by an underscore (e.g.,<br>
<code>gtm_myCategoryMethodOnAString:</code>) in order to prevent collisions in<br>
Objective-C's global namespace.</p>
</blockquote>
<p>Category源文件名必须以被扩展类名开头，中间用+号衔接后面的扩展名字，例如：<code>NSString+GTMParsing.h</code>。 扩展中的方法以小写的扩展名为前缀，中间用下划线衔接方法名（例如：<code>gtm_myCategoryMethodOnAString:</code>），以便避免全局命名范围内的命名冲突。</p>
<blockquote>
<p>There should be a single space between the class name and the opening<br>
parenthesis of the category.</p>
</blockquote>
<p>类名和扩展名的左圆括号之间，须添加一个空格。</p>
<pre><code class="language-objectivec">// GOOD:

// UIViewController+GTMCrashReporting.h

/** A category that adds metadata to include in crash reports to UIViewController. */
@interface UIViewController (GTMCrashReporting)

/** A unique identifier to represent the view controller in crash reports. */
@property(nonatomic, setter=gtm_setUniqueIdentifier:) int gtm_uniqueIdentifier;

/** Returns an encoded representation of the view controller's current state. */
- (nullable NSData *)gtm_encodedState;

@end
</code></pre>
<blockquote>
<p>If a class is not shared with other projects, categories extending it may omit<br>
name prefixes and method name prefixes.</p>
</blockquote>
<p>若类不被其他工程共用，扩展名和方法名可省略前缀。</p>
<pre><code class="language-objectivec">// GOOD:

/** This category extends a class that is not shared with other projects. */
@interface XYZDataObject (Storage)
- (NSString *)storageIdentifier;
@end
</code></pre>
<h3 id="ocobjectivecmethodnames">OC方法命名（Objective-C Method Names）</h3>
<blockquote>
<p>Method and parameter names typically start as lowercase and then use mixed case.</p>
</blockquote>
<p>方法名和参数名以小写字母开头，中间夹杂大小写。</p>
<blockquote>
<p>Proper capitalization should be respected, including at the beginning of names.</p>
</blockquote>
<p>包括首字母命名，可以考虑某些字母大写。</p>
<pre><code class="language-objectivec">// GOOD:

+ (NSURL *)URLWithString:(NSString *)URLString;
</code></pre>
<blockquote>
<p>The method name should read like a sentence if possible, meaning you should<br>
choose parameter names that flow with the method name. Objective-C method names<br>
tend to be very long, but this has the benefit that a block of code can almost<br>
read like prose, thus rendering many implementation comments unnecessary.</p>
</blockquote>
<p>方法名应该尽量读起来像一个句子，告诉你这个方法后面应该传入的参数名。Objective-C方法名倾向于非常长，但是这样的好处就是一段block的代码读起来像散文，因此没必要再添加更多注释。</p>
<blockquote>
<p>Use prepositions and conjunctions like &quot;with&quot;, &quot;from&quot;, and &quot;to&quot; in the second<br>
and later parameter names only where necessary to clarify the meaning or<br>
behavior of the method.</p>
</blockquote>
<p>只有在有必要说明方法意义或行为时，才在第二个参数名后，使用例如&quot;with&quot;, &quot;from&quot;, and &quot;to&quot;等介词和连词。</p>
<pre><code class="language-objectivec">// GOOD:

- (void)addTarget:(id)target action:(SEL)action;                          // GOOD; no conjunction needed
- (CGPoint)convertPoint:(CGPoint)point fromView:(UIView *)view;           // GOOD; conjunction clarifies parameter
- (void)replaceCharactersInRange:(NSRange)aRange
            withAttributedString:(NSAttributedString *)attributedString;  // GOOD.
</code></pre>
<blockquote>
<p>A method that returns an object should have a name beginning with a noun<br>
identifying the object returned:</p>
</blockquote>
<p>返回对象的方法名需要以名词开头，以表明返回的对象类型。</p>
<pre><code class="language-objectivec">// GOOD:

- (Sandwich *)sandwich;      // GOOD.
</code></pre>
<pre><code class="language-objectivec">// AVOID:

- (Sandwich *)makeSandwich;  // AVOID.
</code></pre>
<blockquote>
<p>An accessor method should be named the same as the object it's getting, but it<br>
should not be prefixed with the word <code>get</code>. For example:</p>
</blockquote>
<p>访问器方法需要和对象的getting方法一致，但不可有<code>get</code>前缀。例如：</p>
<pre><code class="language-objectivec">// GOOD:

- (id)delegate;     // GOOD.
</code></pre>
<pre><code class="language-objectivec">// AVOID:

- (id)getDelegate;  // AVOID.
</code></pre>
<blockquote>
<p>Accessors that return the value of boolean adjectives have method names<br>
beginning with <code>is</code>, but property names for those methods omit the <code>is</code>.</p>
</blockquote>
<p>返回布尔类型的方法，要以<code>is</code>为开头，但属性名省略<code>is</code></p>
<blockquote>
<p>Dot notation is used only with property names, not with method names.</p>
</blockquote>
<p>点只用于属性获取，不可用于方法调用</p>
<pre><code class="language-objectivec">// GOOD:

@property(nonatomic, getter=isGlorious) BOOL glorious;
- (BOOL)isGlorious;

BOOL isGood = object.glorious;      // GOOD.
BOOL isGood = [object isGlorious];  // GOOD.
</code></pre>
<pre><code class="language-objectivec">// AVOID:

BOOL isGood = object.isGlorious;    // AVOID.
</code></pre>
<pre><code class="language-objectivec">// GOOD:

NSArray&lt;Frog *&gt; *frogs = [NSArray&lt;Frog *&gt; arrayWithObject:frog];
NSEnumerator *enumerator = [frogs reverseObjectEnumerator];  // GOOD.
</code></pre>
<pre><code class="language-objectivec">// AVOID: 避免使用.来调用方法

NSEnumerator *enumerator = frogs.reverseObjectEnumerator;    // AVOID.
</code></pre>
<p>See <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingMethods.html#//apple_ref/doc/uid/20001282-BCIGIJJF">Apple's Guide to Naming Methods</a> for more details on Objective-C naming.</p>
<p>These guidelines are for Objective-C methods only. C++ method names continue to<br>
follow the rules set in the C++ style guide.</p>
<p>更多命名相关内容，参考<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingMethods.html#//apple_ref/doc/uid/20001282-BCIGIJJF">Apple's Guide to Naming Methods</a>。</p>
<p>以上规范只适用于Objective-C方法，C++方法命名请参考C++命名指南。</p>
<h3 id="functionnames">函数命名（Function Names）</h3>
<p>Function names should start with a capital letter and have a capital letter for<br>
each new word (a.k.a. &quot;<a href="https://en.wikipedia.org/wiki/Camel_case">camel case</a>&quot; or &quot;Pascal case&quot;).</p>
<p>函数名要首字母大写，之后使用驼峰命名法。</p>
<pre><code class="language-objectivec">// GOOD:

static void AddTableEntry(NSString *tableEntry);
static BOOL DeleteFile(const char *filename);
</code></pre>
<p>Because Objective-C does not provide namespacing, non-static functions should<br>
have a <a href="index.html#prefixes">prefix</a> that minimizes the chance of a name collision.</p>
<p>由于Objective-C不支持命名空间，非静态函数要使用前缀，以最大程度减少命名冲突。</p>
<pre><code class="language-objectivec">// GOOD:

extern NSTimeZone *GTMGetDefaultTimeZone(void);
extern NSString *GTMGetURLScheme(NSURL *URL);
</code></pre>
<h3 id="variablenames">变量命名（Variable Names）</h3>
<blockquote>
<p>Variable names typically start with a lowercase and use mixed case to delimit<br>
words.</p>
</blockquote>
<blockquote>
<p>Instance variables have leading underscores. File scope or global variables have<br>
a prefix <code>g</code>. For example: <code>myLocalVariable</code>, <code>_myInstanceVariable</code>,<br>
<code>gMyGlobalVariable</code>.</p>
</blockquote>
<p>变量名首字母小写，采用驼峰命名法.</p>
<p>实例变量使用下划线前缀。文件范围或全局变量使用<code>g</code>作为前缀。例如<code>myLocalVariable</code>, <code>_myInstanceVariable</code>, <code>gMyGlobalVariable</code>.</p>
<h4 id="commonvariablenames">一般变量命名（Common Variable Names）</h4>
<blockquote>
<p>Readers should be able to infer the variable type from the name, but do not use<br>
Hungarian notation for syntactic attributes, such as the static type of a<br>
variable (int or pointer).</p>
</blockquote>
<p>代码读者应该能从命名中推导出变量所代表的含义，但是对于句法属性不要使用匈牙利表示法，例如，对于静态变量，不需要加<code>s</code></p>
<blockquote>
<p>File scope or global variables (as opposed to constants) declared outside the<br>
scope of a method or function should be rare, and should have the prefix g.</p>
</blockquote>
<p>声明在方法或函数外的文件作用域变量或全局变量（区别常量）比较少见，应该带有一个前缀<code>g</code></p>
<pre><code class="language-objectivec">// GOOD:

static int gGlobalCounter;
</code></pre>
<h4 id="instancevariables">实例变量（Instance Variables）</h4>
<blockquote>
<p>Instance variable names are mixed case and should be prefixed with an<br>
underscore, like <code>_usernameTextField</code>.</p>
</blockquote>
<p>示例变量前边以下划线<code>_</code>开头，中间但是使用驼峰法区分大小写。</p>
<blockquote>
<p>NOTE: Google's previous convention for Objective-C ivars was a trailing<br>
underscore. Existing projects may opt to continue using trailing underscores in<br>
new code in order to maintain consistency within the project codebase.<br>
Consistency of prefix or suffix underscores should be maintained within each<br>
class.</p>
</blockquote>
<p>注意：Google之前对Objective-C变量的约定是使用尾部下划线。现有工程中，后续开发可能会选择继续使用实例变量尾部带有下划线的方式，以便与之前工程代码保持一致。在每个类中要保持前后缀下划线的一致性。</p>
<h4 id="constants">常量（Constants）</h4>
<blockquote>
<p>Constant symbols (const global and static variables and constants created<br>
with #define) should use mixed case to delimit words.</p>
</blockquote>
<p>常量标识符（包括全局常量、静态变量和使用#define定义的常量）需使用驼峰命名；</p>
<blockquote>
<p>Global and file scope constants should have an appropriate <a href="index.html#prefixes">prefix</a>.</p>
</blockquote>
<p>全局和文件作用域常量要带有合适的前缀。</p>
<pre><code class="language-objectivec">// GOOD:

extern NSString *const GTLServiceErrorDomain;

typedef NS_ENUM(NSInteger, GTLServiceError) {
  GTLServiceErrorQueryResultMissing = -3000,
  GTLServiceErrorWaitTimedOut       = -3001,
};
</code></pre>
<blockquote>
<p>Because Objective-C does not provide namespacing, constants with external<br>
linkage should have a prefix that minimizes the chance of a name collision,<br>
typically like <code>ClassNameConstantName</code> or <code>ClassNameEnumName</code>.</p>
</blockquote>
<p>由于Objective-C不支持命名空间，与外界关联的常量要使用前缀以最大程度避免命名冲突，常用方式例如<code>ClassNameConstantName</code> or <code>ClassNameEnumName</code>.</p>
<blockquote>
<p>For interoperability with Swift code, enumerated values should have names that<br>
extend the typedef name:</p>
</blockquote>
<p>与Swift有交互的Objective-C代码，枚举值变量要使用自定义类型名作为前缀：</p>
<pre><code class="language-objectivec">// GOOD:

typedef NS_ENUM(NSInteger, DisplayTinge) {
  DisplayTingeGreen = 1,
  DisplayTingeBlue = 2,
};
</code></pre>
<blockquote>
<p>A lowercase k can be used as a standalone prefix for constants of static storage<br>
duration declared within implementation files:</p>
</blockquote>
<p>在实现文件中，小写字母k可以被用来作为声明独立的常量或者静态变量前缀：</p>
<pre><code class="language-objectivec">// GOOD:

static const int kFileCount = 12;
static NSString *const kUserKey = @&quot;kUserKey&quot;;
</code></pre>
<blockquote>
<p>NOTE: Previous convention was for public constant names to begin with a<br>
lowercase k followed by a project-specific <a href="index.html#prefixes">prefix</a>. This practice is<br>
no longer recommended.</p>
</blockquote>
<p>提示：之前约定中，公共常量名使用小写k开头，以作为工程常量特有标识。该方式不再推荐使用。</p>
<h2 id="typesanddeclarations">类型和声明（Types and Declarations ）</h2>
<h3 id="methoddeclarations">方法声明（Method Declarations）</h3>
<blockquote>
<p>As shown in the <a href="index.html#Example">example</a>, the recommended order<br>
for declarations in an <code>@interface</code> declaration are: properties, class methods,<br>
initializers, and then finally instance methods. The class methods section<br>
should begin with any convenience constructors.</p>
</blockquote>
<p>如示例所示，声明一个 <code>@interface</code> 内容的推荐顺序为：属性，类方法，初始化方法，之后实例方法。类方法区域，把<a href="https://zhuanlan.zhihu.com/p/35695874">便捷初始化方法</a>放在前面。</p>
<h3 id="localvariables">局部变量（Local Variables）</h3>
<blockquote>
<p>Declare variables in the narrowest practical scopes, and close to their use.<br>
Initialize variables in their declarations.</p>
</blockquote>
<p>在靠近需要使用该变量的地方声明变量，声明时完成初始化。</p>
<pre><code class="language-objectivec">// GOOD:

CLLocation *location = [self lastKnownLocation];
for (int meters = 1; meters &lt; 10; meters++) {
  reportFrogsWithinRadius(location, meters);
}
</code></pre>
<blockquote>
<p>Occasionally, efficiency will make it more appropriate to declare a variable<br>
outside the scope of its use. This example declares meters separate from<br>
initialization, and needlessly sends the lastKnownLocation message each time<br>
through the loop:</p>
</blockquote>
<p>有时出于效率考虑，把变量声明在作用域外更可取。这个例子声明meters变量，并没有初始化，每次循环时，没必要每次都需要对location进行赋值。</p>
<pre><code class="language-objectivec">// AVOID:

int meters;                                         // AVOID.
for (meters = 1; meters &lt; 10; meters++) {
  CLLocation *location = [self lastKnownLocation];  // AVOID.
  reportFrogsWithinRadius(location, meters);
}
</code></pre>
<blockquote>
<p>Under Automatic Reference Counting, strong and weak pointers to Objective-C<br>
objects are automatically initialized to <code>nil</code>, so explicit initialization to<br>
<code>nil</code> is not required for those common cases. However, automatic initialization<br>
does <em>not</em> occur for many Objective-C pointer types, including object pointers<br>
declared with the <code>__unsafe_unretained</code> ownership qualifier and CoreFoundation<br>
object pointer types. When in doubt, prefer to initialize all Objective-C<br>
local variables.</p>
</blockquote>
<p>使用ARC时，Objective-C对象的强、弱指针会被自动会被初始化为<code>nil</code>，所以通常不需要强制初始化为<code>nil</code>。然而，包括利用<code>__unsafe_unretained</code>声明的变量和CoreFoundation对象指针，很多Objective-C指针类型不会自动完成初始化。 当无法肯定时，建议所有Objective-C局部变量声明时进行初始化。</p>
<h3 id="unsignedintegers">无符号整型 （Unsigned Integers）</h3>
<blockquote>
<p>Avoid unsigned integers except when matching types used by system interfaces.</p>
</blockquote>
<p>除匹配系统接口调用外，避免使用无符号整型。</p>
<blockquote>
<p>Subtle errors crop up when doing math or counting down to zero using unsigned<br>
integers. Rely only on signed integers in math expressions except when matching<br>
NSUInteger in system interfaces.</p>
</blockquote>
<p>使用无符号整型进行数学计算或出现倒数为0时，会出现微妙的错误。除匹配系统接口时使用NSUInteger外，数学计算时只使用带符号整型。</p>
<pre><code class="language-objectivec">// GOOD:

NSUInteger numberOfObjects = array.count;
for (NSInteger counter = numberOfObjects - 1; counter &gt; 0; --counter)
</code></pre>
<pre><code class="language-objectivec">// AVOID:

for (NSUInteger counter = numberOfObjects - 1; counter &gt; 0; --counter)  // AVOID.
</code></pre>
<blockquote>
<p>Unsigned integers may be used for flags and bitmasks, though often NS_OPTIONS or<br>
NS_ENUM will be more appropriate.</p>
</blockquote>
<p>尽管推荐使用NS_OPTIONS或NS_ENUM，无符号整型可以被用来作为标志位或位运算掩码。</p>
<h3 id="typeswithinconsistentsizes">字节宽度可变类型（Types with Inconsistent Sizes)</h3>
<blockquote>
<p>Due to sizes that differ in 32- and 64-bit builds, avoid types long, NSInteger,<br>
NSUInteger, and CGFloat except when matching system interfaces.</p>
</blockquote>
<p>由于long，NSInteger，NSUIInteger和CGFloat类型在32位和64位机上字节宽度不同，除必须匹配调用系统接口外，避免使用。</p>
<blockquote>
<p>Types long, NSInteger, NSUInteger, and CGFloat vary in size between 32- and<br>
64-bit builds. Use of these types is appropriate when handling values exposed by<br>
system interfaces, but they should be avoided for most other computations.</p>
</blockquote>
<p>long, NSInteger, NSUInteger, and CGFloat类型在32位和64位环境下字节宽度可变。处理系统暴露的数据时，可以使用上述类型，但其他运算，避免使用。</p>
<pre><code class="language-objectivec">// GOOD:

int32_t scalar1 = proto.intValue;

int64_t scalar2 = proto.longValue;

NSUInteger numberOfObjects = array.count;

CGFloat offset = view.bounds.origin.x;
</code></pre>
<pre><code class="language-objectivec">// AVOID:

NSInteger scalar2 = proto.longValue;  // AVOID.
</code></pre>
<blockquote>
<p>File and buffer sizes often exceed 32-bit limits, so they should be declared<br>
using <code>int64_t</code>, not with <code>long</code>, <code>NSInteger</code>, or <code>NSUInteger</code>.</p>
</blockquote>
<p>文件或缓存区大小常常超过32位限制，所以应该使用<code>int64_t</code>，而不是<code>long</code>, <code>NSInteger</code>,或 <code>NSUInteger</code>。</p>
<h2 id="comments">注释（Comments）</h2>
<blockquote>
<p>Comments are absolutely vital to keeping our code readable. The following rules<br>
describe what you should comment and where. But remember: while comments are<br>
important, the best code is self-documenting. Giving sensible names to types and<br>
variables is much better than using obscure names and then trying to explain<br>
them through comments.</p>
</blockquote>
<p>注释对于保证代码可读性至关重要。以下规范说明在哪以及如何写注释。但请记住：</p>
<blockquote>
<p>Pay attention to punctuation, spelling, and grammar; it is easier to read<br>
well-written comments than badly written ones.</p>
</blockquote>
<p>注意（注释的）标点、拼写和语法；写的好的注释更易懂。（aka，注释要写的清楚明白，好好说话）</p>
<blockquote>
<p>Comments should be as readable as narrative text, with proper capitalization and<br>
punctuation. In many cases, complete sentences are more readable than sentence<br>
fragments. Shorter comments, such as comments at the end of a line of code, can<br>
sometimes be less formal, but use a consistent style.<br>
When writing your comments, write for your audience: the next contributor who will need to understand your code. Be generous—the next one may be you!</p>
</blockquote>
<p>注释要读起来是叙事文字，需要使用合适的大小写和标点。很多场景中，完整的句子比一段段的文字更易懂。注释要简短，例如一行代码后的注释，可以是非正式的（句子），但请使用一致的风格。</p>
<p>当你写注释时，要为你的读者而写，也就是后面需要读你代码的合作者。要慷慨些，也许他之后读注释的就是你自己。</p>
<h3 id="filecomments">文件注释（File Comments）</h3>
<blockquote>
<p>A file may optionally start with a description of its contents.<br>
Every file may contain the following items, in order:</p>
<ul>
<li>License boilerplate if necessary. Choose the appropriate boilerplate for the license used by the project.</li>
<li>A basic description of the contents of the file if necessary.</li>
</ul>
</blockquote>
<p>文件头部可以添加该文件的注释说明。文件注释可以包含这些内容，顺序如下：</p>
<ul>
<li>如有必要，添加许可。选择工程使用的合适的许可引用说明</li>
<li>文件内容简要说明</li>
</ul>
<blockquote>
<p>If you make significant changes to a file with an author line, consider deleting<br>
the author line since revision history already provides a more detailed and<br>
accurate record of authorship.</p>
</blockquote>
<p>如果对具有作者行的文件进行了重大更改，请考虑删除作者行，因为修订历史记录已提供更详细和准确的作者记录。</p>
<h3 id="declarationcomments">声明注释（Declaration Comments）</h3>
<blockquote>
<p>Every non-trivial interface, public and private, should have an accompanying<br>
comment describing its purpose and how it fits into the larger picture.</p>
</blockquote>
<p>每个公开和私有的重要接口，要有附加的注释说明其作用和试用场景。</p>
<blockquote>
<p>Comments should be used to document classes, properties, ivars, functions,<br>
categories, protocol declarations, and enums.</p>
</blockquote>
<p>注释适用于要有文档说明的类、属性、成员变量、方法、扩展、协议声明及枚举。</p>
<pre><code class="language-objectivec">// GOOD:

/**
 * A delegate for NSApplication to handle notifications about app
 * launch and shutdown. Owned by the main app controller.
 */
@interface MyAppDelegate : NSObject {
  /**
   * The background task in progress, if any. This is initialized
   * to the value UIBackgroundTaskInvalid.
   */
  UIBackgroundTaskIdentifier _backgroundTaskID;
}

/** The factory that creates and manages fetchers for the app. */
@property(nonatomic) GTMSessionFetcherService *fetcherService;

@end
</code></pre>
<blockquote>
<p>Doxygen-style comments are encouraged for interfaces as they are parsed by Xcode<br>
to display formatted documentation. There is a wide variety of Doxygen commands;<br>
use them consistently within a project.</p>
</blockquote>
<p>接口推荐使用Doxygen风格注释，并可以利用xcode将注释原样转化为文档。Doxygen命令很多样，请在工程中保持一致，即使用同一套Doxygen命令</p>
<blockquote>
<p>If you have already described an interface in detail in the comments at the top<br>
of your file, feel free to simply state, &quot;See comment at top of file for a<br>
complete description&quot;, but be sure to have some sort of comment.</p>
</blockquote>
<p>如果在文件顶部已经添加了对接口的详细说明，你可以轻松的指出：&quot;请参考文件顶部的完整说明&quot;，但一定要有类似说明，说明一下。</p>
<blockquote>
<p>Additionally, each method should have a comment explaining its function,<br>
arguments, return value, thread or queue assumptions, and any side effects.<br>
Documentation comments should be in the header for public methods, or<br>
immediately preceding the method for non-trivial private methods.</p>
</blockquote>
<p>另外，每个方法需要有注释解释其功能、参数、返回值、使用线程假设，以及副作用。文档化注释需要在公开方法的头文件中，或者紧挨着重要的私有方法前。</p>
<blockquote>
<p>Use descriptive form (&quot;Opens the file&quot;) rather than imperative form (&quot;Open the<br>
file&quot;) for method and function comments. The comment describes the function; it<br>
does not tell the function what to do.</p>
</blockquote>
<p>对于方法和函数的注释使用描述性形式，而不是使用命令形式。注释描述其功能，而不是让函数去做什么。</p>
<blockquote>
<p>Document the thread usage assumptions the class, properties, or methods make, if<br>
any. If an instance of the class can be accessed by multiple threads, take extra<br>
care to document the rules and invariants surrounding multithreaded use.</p>
</blockquote>
<p>对于类、属性、方法，如果需要，添加线程使用假设文档说明。若类的示例被多个线程访问使用，对此文档中要格外说明其在多线程中使用规范及不变式。</p>
<blockquote>
<p>Any sentinel values for properties and ivars, such as <code>NULL</code> or <code>-1</code>, should be<br>
documented in comments.</p>
</blockquote>
<p>任何属性或成员变量的临界值，例如<code>NULL</code>或<code>-1</code>, 都需要在文档中注释说明其代表的意义。</p>
<blockquote>
<p>Declaration comments explain how a method or function is used. Comments<br>
explaining how a method or function is implemented should be with the<br>
implementation rather than with the declaration.</p>
</blockquote>
<p>声明注释用于解释方法或函数应该如何被使用。那些解释方法或函数是如何实现的注释，应该添加在实现处，而不是函数或方法的声明处。</p>
<h3 id="implementationcomments">实现注释（Implementation Comments）</h3>
<blockquote>
<p>Provide comments explaining tricky, subtle, or complicated sections of code.</p>
</blockquote>
<p>对刁钻、微妙或复杂的代码添加注释，解释其中奥妙。</p>
<pre><code class="language-objectivec">// GOOD:

// Set the property to nil before invoking the completion handler to
// avoid the risk of reentrancy leading to the callback being
// invoked again.
CompletionHandler handler = self.completionHandler;
self.completionHandler = nil;
handler();
</code></pre>
<blockquote>
<p>When useful, also provide comments about implementation approaches that were<br>
considered or abandoned.</p>
</blockquote>
<p>如果需要，也对一些考虑使用或放弃使用的方法实现添加注释。</p>
<blockquote>
<p>End-of-line comments should be separated from the code by at least 2 spaces. If<br>
you have several comments on subsequent lines, it can often be more readable to<br>
line them up.</p>
</blockquote>
<p>跟在代码行尾的注释需要至少用两个空格隔开代码与注释。如果你在随后的多行里有多个注释，更易读的办法是把他们（对齐）排好。</p>
<pre><code class="language-objectivec">// GOOD:

[self doSomethingWithALongName];  // Two spaces before the comment.
[self doSomethingShort];          // More spacing to align the comment.
</code></pre>
<h3 id="disambiguatingsymbols">消除符号歧义（Disambiguating Symbols）</h3>
<blockquote>
<p>Where needed to avoid ambiguity, use backticks or vertical bars to quote<br>
variable names and symbols in comments in preference to using quotation marks<br>
or naming the symbols inline.</p>
</blockquote>
<p>在需要避免歧义的地方，使用反引号或竖杠将注释中变量名字或符号引起来，要优于使用引号或内联命名符号。</p>
<blockquote>
<p>In Doxygen-style comments, prefer demarcating symbols with a monospace text<br>
command, such as <code>@c</code>.</p>
</blockquote>
<p>在Doxygen风格注释中，更建议使用等宽文本命令来划分标定符号，例如<code>@c</code>。</p>
<blockquote>
<p>Demarcation helps provide clarity when a symbol is a common word that might make<br>
the sentence read like it was poorly constructed. A common example is the symbol<br>
<code>count</code>:</p>
</blockquote>
<p>当一个符号命名是常用单词时，划定边界会使注释更清晰。若不划分，可能会使句子读起来不通顺。常见的例子如单词<code>count</code>：</p>
<pre><code class="language-objectivec">// GOOD:

// Sometimes `count` will be less than zero.
</code></pre>
<blockquote>
<p>or when quoting something which already contains quotes</p>
</blockquote>
<p>或引用已经有引号的文字</p>
<pre><code class="language-objectivec">// GOOD:

// Remember to call `StringWithoutSpaces(&quot;foo bar baz&quot;)`
</code></pre>
<blockquote>
<p>Backticks or vertical bars are not needed when a symbol is self-apparent.</p>
</blockquote>
<p>对于显而易见的文字不需要添加反引号或竖杠。</p>
<pre><code class="language-objectivec">// GOOD:

// This class serves as a delegate to GTMDepthCharge.
</code></pre>
<blockquote>
<p>Doxygen formatting is also suitable for identifying symbols.</p>
</blockquote>
<p>Doxygen格式化同样适用标识符号。</p>
<pre><code class="language-objectivec">// GOOD:

/** @param maximum The highest value for @c count. */
</code></pre>
<h3 id="objectownership">对象所有权（Object Ownership）</h3>
<blockquote>
<p>For objects not managed by ARC, make the pointer ownership model as explicit as<br>
possible when it falls outside the most common Objective-C usage idioms.</p>
</blockquote>
<p>不在ARC管理下的对象，当这些对象的指针在常见的Objective-C常用用法之外时，需要尽可能明确的说明该对象的指针。</p>
<h4 id="mrcmanualreferencecounting">MRC（Manual Reference Counting）</h4>
<blockquote>
<p>Instance variables for NSObject-derived objects are presumed to be retained; if<br>
they are not retained, they should be either commented as weak or declared with<br>
the <code>__weak</code> lifetime qualifier.</p>
</blockquote>
<p>NSObject子类的所有示例对象都被假定为会被保留计数，若他们没有被保留计数，要么需要注释为弱引用，要么声明时使用为<code>__weak</code>标识符。</p>
<blockquote>
<p>An exception is in Mac software for instance variables labeled as <code>@IBOutlets</code>,<br>
which are presumed to not be retained.</p>
</blockquote>
<p>在Mac软件中，被标示为 <code>@IBOutlets</code>的实例变量是个例外，这些变量假定不会被保留计数。</p>
<blockquote>
<p>Where instance variables are pointers to Core Foundation, C++, and other<br>
non-Objective-C objects, they should always be declared with strong and weak<br>
comments to indicate which pointers are and are not retained. Core Foundation<br>
and other non-Objective-C object pointers require explicit memory management,<br>
even when building for automatic reference counting.</p>
</blockquote>
<p>当实例变量指向Core Foundation，C++或其他非Objective-C对象，这些变量应该使用使用strong和weak，注释其哪些是被保留的，哪些不保留。Core Foundation和其他非Objective-C对象指针需要清晰明确的内存管理，即便使用ARC情况下也一样。</p>
<blockquote>
<p>Examples of strong and weak declarations:</p>
</blockquote>
<p>strong和weak声明示例</p>
<pre><code class="language-objectivec">// GOOD:

@interface MyDelegate : NSObject

@property(nonatomic) NSString *doohickey;
@property(nonatomic, weak) NSString *parent;

@end


@implementation MyDelegate {
  IBOutlet NSButton *_okButton;  // Normal NSControl; implicitly weak on Mac only

  AnObjcObject *_doohickey;  // My doohickey
  __weak MyObjcParent *_parent;  // To send messages back (owns this instance)

  // non-NSObject pointers...
  CWackyCPPClass *_wacky;  // Strong, some cross-platform object
  CFDictionaryRef *_dict;  // Strong
}
@end
</code></pre>
<h4 id="arcautomaticreferencecounting">ARC （Automatic Reference Counting）</h4>
<blockquote>
<p>Object ownership and lifetime are explicit when using ARC, so no additional<br>
comments are required for automatically retained objects.</p>
</blockquote>
<p>当使用ARC时，对象所有权和生命周期很清晰，所以不需要额外的注释来说明自动引用计数变量。</p>
<h2 id="cclanguagefeatures">C语言特性（C Language Features）</h2>
<h3 id="macros">宏（Macros）</h3>
<blockquote>
<p>Avoid macros, especially where <code>const</code> variables, enums, XCode snippets, or C<br>
functions may be used instead.</p>
</blockquote>
<p>若能使用<code>const</code>变量，枚举，Xcode代码片段，或C函数，请不要使用宏。</p>
<blockquote>
<p>Macros make the code you see different from the code the compiler sees. Modern C<br>
renders traditional uses of macros for constants and utility functions<br>
unnecessary. Macros should only be used when there is no other solution<br>
available.</p>
</blockquote>
<p>宏会使你看到的代码和编译器看到的代码不同。现代C使用宏的的传统用途不再是常量和工具函数。现在宏只有在没有其他解决方案时才被使用。</p>
<blockquote>
<p>Where a macro is needed, use a unique name to avoid the risk of a symbol<br>
collision in the compilation unit. If practical, keep the scope limited by<br>
<code>#undefining</code> the macro after its use.</p>
</blockquote>
<p>需要宏的地方，使用唯一的名字以避免在汇编时符号冲突。如果可行，使用<code>#undefining</code>限制宏的使用范围。</p>
<blockquote>
<p>Macro names should use <code>SHOUTY_SNAKE_CASE</code>—all uppercase letters with<br>
underscores between words. Function-like macros may use C function naming<br>
practices. Do not define macros that appear to be C or Objective-C keywords.</p>
</blockquote>
<p>宏的名字应该使用<code>SHOUTY_SNAKE_CASE</code>形式——所有字母大写，使用下划线链接不同单词。函数类的宏使用函数的命名规范。不要定义和C或Objective-C关键字同名的宏。</p>
<pre><code class="language-objectivec">// GOOD:

#define GTM_EXPERIMENTAL_BUILD ...      // GOOD

// Assert unless X &gt; Y
#define GTM_ASSERT_GT(X, Y) ...         // GOOD, macro style.

// Assert unless X &gt; Y
#define GTMAssertGreaterThan(X, Y) ...  // GOOD, function style.
</code></pre>
<pre><code class="language-objectivec">// AVOID:

#define kIsExperimentalBuild ...        // AVOID

#define unless(X) if(!(X))              // AVOID
</code></pre>
<blockquote>
<p>Avoid macros that expand to unbalanced C or Objective-C constructs. Avoid macros<br>
that introduce scope, or may obscure the capturing of values in blocks.</p>
</blockquote>
<p><em>这一段突然不知道如何翻译</em>，大意是：避免使用会导致C或Objective-C构造方法错乱的宏，避免使用会引入作用域或让block中变量持有者模糊（防止内存泄漏）的宏。</p>
<blockquote>
<p>Avoid macros that generate class, property, or method definitions in<br>
headers to be used as public API. These only make the code hard to<br>
understand, and the language already has better ways of doing this.</p>
</blockquote>
<p>避免在公用API头文件中使用可以生成类，属性或方法定义的宏。这种用法会导致代码难懂，而且语言本身有相对此方法更好的实现方法。</p>
<blockquote>
<p>Avoid macros that generate method implementations, or that generate declarations<br>
of variables that are later used outside of the macro. Macros shouldn't make<br>
code hard to understand by hiding where and how a variable is declared.</p>
</blockquote>
<p>避免使用生成方法实现的宏（比如生成单例方法的宏等）或者可生成变量声明，且该变量在宏外使用的宏。宏不能隐藏变量在何处以及如何被声明，这会导致代码晦涩难懂。</p>
<pre><code class="language-objectivec">// AVOID:

#define ARRAY_ADDER(CLASS) \
  -(void)add ## CLASS ## :(CLASS *)obj toArray:(NSMutableArray *)array

ARRAY_ADDER(NSString) {
  if (array.count &gt; 5) {              // AVOID -- where is 'array' defined?
    ...
  }
}
</code></pre>
<blockquote>
<p>Examples of acceptable macro use include assertion and debug logging macros<br>
that are conditionally compiled based on build settings—often, these are<br>
not compiled into release builds.</p>
</blockquote>
<p>宏中使用assert或根据编译设置，进行debug有条件编译，这可以接受，一般情况下这些条件编译代码不会包含在release版本中。</p>
<h3 id="nonstandardextensions">非标准扩展宏（Nonstandard Extensions）</h3>
<blockquote>
<p>Nonstandard extensions to C/Objective-C may not be used unless otherwise<br>
specified.</p>
</blockquote>
<p>C/Objective-C非标准扩展宏，除非特别说明，否则不可使用。</p>
<blockquote>
<p>Compilers support various extensions that are not part of standard C. Examples<br>
include compound statement expressions (e.g. <code>foo = ({ int x; Bar(&amp;x); x })</code>).</p>
</blockquote>
<p>编译器支持大量的非标准C语言扩展宏。例如复合语句表达式(例如： <code>foo = ({ int x; Bar(&amp;x); x })</code>).</p>
<blockquote>
<p><code>__attribute__</code> is an approved exception, as it is used in Objective-C API<br>
specifications.</p>
</blockquote>
<p><code>__attribute__</code> 是一个在Objective-C API被认可和使用的扩展宏。</p>
<blockquote>
<p>The binary form of the conditional operator, <code>A ?: B</code>, is an approved exception.</p>
</blockquote>
<p>对于三元运算符，<code>A ?: B</code>这种用法是个例外，也被认可使用。</p>
<h2 id="cocoaobjectiveccocoaandobjectivecfeatures">Cocoa&amp;Objective-C特性 （Cocoa and Objective-C Features）</h2>
<h3 id="identifydesignatedinitializer">明确特定初始化器（Identify Designated Initializer）</h3>
<blockquote>
<p>Clearly identify your designated initializer.</p>
</blockquote>
<p>清晰指明你的特定初始化器（也可以理解成初始化方法）。</p>
<blockquote>
<p>It is important for those who might be subclassing your class that the<br>
designated initializer be clearly identified. That way, they only need to<br>
override a single initializer (of potentially several) to guarantee the<br>
initializer of their subclass is called. It also helps those debugging your<br>
class in the future understand the flow of initialization code if they need to<br>
step through it. Identify the designated initializer using comments or the<br>
<code>NS_DESIGNATED_INITIALIZER</code> macro. If you use <code>NS_DESIGNATED_INITIALIZER</code>, mark<br>
unsupported initializers with <code>NS_UNAVAILABLE</code>.</p>
</blockquote>
<p>清晰的指明你创建的类的特定初始化器，这一点在其他人创建继承自你的类时显得非常重要。这样的话，他们只需要重写某一个或几个初始化器就可以保证他们的子类初始化方法被调用。这也可以帮助后面可能调试代码的人，更清晰的了解你的类初始化流程。请使用注释或者<code>NS_DESIGNATED_INITIALIZER</code> 宏指明你的特定初始化器。如果使用<code>NS_DESIGNATED_INITIALIZER</code> 宏，请将其他不支持的初始化器用 <code>NS_UNAVAILABLE</code>来标注。</p>
<h3 id="overridedesignatedinitializer">重写指定初始化器（Override Designated Initializer）</h3>
<blockquote>
<p>When writing a subclass that requires an <code>init...</code> method, make sure you<br>
override the designated initializer of the superclass.</p>
</blockquote>
<p>若实现一个类需要 <code>init...</code> 方法，必须重写父类的指定初始化器。</p>
<blockquote>
<p>If you fail to override the designated initializer of the superclass, your<br>
initializer may not be called in all cases, leading to subtle and very difficult<br>
to find bugs.</p>
</blockquote>
<p>如果不重写父类的指定初始化器，你自己的初始化器可能不会保证在所有情况下都被调用，这会导致bug很诡异，难以被发现。</p>
<h3 id="nsobjectoverriddennsobjectmethodplacement">NSObject重写方法的放置位置（Overridden NSObject Method Placement)</h3>
<blockquote>
<p>Put overridden methods of NSObject at the top of an <code>@implementation</code>.</p>
</blockquote>
<p>将NSObject的重写方法置于<code>@implementation</code>部分的顶部。</p>
<blockquote>
<p>This commonly applies to (but is not limited to) the <code>init...</code>, <code>copyWithZone:</code>,<br>
and <code>dealloc</code> methods. The <code>init...</code> methods should be grouped together,<br>
followed by other typical <code>NSObject</code> methods such as <code>description</code>, <code>isEqual:</code>,<br>
and <code>hash</code>.</p>
</blockquote>
<p>这通常用于但不局限于 <code>init...</code>, <code>copyWithZone:</code>, <code>dealloc</code>方法。 <code>init…</code> 一类的方法要集合放置在一起，后面可以放置其他 <code>NSObject</code> 常用方法，例如 <code>description</code>, <code>isEqual:</code>和 <code>hash</code>。</p>
<blockquote>
<p>Convenience class factory methods for creating instances may precede the<br>
<code>NSObject</code> methods.</p>
</blockquote>
<p>便捷的创建对象的工厂方法可以放置在<code>NSObject</code> 之前。</p>
<h3 id="initialization">初始化（Initialization）</h3>
<blockquote>
<p>Don't initialize instance variables to <code>0</code> or <code>nil</code> in the <code>init</code> method; doing<br>
so is redundant.</p>
</blockquote>
<p>不必在 <code>init</code> 方法中初始化实例变量为 <code>0</code> 或 <code>nil</code> ，多余！</p>
<blockquote>
<p>All instance variables for a newly allocated object are <a href="https://developer.apple.com/library/mac/documentation/General/Conceptual/CocoaEncyclopedia/ObjectAllocation/ObjectAllocation.html">initialized to</a><br>
<code>0</code> (except for isa), so don't clutter up the init method by re-initializing<br>
variables to <code>0</code> or <code>nil</code>.</p>
</blockquote>
<p>所有新创建的实例变量都会被初始化为0（isa除外），所以不必散乱的在init初始化方法中将实例变量初始化为 <code>0</code> 或 <code>nil</code>。</p>
<h3 id="protectedprivateinstancevariablesinheadersshouldbeprotectedorprivate">头文件中的实例变量的作用域应该是@protected或@private（Instance Variables In Headers Should Be @protected or @private）</h3>
<blockquote>
<p>Instance variables should typically be declared in implementation files or<br>
auto-synthesized by properties. When ivars are declared in a header file, they<br>
should be marked <code>@protected</code> or <code>@private</code>.</p>
</blockquote>
<p>实例变量通常被放置在头文件中，或通过property被自动synthesize。若实例变量被声明在头文件中，这些成员变量需要被标记为 <code>@protected</code> 或 <code>@private</code>。</p>
<pre><code class="language-objectivec">// GOOD:

@interface MyClass : NSObject {
 @protected
  id _myInstanceVariable;
}
@end
</code></pre>
<h3 id="newdonotusenew">不要使用+new（Do Not Use +new）</h3>
<blockquote>
<p>Do not invoke the <code>NSObject</code> class method <code>new</code>, nor override it in a subclass.<br>
<code>+new</code> is rarely used and contrasts greatly with initializer usage. Instead, use<br>
<code>+alloc</code> and <code>-init</code> methods to instantiate retained objects.</p>
</blockquote>
<p>不可调用NSObject的类方法<code>new</code>或在子类中重写该方法。<code>+new</code>方法很少使用，与初始化器的使用有很大的不同。相反，一般使用+alloc和-init方法来创建和初始化实例对象。</p>
<h3 id="apikeepthepublicapisimple">公开API保持简单（Keep the Public API Simple）</h3>
<blockquote>
<p>Keep your class simple; avoid &quot;kitchen-sink&quot; APIs. If a method doesn't need to<br>
be public, keep it out of the public interface.</p>
</blockquote>
<p>保持类简单，避免“kitchen-sink”（激进现实主义）API。如果一个方法不需要作为公开方法，请不要暴露在公开接口中。</p>
<blockquote>
<p>Unlike C++, Objective-C doesn't differentiate between public and private<br>
methods; any message may be sent to an object. As a result, avoid placing<br>
methods in the public API unless they are actually expected to be used by a<br>
consumer of the class. This helps reduce the likelihood they'll be called when<br>
you're not expecting it. This includes methods that are being overridden from<br>
the parent class.</p>
</blockquote>
<p>和C++不同，Objective-C在公开方法和私有方法之间并没有什么太多区分，任何消息都可能被发送给对象。因此，只有使用者需要调用某一个方法时，才把这个方法放置在公开的API中。这样可以降低一些你不希望外界调用的方法被调用的可能性，这也包括重写的父类方法。</p>
<blockquote>
<p>Since internal methods are not really private, it's easy to accidentally<br>
override a superclass's &quot;private&quot; method, thus making a very difficult bug to<br>
squash. In general, private methods should have a fairly unique name that will<br>
prevent subclasses from unintentionally overriding them.</p>
</blockquote>
<p>因为内部方法并不是真正的私有方法，也容易碰巧重写一个父类的私有方法，这样会导致很难排除由此引起的bug。通常隐私方法需要有一个较为独特的名字，这样可以防止子类无意的重写这些方法。</p>
<h3 id="importincludeimportandinclude">#import和#include（#import and #include）</h3>
<blockquote>
<p><code>#import</code> Objective-C and Objective-C++ headers, and <code>#include</code> C/C++ headers.</p>
</blockquote>
<p>使用<code>#import</code>引用Objective-C 和 Objective-C++头文件，用<code>#include</code> C/C++头文件。</p>
<blockquote>
<p>C/C++ headers include other C/C++ headers using <code>#include</code>. Using <code>#import</code><br>
on C/C++ headers prevents future inclusions using <code>#include</code> and could result in<br>
unintended compilation behavior.<br>
C/C++ headers should provide their own <code>#define</code> guard.</p>
</blockquote>
<p>C/C++头文件中引用其他C/C++头文件使用<code>#include</code>。使用<code>#import</code>引用C/C++头文件，以避免后面使用 <code>#include</code> 可能导致的头文件冲突和编译问题。</p>
<p>C/C++每个头文件中需要有自己<code>#define</code>保护，（以防止头文件被重复引用导致的重复编译的问题）。</p>
<h3 id="orderofincludes">头文件引用顺序（Order of Includes）</h3>
<blockquote>
<p>The standard order for header inclusion is the related header, operating system<br>
headers, language library headers, and finally groups of headers for other<br>
dependencies.</p>
</blockquote>
<p>标准头文件引用顺序为相关头文件、系统头文件、语言库头文件，最终是其他引用头文件。</p>
<blockquote>
<p>The related header precedes others to ensure it has no hidden dependencies.<br>
For implementation files the related header is the header file.<br>
For test files the related header is the header containing the tested interface.</p>
</blockquote>
<p>相关头文件放在其他头文件前，可以保证其他隐藏依赖。对于implementation文件，它的相关头文件就是它自己的头文件。对于测试文件，它的相关头文件就是包含被测试接口的头文件。</p>
<blockquote>
<p>A blank line may separate logically distinct groups of included headers.</p>
</blockquote>
<p>使用空行来区分不同类别的头文件。</p>
<blockquote>
<p>Within each group the includes should be ordered alphabetically.</p>
</blockquote>
<p>不同类别的头文件，需要按字母顺序排列。</p>
<blockquote>
<p>Import headers using their path relative to the project's source directory.</p>
</blockquote>
<p>以工程目录作为根目录，使用相对路径引用头文件。</p>
<pre><code class="language-objectivec">// GOOD:

#import &quot;ProjectX/BazViewController.h&quot;

#import &lt;Foundation/Foundation.h&gt;

#include &lt;unistd.h&gt;
#include &lt;vector&gt;

#include &quot;base/basictypes.h&quot;
#include &quot;base/integral_types.h&quot;
#include &quot;util/math/mathutil.h&quot;

#import &quot;ProjectX/BazModel.h&quot;
#import &quot;Shared/Util/Foo.h&quot;
</code></pre>
<h3 id="umbrellauseumbrellaheadersforsystemframeworks">使用系统库Umbrella头文件（Use Umbrella Headers for System Frameworks）</h3>
<blockquote>
<p>Import umbrella headers for system frameworks and system libraries rather than<br>
include individual files.</p>
</blockquote>
<p>引用系统库的umbrella头文件，而不是引用某几个单独的头文件。（关于umbrella头文件，更像是一个库中专门暴露出来，供外界使用者去引用的头文件，而不是引用库中的某些头文件，详细解析请Google）</p>
<blockquote>
<p>While it may seem tempting to include individual system headers from a framework<br>
such as Cocoa or Foundation, in fact it's less work on the compiler if you<br>
include the top-level root framework. The root framework is generally<br>
pre-compiled and can be loaded much more quickly. In addition, remember to use<br>
<code>@import</code> or <code>#import</code> rather than <code>#include</code> for Objective-C frameworks.</p>
</blockquote>
<p>人们似乎更倾向引用Cocoa或Foundation系统库中单独的头文件，这样看起来引用更简单，但事实上，引用系统库的顶层头文件会让编译器做更少的工作。根框架通常会预处理，从而加载速度更快。另外，对于Objective-C框架，记住使用<code>@import</code>和<code>#import</code>，而不使用 <code>#include</code> 。</p>
<pre><code class="language-objectivec">// GOOD:

@import UIKit;     // GOOD.
#import &lt;Foundation/Foundation.h&gt;     // GOOD.
</code></pre>
<pre><code class="language-objectivec">// AVOID:

#import &lt;Foundation/NSArray.h&gt;        // AVOID.
#import &lt;Foundation/NSString.h&gt;
...
</code></pre>
<h3 id="deallocavoidmessagingthecurrentobjectwithininitializersanddealloc">避免在初始化器或<code>-dealloc</code>中给当前对象发消息（Avoid Messaging the Current Object Within Initializers and <code>-dealloc</code>）</h3>
<blockquote>
<p>Code in initializers and <code>-dealloc</code> should avoid invoking instance methods.</p>
</blockquote>
<p>初始化器或 <code>-dealloc</code>方法中，避免调用该类对象的实例方法。</p>
<blockquote>
<p>Superclass initialization completes before subclass initialization. Until all<br>
classes have had a chance to initialize their instance state any method<br>
invocation on self may lead to a subclass operating on uninitialized instance<br>
state.</p>
</blockquote>
<p>父类的初始化方法先于子类初始化方法执行。在所有类都被初始化，使该对象的所有属性被初始化之前调用该类的示例方法，都可能导致子类直接操作未初始化的属性。</p>
<blockquote>
<p>A similar issue exists for <code>-dealloc</code>, where a method invocation may cause a<br>
class to operate on state that has been deallocated.</p>
</blockquote>
<p><code>-dealloc</code>方法中也存在类似问题，例如在<code>-dealloc</code>调用一些实例方法，这些方法操作的某些属性，可能早已被释放掉了。</p>
<blockquote>
<p>One case where this is less obvious is property accessors. These can be<br>
overridden just like any other selector. Whenever practical, directly assign to<br>
and release ivars in initializers and <code>-dealloc</code>, rather than rely on accessors.</p>
</blockquote>
<p>属性访问是一种不太明显的案例。属性访问器可以像其他selector一样被重写。一旦切实可行，直接在初始化器和<code>-dealloc</code>方法中对成员变量进行赋值和释放，而不是通过属性访问器来完成。</p>
<pre><code class="language-objectivec">// GOOD:

- (instancetype)init {
  self = [super init];
  if (self) {
    _bar = 23;  // GOOD.
  }
  return self;
}
</code></pre>
<blockquote>
<p>Beware of factoring common initialization code into helper methods:</p>
<ul>
<li>Methods can be overridden in subclasses, either deliberately, or<br>
accidentally due to naming collisions.</li>
<li>When editing a helper method, it may not be obvious that the code is being<br>
run from an initializer.</li>
</ul>
</blockquote>
<p>拆解通用初始化代码为工具方法要谨慎！</p>
<ul>
<li>工具方法可能会有意或无意的被子类重写，或者碰巧产生了命名冲突；</li>
<li>当编辑一个工具方法时，可能不会知晓这段代码是被初始化方法调用的；</li>
</ul>
<pre><code class="language-objectivec">// AVOID:

- (instancetype)init {
  self = [super init];
  if (self) {
    self.bar = 23;  // AVOID.
    [self sharedMethod];  // AVOID. Fragile to subclassing or future extension.
  }
  return self;
}
</code></pre>
<pre><code class="language-objectivec">// GOOD:

- (void)dealloc {
  [_notifier removeObserver:self];  // GOOD.
}
</code></pre>
<pre><code class="language-objectivec">// AVOID:

- (void)dealloc {
  [self removeNotifications];  // AVOID.
}
</code></pre>
<h3 id="setternsstringscopysetterscopynsstrings">Setter方法中NSStrings要Copy（Setters copy NSStrings）</h3>
<blockquote>
<p>Setters taking an <code>NSString</code> should always copy the string it accepts. This is<br>
often also appropriate for collections like <code>NSArray</code> and <code>NSDictionary</code>.</p>
</blockquote>
<p>Setter方法中对传入的<code>NSString</code>参数必须copy一份再使用，同样，对于容器类参数，例如 <code>NSArray</code>、 <code>NSDictionary</code>，也需要copy再使用。</p>
<blockquote>
<p>Never just retain the string, as it may be a <code>NSMutableString</code>. This avoids the<br>
caller changing it under you without your knowledge.</p>
</blockquote>
<p>永远不要只考虑是string类型，也可能（传入的）是<code>NSMutableString</code>类型。这可以避免在你不知情的情况下，调用方修改该值。</p>
<blockquote>
<p>Code receiving and holding collection objects should also consider that the<br>
passed collection may be mutable, and thus the collection could be more safely<br>
held as a copy or mutable copy of the original.</p>
</blockquote>
<p>持有容器对象参数也需要考虑该对象可能也是可变的，因此，使用该容器参数的复制对象，相对更安全。</p>
<pre><code class="language-objectivec">// GOOD:

@property(nonatomic, copy) NSString *name;

- (void)setZigfoos:(NSArray&lt;Zigfoo *&gt; *)zigfoos {
  // Ensure that we're holding an immutable collection.
  _zigfoos = [zigfoos copy];
}
</code></pre>
<h3 id="uselightweightgenericstodocumentcontainedtypes">用泛型标识元素类型（Use Lightweight Generics to Document Contained Types）</h3>
<blockquote>
<p>All projects compiling on Xcode 7 or newer versions should make use of the<br>
Objective-C lightweight generics notation to type contained objects.</p>
</blockquote>
<p>在Xcode7或更新版本编译的工程，应该使用Objective-C轻量级泛型符号来标识其包含的对象类别。</p>
<blockquote>
<p>Every <code>NSArray</code>, <code>NSDictionary</code>, or <code>NSSet</code> reference should be declared using<br>
lightweight generics for improved type safety and to explicitly document usage.</p>
</blockquote>
<p><code>NSArray</code>, <code>NSDictionary</code>, 或 <code>NSSet</code>对象都需要轻量级泛型符号标明，这可以改善类型安全以及明确文档使用说明。</p>
<pre><code class="language-objectivec">// GOOD:

@property(nonatomic, copy) NSArray&lt;Location *&gt; *locations;
@property(nonatomic, copy, readonly) NSSet&lt;NSString *&gt; *identifiers;

NSMutableArray&lt;MyLocation *&gt; *mutableLocations = [otherObject.locations mutableCopy];
</code></pre>
<blockquote>
<p>If the fully-annotated types become complex, consider using a typedef to<br>
preserve readability.</p>
</blockquote>
<p>若要标识的泛型比较复杂，可以考虑使用typedef定义新类型，以保持可读性。</p>
<pre><code class="language-objectivec">// GOOD:

typedef NSSet&lt;NSDictionary&lt;NSString *, NSDate *&gt; *&gt; TimeZoneMappingSet;
TimeZoneMappingSet *timeZoneMappings = [TimeZoneMappingSet setWithObjects:...];
</code></pre>
<blockquote>
<p>Use the most descriptive common superclass or protocol available. In the most<br>
generic case when nothing else is known, declare the collection to be explicitly<br>
heterogenous using id.</p>
</blockquote>
<p>使用最具描述性的常用父类或协议。通常情况下，当不知道容器中对象类型时，使用id显式声明。</p>
<pre><code class="language-objectivec">// GOOD:

@property(nonatomic, copy) NSArray&lt;id&gt; *unknowns;
</code></pre>
<h3 id="avoidthrowingexceptions">避免抛异常（Avoid Throwing Exceptions）</h3>
<blockquote>
<p>Don't <code>@throw</code> Objective-C exceptions, but you should be prepared to catch them<br>
from third-party or OS calls.</p>
</blockquote>
<p>不要使用<code>@throw</code> 抛出Objective-C异常，但在使用第三库或系统调用时，你还必须要考虑如何捕获异常。</p>
<blockquote>
<p>This follows the recommendation to use error objects for error delivery in<br>
<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Exceptions/Exceptions.html">Apple's Introduction to Exception Programming Topics for<br>
Cocoa</a>.</p>
</blockquote>
<p>这遵循关于错误对象错误传递的推荐说明文档：<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Exceptions/Exceptions.html">Apple's Introduction to Exception Programming Topics for<br>
Cocoa</a>.</p>
<blockquote>
<p>We do compile with <code>-fobjc-exceptions</code> (mainly so we get <code>@synchronized</code>), but<br>
we don't <code>@throw</code>. Use of <code>@try</code>, <code>@catch</code>, and <code>@finally</code> are allowed when<br>
required to properly use 3rd party code or libraries. If you do use them, please<br>
document exactly which methods you expect to throw.</p>
</blockquote>
<p>我们编译时使用编译选项<code>-fobjc-exceptions</code>（通常也用<code>@synchronized</code>），但我们不使用<code>@throw</code>。当使用第三方库或代码时， <code>@try</code>, <code>@catch</code>和 <code>@finally</code> 是被允许使用的。如果确定使用了这些关键字，请清晰明确的指明哪些方法会抛出异常。</p>
<h3 id="nilnilchecks"><code>nil</code>检查 （<code>nil</code> Checks）</h3>
<blockquote>
<p>Avoid <code>nil</code> pointer checks that exist only to prevent sending messages to <code>nil</code>.<br>
Sending a message to <code>nil</code> <a href="http://www.sealiesoftware.com/blog/archive/2012/2/29/objc_explain_return_value_of_message_to_nil.html">reliably returns</a></p>
<p><code>nil</code> as a pointer, zero as an integer or floating-point value, structs initialized to <code>0</code>, and <code>_Complex</code> values equal to <code>{0, 0}</code>.</p>
</blockquote>
<p>如果指针检查只是为了防止给nil对象发消息，那这部分检查不必添加。</p>
<p>给<code>nil</code>发消息的返回值是可靠的</p>
<p>返回值是指针时，返回nil；返回值是整数或浮点数时，返回0；返回值是结构体时，返回0；返回值是<code>_Complex</code>时，返回 <code>{0, 0}</code>。</p>
<p><em>(上面这句我也没读懂，我也不打算不懂装懂)</em></p>
<pre><code class="language-objectivec">// AVOID:

if (dataSource) {  // AVOID.
  [dataSource moveItemAtIndex:1 toIndex:0];
}
</code></pre>
<pre><code class="language-objectivec">// GOOD:

[dataSource moveItemAtIndex:1 toIndex:0];  // GOOD.
</code></pre>
<blockquote>
<p>Note that this applies to <code>nil</code> as a message target, not as a parameter value.<br>
Individual methods may or may not safely handle <code>nil</code> parameter values.</p>
</blockquote>
<p>注意：这适用于 <code>nil</code> 作为消息接受者，而不是作为参数值。</p>
<p>个别方法可能会，也可能不会安全处理nil参数值。</p>
<blockquote>
<p>Note too that this is distinct from checking C/C++ pointers and block pointers<br>
against <code>NULL</code>, which the runtime does not handle and will cause your<br>
application to crash. You still need to make sure you do not dereference a<br>
<code>NULL</code> pointer.</p>
</blockquote>
<p>也请注意这区别于检查C/C++指针和block指针是否为<code>NULL</code>, 这些运行时不会处理，这些会导致应用崩溃。你仍然需要检查指针不能为<code>NULL</code>。</p>
<h3 id="nullability">可空性（Nullability）</h3>
<blockquote>
<p>Interfaces can be decorated with nullability annotations to describe how the<br>
interface should be used and how it behaves. Use of nullability regions (e.g.,<br>
<code>NS_ASSUME_NONNULL_BEGIN</code> and <code>NS_ASSUME_NONNULL_END</code>) and explicit nullability<br>
annotations are both accepted. Prefer using the <code>_Nullable</code> and <code>_Nonnull</code><br>
keywords over the <code>__nullable</code> and <code>__nonnull</code> keywords. For Objective-C methods<br>
and properties prefer using the context-sensitive, non-underscored keywords,<br>
e.g., <code>nonnull</code> and <code>nullable</code>.</p>
</blockquote>
<p>Interface中可以使用可空性注解来描述接口行为和如何使用。使用可控性作用域（例如<code>NS_ASSUME_NONNULL_BEGIN</code> 和 <code>NS_ASSUME_NONNULL_END</code>）或使用可控性注解，这两种方式都是可以的。相对 <code>__nullable</code> 和 <code>__nonnull</code> 关键字，更推荐使用 <code>_Nullable</code>和 <code>_Nonnull</code>。对于Objective-C方法和属性，推荐使用无下划线的关键字，例如<code>nonnull</code> 和 <code>nullable</code>。</p>
<pre><code class="language-objectivec">// GOOD:

/** A class representing an owned book. */
@interface GTMBook : NSObject

/** The title of the book. */
@property(readonly, copy, nonnull) NSString *title;

/** The author of the book, if one exists. */
@property(readonly, copy, nullable) NSString *author;

/** The owner of the book. Setting nil resets to the default owner. */
@property(copy, null_resettable) NSString *owner;

/** Initializes a book with a title and an optional author. */
- (nonnull instancetype)initWithTitle:(nonnull NSString *)title
                               author:(nullable NSString *)author
    NS_DESIGNATED_INITIALIZER;

/** Returns nil because a book is expected to have a title. */
- (nullable instancetype)init;

@end

/** Loads books from the file specified by the given path. */
NSArray&lt;GTMBook *&gt; *_Nullable GTMLoadBooksFromFile(NSString *_Nonnull path);
</code></pre>
<pre><code class="language-objectivec">// AVOID:

NSArray&lt;GTMBook *&gt; *__nullable GTMLoadBooksFromTitle(NSString *__nonnull path);
</code></pre>
<blockquote>
<p>Be careful assuming that a pointer is not null based on a non-null qualifier<br>
because the compiler may not guarantee that the pointer is not null.</p>
</blockquote>
<p>如果标识符标注某个指针不为空，也不要轻信，因为编译器可不能保证该指针不为空。</p>
<h3 id="boolboolpitfalls">BOOL陷阱（BOOL Pitfalls）</h3>
<blockquote>
<p>Be careful when converting general integral values to <code>BOOL</code>. Avoid comparing<br>
directly with <code>YES</code>.</p>
</blockquote>
<p>将整型数值转换为<code>BOOL</code>要小心。避免直接和 <code>YES</code>直接进行比较。</p>
<blockquote>
<p><code>BOOL</code> in OS X and in 32-bit iOS builds is defined as a signed <code>char</code>, so it may<br>
have values other than <code>YES</code> (<code>1</code>) and <code>NO</code> (<code>0</code>). Do not cast or convert<br>
general integral values directly to <code>BOOL</code>.</p>
</blockquote>
<p>在OSX和32位iOS系统版本中，<code>BOOL</code> 类型被定义为有符号<code>char</code>类型，所以，它可以是除了<code>YES</code> (<code>1</code>) and <code>NO</code> (<code>0</code>)之外的其他值。切勿将整数值直接赋值或强制类型转换后赋值给<code>BOOL</code>值。</p>
<blockquote>
<p>Common mistakes include casting or converting an array's size, a pointer value,<br>
or the result of a bitwise logic operation to a <code>BOOL</code> that could, depending on<br>
the value of the last byte of the integer value, still result in a <code>NO</code> value.<br>
When converting a general integral value to a <code>BOOL</code>, use ternary operators to<br>
return a <code>YES</code> or <code>NO</code> value.</p>
</blockquote>
<p>常见错误包括将强转或转换数组大小、指针值或者通过逻辑位运算结果赋值给<code>BOOL</code>变量，根据整数最后一个字节的值，结果仍然有可能会产生<code>NO</code>值。在将一个整数转换为<code>BOOL</code>值时，需要使用三元运算符来保证返回值是<code>YES</code> 或 <code>NO</code>。</p>
<blockquote>
<p>You can safely interchange and convert <code>BOOL</code>, <code>_Bool</code> and <code>bool</code> (see C++ Std<br>
4.7.4, 4.12 and C99 Std 6.3.1.2). Use <code>BOOL</code> in Objective-C method signatures.</p>
</blockquote>
<p>Objective-C方法签名中使用<code>BOOL</code>，你可以安全的来转换 <code>BOOL</code>, <code>_Bool</code> and <code>bool</code>值（参考see C++ Std 4.7.4, 4.12 and C99 Std 6.3.1.2）。</p>
<blockquote>
<p>Using logical operators (<code>&amp;&amp;</code>, <code>||</code> and <code>!</code>) with <code>BOOL</code> is also valid and will<br>
return values that can be safely converted to <code>BOOL</code> without the need for a<br>
ternary operator.</p>
</blockquote>
<p>也可以使用逻辑运算符(<code>&amp;&amp;</code>、 <code>||</code>、 <code>!</code>)来获取 <code>BOOL</code> 值，这种方法也可以不使用三元运算符来安全转换 <code>BOOL</code> 值。</p>
<pre><code class="language-objectivec">// AVOID:

- (BOOL)isBold {
  return [self fontTraits] &amp; NSFontBoldTrait;  // AVOID.
}
- (BOOL)isValid {
  return [self stringValue];  // AVOID.
}
</code></pre>
<pre><code class="language-objectivec">// GOOD:

- (BOOL)isBold {
  return ([self fontTraits] &amp; NSFontBoldTrait) ? YES : NO;
}
- (BOOL)isValid {
  return [self stringValue] != nil;
}
- (BOOL)isEnabled {
  return [self isValid] &amp;&amp; [self isBold];
}
</code></pre>
<blockquote>
<p>Also, don't directly compare <code>BOOL</code> variables directly with <code>YES</code>. Not only is<br>
it harder to read for those well-versed in C, but the first point above<br>
demonstrates that return values may not always be what you expect.</p>
</blockquote>
<p>同样，不要将 <code>BOOL</code> 值和<code>YES</code>进行直接比较。这样做不仅仅是因为对于精通C语言的人可能难以理解，而是返回值可能并不总是和预期一致（容易引起逻辑错误），这才是真正原因。</p>
<pre><code class="language-objectivec">// AVOID:

BOOL great = [foo isGreat];
if (great == YES) {  // AVOID.
  // ...be great!
}
</code></pre>
<pre><code class="language-objectivec">// GOOD:

BOOL great = [foo isGreat];
if (great) {         // GOOD.
  // ...be great!
}
</code></pre>
<h3 id="interfaceinterfaceswithoutinstancevariables">无实例变量的Interface（Interfaces Without Instance Variables）</h3>
<blockquote>
<p>Omit the empty set of braces on interfaces that do not declare any instance<br>
variables.</p>
</blockquote>
<p>若interface不声明任何实例变量，省略空的大括号。</p>
<pre><code class="language-objectivec">// GOOD:

@interface MyClass : NSObject
// Does a lot of stuff.
- (void)fooBarBam;
@end
</code></pre>
<pre><code class="language-objectivec">// AVOID:

@interface MyClass : NSObject {
}
// Does a lot of stuff.
- (void)fooBarBam;
@end
</code></pre>
<h2 id="cocoacocoapatterns">Cocoa模式（Cocoa Patterns）</h2>
<h3 id="delegatedelegatepattern">Delegate模式（Delegate Pattern）</h3>
<blockquote>
<p>Delegates, target objects, and block pointers should not be retained when doing<br>
so would create a retain cycle.</p>
</blockquote>
<p>Delegate，target对象，block指针不可使用retain，不然会产生循环引用。</p>
<blockquote>
<p>To avoid causing a retain cycle, a delegate or target pointer should be released<br>
as soon as it is clear there will no longer be a need to message the object.</p>
</blockquote>
<p>为避免引起循环引用，delegate或响应对象指针需要被及时清理，以便后续发送的消息不再被响应。</p>
<blockquote>
<p>If there is no clear time at which the delegate or target pointer is no longer<br>
needed, the pointer should only be retained weakly.</p>
</blockquote>
<p>若delegate或响应对象指针在后续不被需要时，没有一个清晰的时间点，那么该delegate或响应对象指针应该被设置为弱引用。</p>
<blockquote>
<p>Block pointers cannot be retained weakly. To avoid causing retain cycles in the<br>
client code, block pointers should be used for callbacks only where they can be<br>
explicitly released after they have been called or once they are no longer<br>
needed. Otherwise, callbacks should be done via weak delegate or target<br>
pointers.</p>
</blockquote>
<p>Block指针不可使用弱引用。为避免在客户端代码中出现循环引用，block指针只有在被调用一次或者他们不被需要时会被明确的清理，才可以用于回调方法。否则，回调方法应该通过弱引用的delegate或者响应对象指针来实现。</p>
<h2 id="objectivec">Objective-C++</h2>
<h3 id="stylematchesthelanguage">代码风格与所用语言保持一致（Style Matches the Language）</h3>
<blockquote>
<p>Within an Objective-C++ source file, follow the style for the language of the<br>
function or method you're implementing. In order to minimize clashes between the<br>
differing naming styles when mixing Cocoa/Objective-C and C++, follow the style<br>
of the method being implemented.</p>
</blockquote>
<p>对于Objective-C++源码文件，遵守函数或方法实现语言的编码规范。为了将Cocoa/Objective-C、C++不同语言混合使用导致的命名风格冲突最小化，遵守源码中方法实现使用的编码风格。</p>
<blockquote>
<p>For code in an <code>@implementation</code> block, use the Objective-C naming rules. For<br>
code in a method of a C++ class, use the C++ naming rules.</p>
</blockquote>
<p>对于 <code>@implementation</code>代码，使用Objective-C命名规范。对于C++类中方法代码，使用C++命名规范。</p>
<blockquote>
<p>For code in an Objective-C++ file outside of a class implementation, be<br>
consistent within the file.</p>
</blockquote>
<p>对于Objective-C++文件类实现部分之外的代码，与该文件代码风格保持一致。</p>
<pre><code class="language-objectivec++">// GOOD:

// file: cross_platform_header.h

class CrossPlatformAPI {
 public:
  ...
  int DoSomethingPlatformSpecific();  // impl on each platform
 private:
  int an_instance_var_;
};

// file: mac_implementation.mm
#include &quot;cross_platform_header.h&quot;

/** A typical Objective-C class, using Objective-C naming. */
@interface MyDelegate : NSObject {
 @private
  int _instanceVar;
  CrossPlatformAPI* _backEndObject;
}

- (void)respondToSomething:(id)something;

@end

@implementation MyDelegate

- (void)respondToSomething:(id)something {
  // bridge from Cocoa through our C++ backend
  _instanceVar = _backEndObject-&gt;DoSomethingPlatformSpecific();
  NSString* tempString = [NSString stringWithFormat:@&quot;%d&quot;, _instanceVar];
  NSLog(@&quot;%@&quot;, tempString);
}

@end

/** The platform-specific implementation of the C++ class, using C++ naming. */
int CrossPlatformAPI::DoSomethingPlatformSpecific() {
  NSString* temp_string = [NSString stringWithFormat:@&quot;%d&quot;, an_instance_var_];
  NSLog(@&quot;%@&quot;, temp_string);
  return [temp_string intValue];
}
</code></pre>
<blockquote>
<p>Projects may opt to use an 80 column line length limit for consistency with<br>
Google's C++ style guide.</p>
</blockquote>
<p>工程中可能选择使用80个字符列宽限制，以便和Google的C++代码规范保持一致。</p>
<h2 id="spacingandformatting">空间布局和格式（Spacing and Formatting）</h2>
<h3 id="vsspacesvstabs">空格 vs 制表符（Spaces vs. Tabs）</h3>
<blockquote>
<p>Use only spaces, and indent 2 spaces at a time. We use spaces for indentation.<br>
Do not use tabs in your code.</p>
</blockquote>
<p>只使用空格，缩进量为2个空格宽度。缩进时不使用制表符，只用空格。</p>
<blockquote>
<p>You should set your editor to emit spaces when you hit the tab key, and to trim<br>
trailing spaces on lines.</p>
</blockquote>
<p>设置编辑器使用空格自动替换制表符，并消除行位空格。</p>
<h3 id="linelength">行宽（Line Length）</h3>
<blockquote>
<p>The maximum line length for Objective-C files is 100 columns.</p>
</blockquote>
<blockquote>
<p>You can make violations easier to spot by enabling <em>Preferences &gt; Text Editing &gt;<br>
Page guide at column: 100</em> in Xcode.</p>
</blockquote>
<p>Objective-C最大行宽为100列（100字符宽度）。在xCode中，通过设置Preferences &gt; Text Editing &gt; Page guide at column:为100，可以轻松检查超宽地方。</p>
<h3 id="methoddeclarationsanddefinitions">方法声明与定义（Method Declarations and Definitions）</h3>
<blockquote>
<p>One space should be used between the <code>-</code> or <code>+</code> and the return type, and no<br>
spacing in the parameter list except between parameters.</p>
</blockquote>
<p><code>-</code> or <code>+</code> 后与返回值之间须有一个空格，参数名与参数类型间无空格，参数列表不同参数间有一个空格；</p>
<blockquote>
<p>Methods should look like this:</p>
</blockquote>
<p>方法示例如下：</p>
<pre><code class="language-objectivec">// GOOD:

- (void)doSomethingWithString:(NSString *)theString {
  ...
}
</code></pre>
<blockquote>
<p>The spacing before the asterisk is optional. When adding new code, be consistent<br>
with the surrounding file's style.</p>
</blockquote>
<p>星号前可以有一个空格。新添加的代码要与文件代码风格保持一致。</p>
<blockquote>
<p>If a method declaration does not fit on a single line, put each parameter on its<br>
own line. All lines except the first should be indented at least four spaces.<br>
Colons before parameters should be aligned on all lines. If the colon before the<br>
parameter on the first line of a method declaration is positioned such that<br>
colon alignment would cause indentation on a subsequent line to be less than<br>
four spaces, then colon alignment is only required for all lines except the<br>
first.</p>
</blockquote>
<p>如果一个方法声明一行放不下，需要将不同参数各占一行。除首行外，其余所有行都要至少缩进4个空格。不同参数前的冒号要对齐。如果方法声明第一行中参数前的冒号所在位置，对齐所有冒号后，后面的参数前面缩进的空格数少于4个，这种情况只需要将函数声明中第一行之外的其他行冒号对齐即可。</p>
<pre><code class="language-objectivec">// GOOD:

- (void)doSomethingWithFoo:(GTMFoo *)theFoo
                      rect:(NSRect)theRect
                  interval:(float)theInterval {
  ...
}

- (void)shortKeyword:(GTMFoo *)theFoo
            longerKeyword:(NSRect)theRect
    someEvenLongerKeyword:(float)theInterval
                    error:(NSError **)theError {
  ...
}

- (id&lt;UIAdaptivePresentationControllerDelegate&gt;)
    adaptivePresentationControllerDelegateForViewController:(UIViewController *)viewController;

- (void)presentWithAdaptivePresentationControllerDelegate:
    (id&lt;UIAdaptivePresentationControllerDelegate&gt;)delegate;
</code></pre>
<h3 id="functiondeclarationsanddefinitions">方法声明与定义（Function Declarations and Definitions）</h3>
<blockquote>
<p>Prefer putting the return type on the same line as the function name and append<br>
all parameters on the same line if they will fit. Wrap parameter lists which do<br>
not fit on a single line as you would wrap arguments in a <a href="index.html#Function_Calls">function<br>
call</a>.</p>
</blockquote>
<p>将方法返回类型和方法名放于同一行，后面跟其他参数，如果一行能放下，则参数放于同一行。若一行放不下，就像函数调用一样，来包装参数列表。</p>
<pre><code class="language-objectivec">// GOOD:

NSString *GTMVersionString(int majorVersion, minorVersion) {
  ...
}

void GTMSerializeDictionaryToFileOnDispatchQueue(
    NSDictionary&lt;NSString *, NSString *&gt; *dictionary,
    NSString *filename,
    dispatch_queue_t queue) {
  ...
}
</code></pre>
<blockquote>
<p>Function declarations and definitions should also satisfy the following<br>
conditions:</p>
<ul>
<li>The opening parenthesis must always be on the same line as the function<br>
name.</li>
<li>If you cannot fit the return type and the function name on a single line,<br>
break between them and do not indent the function name.</li>
<li>There should never be a space before the opening parenthesis.</li>
<li>There should never be a space between function parentheses and parameters.</li>
<li>The open curly brace is always on the end of the last line of the function<br>
declaration, not the start of the next line.</li>
<li>The close curly brace is either on the last line by itself or on the same<br>
line as the open curly brace.</li>
<li>There should be a space between the close parenthesis and the open curly<br>
brace.</li>
<li>All parameters should be aligned if possible.</li>
<li>Function scopes should be indented 2 spaces.</li>
<li>Wrapped parameters should have a 4 space indent.</li>
</ul>
</blockquote>
<p>函数声明和定义也需要满足以下条件：</p>
<ul>
<li>函数名后的左括号必须和函数名在同一行；</li>
<li>若返回值类型和函数名不能放在同一行，在他们之间换行，并且不缩进函数名；</li>
<li>函数名后的左括号前无空格；</li>
<li>函数括号和参数间无空格；</li>
<li>函数左大括号在函数声明后，不可另起一行；</li>
<li>函数右大括号在函数最后独占一行，或和左大括号同一行；</li>
<li>函数左大括号和函数参数右括号间，有一个空格；</li>
<li>所有参数尽量对齐（冒号对齐）；</li>
<li>函数作用域缩进2个空格；</li>
<li>封装参数缩进4个空格；</li>
</ul>
<h3 id="conditionals">条件判断（Conditionals）</h3>
<blockquote>
<p>Include a space after <code>if</code>, <code>while</code>, <code>for</code>, and <code>switch</code>, and around comparison<br>
operators.</p>
</blockquote>
<p><code>if</code>, <code>while</code>, <code>for</code>,  <code>switch</code>后有一个空格，比较运算符两边有空格。</p>
<pre><code class="language-objectivec">// GOOD:

for (int i = 0; i &lt; 5; ++i) {
}

while (test) {};
</code></pre>
<blockquote>
<p>Braces may be omitted when a loop body or conditional statement fits on a single<br>
line.</p>
</blockquote>
<p>若循环体或条件语句可放置一行中时，可以省略大括号；</p>
<pre><code class="language-objectivec">// GOOD:

if (hasSillyName) LaughOutLoud();

for (int i = 0; i &lt; 10; i++) {
  BlowTheHorn();
}
</code></pre>
<pre><code class="language-objectivec">// AVOID:

if (hasSillyName)
  LaughOutLoud();               // AVOID.

for (int i = 0; i &lt; 10; i++)
  BlowTheHorn();                // AVOID.
</code></pre>
<blockquote>
<p>If an <code>if</code> clause has an <code>else</code> clause, both clauses should use braces.</p>
</blockquote>
<p>若 <code>if</code> 语句后有 <code>else</code> 语句，两部分都需要使用大括号。</p>
<pre><code class="language-objectivec">// GOOD:

if (hasBaz) {
  foo();
} else {  // The else goes on the same line as the closing brace.
  bar();
}
</code></pre>
<pre><code class="language-objectivec">// AVOID:

if (hasBaz) foo();
else bar();        // AVOID.

if (hasBaz) {
  foo();
} else bar();      // AVOID.
</code></pre>
<blockquote>
<p>Intentional fall-through to the next case should be documented with a comment<br>
unless the case has no intervening code before the next case.</p>
</blockquote>
<p>除非两个case语句之间没有其他代码，有意添加的case连续执行情况，需要增加注释说明。</p>
<pre><code class="language-objectivec">// GOOD:

switch (i) {
  case 1:
    ...
    break;
  case 2:
    j++;
    // Falls through.
  case 3: {
    int k;
    ...
    break;
  }
  case 4:
  case 5:
  case 6: break;
}
</code></pre>
<h3 id="expressions">表达式（Expressions）</h3>
<blockquote>
<p>Use a space around binary operators and assignments. Omit a space for a unary<br>
operator. Do not add spaces inside parentheses.</p>
</blockquote>
<p>二进制运算符、赋值运算符左右两边都需要添加空格。一元运算符可以省略空格。圆括号（左括号右边、右括号左边）不用空格。</p>
<pre><code class="language-objectivec">// GOOD:

x = 0;
v = w * x + y / z;
v = -y * (x + z);
</code></pre>
<blockquote>
<p>Factors in an expression may omit spaces.</p>
</blockquote>
<p>某些表达式运算符左右可能省略空格。</p>
<pre><code class="language-objectivec">// GOOD:

v = w*x + y/z;
</code></pre>
<h3 id="methodinvocations">方法调动（Method Invocations）</h3>
<blockquote>
<p>Method invocations should be formatted much like method declarations.</p>
</blockquote>
<p>方法调用的格式应与方法声明一致。</p>
<blockquote>
<p>When there's a choice of formatting styles, follow the convention already used<br>
in a given source file. Invocations should have all arguments on one line:</p>
</blockquote>
<p>若源码中有现有的编码规范使用惯例，请保持一致继续使用。方法调用的所有参数都放在一行。</p>
<pre><code class="language-objectivec">// GOOD:

[myObject doFooWith:arg1 name:arg2 error:arg3];
</code></pre>
<blockquote>
<p>or have one argument per line, with colons aligned:</p>
</blockquote>
<p>或每个参数放在单独一行，冒号对齐。</p>
<pre><code class="language-objectivec">// GOOD:

[myObject doFooWith:arg1
               name:arg2
              error:arg3];
</code></pre>
<blockquote>
<p>Don't use any of these styles:</p>
</blockquote>
<p>不要使用下列编码风格：</p>
<pre><code class="language-objectivec">// AVOID:

[myObject doFooWith:arg1 name:arg2  // some lines with &gt;1 arg
              error:arg3];

[myObject doFooWith:arg1
               name:arg2 error:arg3];

[myObject doFooWith:arg1
          name:arg2  // aligning keywords instead of colons
          error:arg3];
</code></pre>
<blockquote>
<p>As with declarations and definitions, when the first keyword is shorter than the<br>
others, indent the later lines by at least four spaces, maintaining colon<br>
alignment:</p>
</blockquote>
<p>与声明和定义一样，当第一个关键字比其他字段短，将后面的参数缩进至少4个空格，并将冒号对齐。</p>
<pre><code class="language-objectivec">// GOOD:

[myObj short:arg1
          longKeyword:arg2
    evenLongerKeyword:arg3
                error:arg4];
</code></pre>
<blockquote>
<p>Invocations containing multiple inlined blocks may have their parameter names<br>
left-aligned at a four space indent.</p>
</blockquote>
<p>方法调用包含多个内嵌block时，将这些参数缩进4个空格，并左对齐。</p>
<h3 id="functioncalls">函数调用（Function Calls）</h3>
<blockquote>
<p>Function calls should include as many parameters as fit on each line, except<br>
where shorter lines are needed for clarity or documentation of the parameters.</p>
</blockquote>
<p>函数调用要尽可能多的将参数填满每一行，如果某些参数需要说明参数含义或添加文档说明，将这行参数不填满整行。</p>
<blockquote>
<p>Continuation lines for function parameters may be indented to align with the<br>
opening parenthesis, or may have a four-space indent.</p>
</blockquote>
<p>换行后的参数需要与函数的左括号对齐，或者使用4个空格进行缩进。</p>
<pre><code class="language-objectivec">// GOOD:

CFArrayRef array = CFArrayCreate(kCFAllocatorDefault, objects, numberOfObjects,
                                 &amp;kCFTypeArrayCallBacks);

NSString *string = NSLocalizedStringWithDefaultValue(@&quot;FEET&quot;, @&quot;DistanceTable&quot;,
    resourceBundle,  @&quot;%@ feet&quot;, @&quot;Distance for multiple feet&quot;);

UpdateTally(scores[x] * y + bases[x],  // Score heuristic.
            x, y, z);

TransformImage(image,
               x1, x2, x3,
               y1, y2, y3,
               z1, z2, z3);
</code></pre>
<blockquote>
<p>Use local variables with descriptive names to shorten function calls and reduce<br>
nesting of calls.</p>
</blockquote>
<p>使用具有描述性名称的局部变量来缩短函数调用和减少内嵌调用。</p>
<pre><code class="language-objectivec">// GOOD:

double scoreHeuristic = scores[x] * y + bases[x];
UpdateTally(scoreHeuristic, x, y, z);

// AVOID
UpdateTally((scores[x] * y + bases[x]), x, y, z);
</code></pre>
<h3 id="exceptions">异常（Exceptions）</h3>
<blockquote>
<p>Format exceptions with <code>@catch</code> and <code>@finally</code> labels on the same line as the<br>
preceding <code>}</code>. Add a space between the <code>@</code> label and the opening brace (<code>{</code>), as<br>
well as between the <code>@catch</code> and the caught object declaration. If you must use<br>
Objective-C exceptions, format them as follows. However, see <a href="index.html#Avoid_Throwing_Exceptions">Avoid Throwing<br>
Exceptions</a> for reasons why you should not be using<br>
exceptions.</p>
</blockquote>
<p>使用 <code>@catch</code> 和 <code>@finally</code> 标签要与左大括号在同一行。标签与左大括号之间添加一个空格， <code>@catch</code> 与异常对象声明之间也添加一个空格。如果必须使用Objective-C异常类型，请按下面方式进行格式化。但是，请参考[避免抛异常（Avoid Throwing Exceptions）](#避免抛异常（Avoid Throwing Exceptions）) 以便了解避免抛出异常的原因。</p>
<pre><code class="language-objectivec">// GOOD:

@try {
  foo();
} @catch (NSException *ex) {
  bar(ex);
} @finally {
  baz();
}
</code></pre>
<h3 id="functionlength">函数长度（Function Length）</h3>
<blockquote>
<p>Prefer small and focused functions.</p>
</blockquote>
<p>推荐小而功能专注的函数。</p>
<blockquote>
<p>Long functions and methods are occasionally appropriate, so no hard limit is<br>
placed on function length. If a function exceeds about 40 lines, think about<br>
whether it can be broken up without harming the structure of the program.</p>
</blockquote>
<p>长方法或者函数某些情况下也是可以的，所以关于函数长度没有固定的限制。如果一个函数长度超过了40个字符，请考虑如何在不破坏代码结构的基础上，将它拆分。</p>
<blockquote>
<p>Even if your long function works perfectly now, someone modifying it in a few<br>
months may add new behavior. This could result in bugs that are hard to find.<br>
Keeping your functions short and simple makes it easier for other people to read<br>
and modify your code.</p>
</blockquote>
<p>即便你现在的长方法可以完美运行，可能几个月后的某些修改会给他添加新特性。这也导致出现问题难以发现。保持函数简练可以使代码易读，利于修改。</p>
<blockquote>
<p>When updating legacy code, consider also breaking long functions into smaller<br>
and more manageable pieces.</p>
</blockquote>
<p>当更新遗留代码时，也需要考虑将长函数分解成更小更利于管理维护的部分。</p>
<h3 id="verticalwhitespace">垂直空白（Vertical Whitespace）</h3>
<blockquote>
<p>Use vertical whitespace sparingly.</p>
</blockquote>
<p>谨慎使用垂直空白。</p>
<blockquote>
<p>To allow more code to be easily viewed on a screen, avoid putting blank lines<br>
just inside the braces of functions.</p>
</blockquote>
<p>为了让更多代码能够一屏展示，在函数大括号内，避免使用空行。</p>
<blockquote>
<p>Limit blank lines to one or two between functions and between logical groups of<br>
code.</p>
</blockquote>
<p>不同函数间或不同代码逻辑组之间，空行限制在1-2行。</p>
<h2 id="objectivecobjectivecstyleexceptions">Objective-C风格异常（Objective-C Style Exceptions）</h2>
<h3 id="indicatingstyleexceptions">指明风格异常（Indicating style exceptions）</h3>
<blockquote>
<p>Lines of code that are not expected to adhere to these style recommendations<br>
require <code>// NOLINT</code> at the end of the line or <code>// NOLINTNEXTLINE</code> at the end of<br>
the previous line. Sometimes it is required that parts of Objective-C code must<br>
ignore these style recommendations (for example code may be machine generated or<br>
code constructs are such that its not possible to style correctly).</p>
</blockquote>
<p>预计不符合这些规范的代码行，需要在行尾添加<code>// NOLINT</code>或者在前一行添加 <code>// NOLINTNEXTLINE</code> 标识。有时一部分代码需要忽略某些推荐的编码风格规范（例如某些机器生成的代码或者某些结构是不可能设置为正式样式的代码）。</p>
<blockquote>
<p>A <code>// NOLINT</code> comment on that line or <code>// NOLINTNEXTLINE</code> on the previous line<br>
can be used to indicate to the reader that code is intentionally ignoring style<br>
guidelines. In addition these annotations can also be picked up by automated<br>
tools such as linters and handle code correctly. Note that there is a single<br>
space between <code>//</code> and <code>NOLINT*</code>.</p>
</blockquote>
<p>一行中的 <code>// NOLINT</code> 标注和前一行的 <code>// NOLINTNEXTLINE</code> 标注可以被用来告诉读者，某些代码是故意忽略遵守使用编码规范的，此外，这些标注也可以让一些自动化工具（如linters）正确处理代码。</p>
<p>注意 <code>//</code> 和 <code>NOLINT*</code>之间有一个空格。</p>
<p><br></br></p>
<style>.bmc-button img{width: 35px !important;margin-bottom: 1px !important;box-shadow: none !important;border: none !important;vertical-align: middle !important;}.bmc-button{padding: 7px 10px 7px 10px !important;line-height: 35px !important;height:51px !important;min-width:217px !important;text-decoration: none !important;display:inline-flex !important;color:#FFFFFF !important;background-color:#FF813F !important;border-radius: 5px !important;border: 1px solid transparent !important;padding: 7px 10px 7px 10px !important;font-size: 22px !important;letter-spacing: 0.6px !important;box-shadow: 0px 1px 2px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;margin: 0 auto !important;font-family:'Cookie', cursive !important;-webkit-box-sizing: border-box !important;box-sizing: border-box !important;-o-transition: 0.3s all linear !important;-webkit-transition: 0.3s all linear !important;-moz-transition: 0.3s all linear !important;-ms-transition: 0.3s all linear !important;transition: 0.3s all linear !important;}.bmc-button:hover, .bmc-button:active, .bmc-button:focus {-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;text-decoration: none !important;box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;opacity: 0.85 !important;color:#FFFFFF !important;}</style><link href="https://fonts.googleapis.com/css?family=Cookie" rel="stylesheet"><a class="bmc-button" target="_blank" href="https://www.buymeacoffee.com/eyzU2NJ"><img src="https://cdn.buymeacoffee.com/buttons/bmc-new-btn-logo.svg" alt="Buy me a coffee"><span style="margin-left:15px;font-size:28px !important;">Buy me a coffee</span></a><!--kg-card-end: markdown-->
    </div>


    <footer class="post-footer">

        <div class="authors">
            <a class="author-box" href="../../../../author/mark/index.html">
                <section class="author-box-content">
                    <div class="author-box-label">Author</div>
                    <h5 class="author-box-name">Mark C.J.</h5>
                    <p>Read more posts by this author.</p>
                </section>
            </a>
        </div>

    </footer>


</section>

<script>
    var images = document.querySelectorAll('.kg-gallery-image img');
    images.forEach(function (image) {
        var container = image.closest('.kg-gallery-image');
        var width = image.attributes.width.value;
        var height = image.attributes.height.value;
        var ratio = width / height;
        container.style.flex = ratio + ' 1 0%';
    })
</script>


            </div>
        </main>

        <div id="sidebar">
    <div class="inner">

            <nav id="menu">
    <header class="major">
        <h2>Menu</h2>
    </header>
    <ul class="links">
        <li class="nav-home "><a href="../../../../index.html">Home</a></li>
        <li class="nav-about-me "><a href="../../../../about-me/index.html">About me</a></li>
    </ul>
</nav>

        <section>
            <header class="major">
                <h2>Recent Posts</h2>
            </header>
            <div class="mini-posts">
                    <article>
                        <h3><a href="../../../../2019/07/10/wwdc19-ios-related-session-list/index.html">WWDC19 iOS Related Session List</a></h3>
                        <p>SwiftUI Introducing SwiftUI: Building Your First App  See SwiftUI in action! Watch as engineers from</p>
                    </article>
                    <article>
                        <h3><a href="index.html">Google Objective-C Style Guide [中英对照]</a></h3>
                        <p>注意：文章原始版权归Google所有，本文档翻译部分归作者Mark所有，只供学习使用，禁止以营利为目的或其他商业使用！  Objective-C is a dynamic, object-oriented extension of C. It's designed</p>
                    </article>
                    <article>
                        <h3><a href="../../../03/21/iosduan-cha-kan-pdfwen-dang-shi-xian-fang-an/index.html">iOS端查看PDF文档实现方案</a></h3>
                        <p>文 · Mark  在不同端查看一些文档时，往往会展现出千奇百怪的格式，呈现给用户的也是不同的展示效果。为了保持原始文稿的格式，保证展现效果的统一，PDF文稿可以很好解决格式在不同端文稿展现格式差异，保持原始文稿的展现效果。  对于移动端的开发工作中，查看PDF也是常见的需求，本文针对iOS端查看PDF文档给出实现方案，包括通过网络端读取和本地读取两种方式查看PDF文档。  读取方式  网络读取</p>
                    </article>
            </div>
        </section>


        <footer id="footer">
            <p class="copyright">&copy; Crazy Mark - All rights reserved<br>
            Design: <a href="https://html5up.net" target="_blank" rel="noopener">HTML5 UP</a>, Published with <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a></p>
        </footer>

    </div>
</div>

    </div>

    <script src="../../../../assets/main/js/jquery.min.js?v=db5bd3ff41"></script>
    <script src="../../../../assets/main/js/browser.min.js?v=db5bd3ff41"></script>
    <script src="../../../../assets/main/js/breakpoints.min.js?v=db5bd3ff41"></script>
    <script src="../../../../assets/main/js/util.js?v=db5bd3ff41"></script>
    <script src="../../../../assets/main/js/main.js?v=db5bd3ff41"></script>

    

</body>
</html>
